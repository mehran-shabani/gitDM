/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * GITDM API
 * Description here.
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AISummary,
  AISummaryList,
  ClinicalReference,
  CreateAISummary,
  Encounter,
  LabResult,
  MedicationOrder,
  PatchedAISummary,
  PatchedClinicalReference,
  PatchedEncounter,
  PatchedLabResult,
  PatchedMedicationOrder,
  PatchedPatient,
  Patient,
  RegenerateAISummary,
  TokenObtainPair,
  TokenRefresh
} from './gitdmApi.schemas';

import { createAxiosInstance } from '../http/axios-instance';

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;



type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * List all AI summaries with optional filtering by patient
 * @summary List AI summaries
 */
export const apiAiSummariesList = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<AISummaryList[]>(
      {url: `/api/ai-summaries`, method: 'GET', signal
    },
      options);
    }
  

export const getApiAiSummariesListQueryKey = () => {
    return [`/api/ai-summaries`] as const;
    }

    
export const getApiAiSummariesListQueryOptions = <TData = Awaited<ReturnType<typeof apiAiSummariesList>>, TError = null>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiAiSummariesListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiAiSummariesList>>> = ({ signal }) => apiAiSummariesList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiAiSummariesListQueryResult = NonNullable<Awaited<ReturnType<typeof apiAiSummariesList>>>
export type ApiAiSummariesListQueryError = null


export function useApiAiSummariesList<TData = Awaited<ReturnType<typeof apiAiSummariesList>>, TError = null>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAiSummariesList>>,
          TError,
          Awaited<ReturnType<typeof apiAiSummariesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAiSummariesList<TData = Awaited<ReturnType<typeof apiAiSummariesList>>, TError = null>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAiSummariesList>>,
          TError,
          Awaited<ReturnType<typeof apiAiSummariesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAiSummariesList<TData = Awaited<ReturnType<typeof apiAiSummariesList>>, TError = null>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List AI summaries
 */

export function useApiAiSummariesList<TData = Awaited<ReturnType<typeof apiAiSummariesList>>, TError = null>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiAiSummariesListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new AI summary using GapGPT/OpenAI
 * @summary Create AI summary
 */
export const apiAiSummariesCreate = (
    createAISummary: CreateAISummary,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<CreateAISummary>(
      {url: `/api/ai-summaries`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createAISummary, signal
    },
      options);
    }
  


export const getApiAiSummariesCreateMutationOptions = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesCreate>>, TError,{data: CreateAISummary}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesCreate>>, TError,{data: CreateAISummary}, TContext> => {

const mutationKey = ['apiAiSummariesCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAiSummariesCreate>>, {data: CreateAISummary}> = (props) => {
          const {data} = props ?? {};

          return  apiAiSummariesCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAiSummariesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAiSummariesCreate>>>
    export type ApiAiSummariesCreateMutationBody = CreateAISummary
    export type ApiAiSummariesCreateMutationError = null

    /**
 * @summary Create AI summary
 */
export const useApiAiSummariesCreate = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesCreate>>, TError,{data: CreateAISummary}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAiSummariesCreate>>,
        TError,
        {data: CreateAISummary},
        TContext
      > => {

      const mutationOptions = getApiAiSummariesCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a specific AI summary by ID
 * @summary Get AI summary
 */
export const apiAiSummariesRetrieve = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<AISummary>(
      {url: `/api/ai-summaries/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getApiAiSummariesRetrieveQueryKey = (id?: number,) => {
    return [`/api/ai-summaries/${id}`] as const;
    }

    
export const getApiAiSummariesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiAiSummariesRetrieve>>, TError = null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiAiSummariesRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiAiSummariesRetrieve>>> = ({ signal }) => apiAiSummariesRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiAiSummariesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiAiSummariesRetrieve>>>
export type ApiAiSummariesRetrieveQueryError = null


export function useApiAiSummariesRetrieve<TData = Awaited<ReturnType<typeof apiAiSummariesRetrieve>>, TError = null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAiSummariesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAiSummariesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAiSummariesRetrieve<TData = Awaited<ReturnType<typeof apiAiSummariesRetrieve>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAiSummariesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAiSummariesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAiSummariesRetrieve<TData = Awaited<ReturnType<typeof apiAiSummariesRetrieve>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get AI summary
 */

export function useApiAiSummariesRetrieve<TData = Awaited<ReturnType<typeof apiAiSummariesRetrieve>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiAiSummariesRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet for AI summaries with GapGPT/OpenAI integration
 * @summary Update AI summary
 */
export const apiAiSummariesUpdate = (
    id: number,
    aISummary: NonReadonly<AISummary>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<AISummary>(
      {url: `/api/ai-summaries/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: aISummary
    },
      options);
    }
  


export const getApiAiSummariesUpdateMutationOptions = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesUpdate>>, TError,{id: number;data: NonReadonly<AISummary>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesUpdate>>, TError,{id: number;data: NonReadonly<AISummary>}, TContext> => {

const mutationKey = ['apiAiSummariesUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAiSummariesUpdate>>, {id: number;data: NonReadonly<AISummary>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiAiSummariesUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAiSummariesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAiSummariesUpdate>>>
    export type ApiAiSummariesUpdateMutationBody = NonReadonly<AISummary>
    export type ApiAiSummariesUpdateMutationError = null

    /**
 * @summary Update AI summary
 */
export const useApiAiSummariesUpdate = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesUpdate>>, TError,{id: number;data: NonReadonly<AISummary>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAiSummariesUpdate>>,
        TError,
        {id: number;data: NonReadonly<AISummary>},
        TContext
      > => {

      const mutationOptions = getApiAiSummariesUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ViewSet for AI summaries with GapGPT/OpenAI integration
 * @summary Partially update AI summary
 */
export const apiAiSummariesPartialUpdate = (
    id: number,
    patchedAISummary: NonReadonly<PatchedAISummary>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<AISummary>(
      {url: `/api/ai-summaries/${id}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedAISummary
    },
      options);
    }
  


export const getApiAiSummariesPartialUpdateMutationOptions = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedAISummary>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedAISummary>}, TContext> => {

const mutationKey = ['apiAiSummariesPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAiSummariesPartialUpdate>>, {id: number;data: NonReadonly<PatchedAISummary>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiAiSummariesPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAiSummariesPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAiSummariesPartialUpdate>>>
    export type ApiAiSummariesPartialUpdateMutationBody = NonReadonly<PatchedAISummary>
    export type ApiAiSummariesPartialUpdateMutationError = null

    /**
 * @summary Partially update AI summary
 */
export const useApiAiSummariesPartialUpdate = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedAISummary>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAiSummariesPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedAISummary>},
        TContext
      > => {

      const mutationOptions = getApiAiSummariesPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete an AI summary
 * @summary Delete AI summary
 */
export const apiAiSummariesDestroy = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<null>(
      {url: `/api/ai-summaries/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getApiAiSummariesDestroyMutationOptions = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['apiAiSummariesDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAiSummariesDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  apiAiSummariesDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAiSummariesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof apiAiSummariesDestroy>>>
    
    export type ApiAiSummariesDestroyMutationError = null

    /**
 * @summary Delete AI summary
 */
export const useApiAiSummariesDestroy = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAiSummariesDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getApiAiSummariesDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Regenerate AI summary for existing record with new content
 * @summary Regenerate AI summary
 */
export const apiAiSummariesRegenerateCreate = (
    id: number,
    regenerateAISummary: RegenerateAISummary,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<AISummary>(
      {url: `/api/ai-summaries/${id}/regenerate`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: regenerateAISummary, signal
    },
      options);
    }
  


export const getApiAiSummariesRegenerateCreateMutationOptions = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesRegenerateCreate>>, TError,{id: number;data: RegenerateAISummary}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesRegenerateCreate>>, TError,{id: number;data: RegenerateAISummary}, TContext> => {

const mutationKey = ['apiAiSummariesRegenerateCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAiSummariesRegenerateCreate>>, {id: number;data: RegenerateAISummary}> = (props) => {
          const {id,data} = props ?? {};

          return  apiAiSummariesRegenerateCreate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAiSummariesRegenerateCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAiSummariesRegenerateCreate>>>
    export type ApiAiSummariesRegenerateCreateMutationBody = RegenerateAISummary
    export type ApiAiSummariesRegenerateCreateMutationError = null

    /**
 * @summary Regenerate AI summary
 */
export const useApiAiSummariesRegenerateCreate = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesRegenerateCreate>>, TError,{id: number;data: RegenerateAISummary}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAiSummariesRegenerateCreate>>,
        TError,
        {id: number;data: RegenerateAISummary},
        TContext
      > => {

      const mutationOptions = getApiAiSummariesRegenerateCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get statistics about AI summaries
 * @summary Get summary statistics
 */
export const apiAiSummariesStatsRetrieve = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<AISummary>(
      {url: `/api/ai-summaries/stats`, method: 'GET', signal
    },
      options);
    }
  

export const getApiAiSummariesStatsRetrieveQueryKey = () => {
    return [`/api/ai-summaries/stats`] as const;
    }

    
export const getApiAiSummariesStatsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>, TError = null>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiAiSummariesStatsRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>> = ({ signal }) => apiAiSummariesStatsRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiAiSummariesStatsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>>
export type ApiAiSummariesStatsRetrieveQueryError = null


export function useApiAiSummariesStatsRetrieve<TData = Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>, TError = null>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAiSummariesStatsRetrieve<TData = Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>, TError = null>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAiSummariesStatsRetrieve<TData = Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>, TError = null>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get summary statistics
 */

export function useApiAiSummariesStatsRetrieve<TData = Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>, TError = null>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiAiSummariesStatsRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Test the AI service connection and generate a simple summary
 * @summary Test AI service
 */
export const apiAiSummariesTestCreate = (
    aISummary: NonReadonly<AISummary>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<AISummary>(
      {url: `/api/ai-summaries/test`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: aISummary, signal
    },
      options);
    }
  


export const getApiAiSummariesTestCreateMutationOptions = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesTestCreate>>, TError,{data: NonReadonly<AISummary>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesTestCreate>>, TError,{data: NonReadonly<AISummary>}, TContext> => {

const mutationKey = ['apiAiSummariesTestCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAiSummariesTestCreate>>, {data: NonReadonly<AISummary>}> = (props) => {
          const {data} = props ?? {};

          return  apiAiSummariesTestCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAiSummariesTestCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAiSummariesTestCreate>>>
    export type ApiAiSummariesTestCreateMutationBody = NonReadonly<AISummary>
    export type ApiAiSummariesTestCreateMutationError = null

    /**
 * @summary Test AI service
 */
export const useApiAiSummariesTestCreate = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesTestCreate>>, TError,{data: NonReadonly<AISummary>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAiSummariesTestCreate>>,
        TError,
        {data: NonReadonly<AISummary>},
        TContext
      > => {

      const mutationOptions = getApiAiSummariesTestCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Test the clinical references linking function with sample text
 * @summary Test clinical references linking
 */
export const apiAiSummariesTestReferencesCreate = (
    aISummary: NonReadonly<AISummary>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<AISummary>(
      {url: `/api/ai-summaries/test-references`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: aISummary, signal
    },
      options);
    }
  


export const getApiAiSummariesTestReferencesCreateMutationOptions = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesTestReferencesCreate>>, TError,{data: NonReadonly<AISummary>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesTestReferencesCreate>>, TError,{data: NonReadonly<AISummary>}, TContext> => {

const mutationKey = ['apiAiSummariesTestReferencesCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAiSummariesTestReferencesCreate>>, {data: NonReadonly<AISummary>}> = (props) => {
          const {data} = props ?? {};

          return  apiAiSummariesTestReferencesCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAiSummariesTestReferencesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAiSummariesTestReferencesCreate>>>
    export type ApiAiSummariesTestReferencesCreateMutationBody = NonReadonly<AISummary>
    export type ApiAiSummariesTestReferencesCreateMutationError = null

    /**
 * @summary Test clinical references linking
 */
export const useApiAiSummariesTestReferencesCreate = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesTestReferencesCreate>>, TError,{data: NonReadonly<AISummary>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAiSummariesTestReferencesCreate>>,
        TError,
        {data: NonReadonly<AISummary>},
        TContext
      > => {

      const mutationOptions = getApiAiSummariesTestReferencesCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Takes a set of user credentials and returns an access and refresh JSON web
token pair to prove the authentication of those credentials.
 * @summary Obtain JWT token pair
 */
export const apiApiTokenCreate = (
    tokenObtainPair: NonReadonly<TokenObtainPair>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<TokenObtainPair>(
      {url: `/api/api/token`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: tokenObtainPair, signal
    },
      options);
    }
  


export const getApiApiTokenCreateMutationOptions = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiApiTokenCreate>>, TError,{data: NonReadonly<TokenObtainPair>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiApiTokenCreate>>, TError,{data: NonReadonly<TokenObtainPair>}, TContext> => {

const mutationKey = ['apiApiTokenCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiApiTokenCreate>>, {data: NonReadonly<TokenObtainPair>}> = (props) => {
          const {data} = props ?? {};

          return  apiApiTokenCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiApiTokenCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiApiTokenCreate>>>
    export type ApiApiTokenCreateMutationBody = NonReadonly<TokenObtainPair>
    export type ApiApiTokenCreateMutationError = null

    /**
 * @summary Obtain JWT token pair
 */
export const useApiApiTokenCreate = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiApiTokenCreate>>, TError,{data: NonReadonly<TokenObtainPair>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiApiTokenCreate>>,
        TError,
        {data: NonReadonly<TokenObtainPair>},
        TContext
      > => {

      const mutationOptions = getApiApiTokenCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Takes a refresh type JSON web token and returns an access type JSON web
token if the refresh token is valid.
 * @summary Refresh JWT access token
 */
export const apiApiTokenRefreshCreate = (
    tokenRefresh: NonReadonly<TokenRefresh>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<TokenRefresh>(
      {url: `/api/api/token/refresh`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: tokenRefresh, signal
    },
      options);
    }
  


export const getApiApiTokenRefreshCreateMutationOptions = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiApiTokenRefreshCreate>>, TError,{data: NonReadonly<TokenRefresh>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiApiTokenRefreshCreate>>, TError,{data: NonReadonly<TokenRefresh>}, TContext> => {

const mutationKey = ['apiApiTokenRefreshCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiApiTokenRefreshCreate>>, {data: NonReadonly<TokenRefresh>}> = (props) => {
          const {data} = props ?? {};

          return  apiApiTokenRefreshCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiApiTokenRefreshCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiApiTokenRefreshCreate>>>
    export type ApiApiTokenRefreshCreateMutationBody = NonReadonly<TokenRefresh>
    export type ApiApiTokenRefreshCreateMutationError = null

    /**
 * @summary Refresh JWT access token
 */
export const useApiApiTokenRefreshCreate = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiApiTokenRefreshCreate>>, TError,{data: NonReadonly<TokenRefresh>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiApiTokenRefreshCreate>>,
        TError,
        {data: NonReadonly<TokenRefresh>},
        TContext
      > => {

      const mutationOptions = getApiApiTokenRefreshCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary List encounters
 */
export const apiEncountersList = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<Encounter[]>(
      {url: `/api/encounters`, method: 'GET', signal
    },
      options);
    }
  

export const getApiEncountersListQueryKey = () => {
    return [`/api/encounters`] as const;
    }

    
export const getApiEncountersListQueryOptions = <TData = Awaited<ReturnType<typeof apiEncountersList>>, TError = null>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiEncountersList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiEncountersListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiEncountersList>>> = ({ signal }) => apiEncountersList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiEncountersList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiEncountersListQueryResult = NonNullable<Awaited<ReturnType<typeof apiEncountersList>>>
export type ApiEncountersListQueryError = null


export function useApiEncountersList<TData = Awaited<ReturnType<typeof apiEncountersList>>, TError = null>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiEncountersList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiEncountersList>>,
          TError,
          Awaited<ReturnType<typeof apiEncountersList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiEncountersList<TData = Awaited<ReturnType<typeof apiEncountersList>>, TError = null>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiEncountersList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiEncountersList>>,
          TError,
          Awaited<ReturnType<typeof apiEncountersList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiEncountersList<TData = Awaited<ReturnType<typeof apiEncountersList>>, TError = null>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiEncountersList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List encounters
 */

export function useApiEncountersList<TData = Awaited<ReturnType<typeof apiEncountersList>>, TError = null>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiEncountersList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiEncountersListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create encounter
 */
export const apiEncountersCreate = (
    encounter: NonReadonly<Encounter>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<Encounter>(
      {url: `/api/encounters`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: encounter, signal
    },
      options);
    }
  


export const getApiEncountersCreateMutationOptions = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiEncountersCreate>>, TError,{data: NonReadonly<Encounter>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiEncountersCreate>>, TError,{data: NonReadonly<Encounter>}, TContext> => {

const mutationKey = ['apiEncountersCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiEncountersCreate>>, {data: NonReadonly<Encounter>}> = (props) => {
          const {data} = props ?? {};

          return  apiEncountersCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiEncountersCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiEncountersCreate>>>
    export type ApiEncountersCreateMutationBody = NonReadonly<Encounter>
    export type ApiEncountersCreateMutationError = null

    /**
 * @summary Create encounter
 */
export const useApiEncountersCreate = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiEncountersCreate>>, TError,{data: NonReadonly<Encounter>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiEncountersCreate>>,
        TError,
        {data: NonReadonly<Encounter>},
        TContext
      > => {

      const mutationOptions = getApiEncountersCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get encounter
 */
export const apiEncountersRetrieve = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<Encounter>(
      {url: `/api/encounters/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getApiEncountersRetrieveQueryKey = (id?: number,) => {
    return [`/api/encounters/${id}`] as const;
    }

    
export const getApiEncountersRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiEncountersRetrieve>>, TError = null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiEncountersRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiEncountersRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiEncountersRetrieve>>> = ({ signal }) => apiEncountersRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiEncountersRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiEncountersRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiEncountersRetrieve>>>
export type ApiEncountersRetrieveQueryError = null


export function useApiEncountersRetrieve<TData = Awaited<ReturnType<typeof apiEncountersRetrieve>>, TError = null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiEncountersRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiEncountersRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiEncountersRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiEncountersRetrieve<TData = Awaited<ReturnType<typeof apiEncountersRetrieve>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiEncountersRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiEncountersRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiEncountersRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiEncountersRetrieve<TData = Awaited<ReturnType<typeof apiEncountersRetrieve>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiEncountersRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get encounter
 */

export function useApiEncountersRetrieve<TData = Awaited<ReturnType<typeof apiEncountersRetrieve>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiEncountersRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiEncountersRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update encounter
 */
export const apiEncountersUpdate = (
    id: number,
    encounter: NonReadonly<Encounter>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<Encounter>(
      {url: `/api/encounters/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: encounter
    },
      options);
    }
  


export const getApiEncountersUpdateMutationOptions = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiEncountersUpdate>>, TError,{id: number;data: NonReadonly<Encounter>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiEncountersUpdate>>, TError,{id: number;data: NonReadonly<Encounter>}, TContext> => {

const mutationKey = ['apiEncountersUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiEncountersUpdate>>, {id: number;data: NonReadonly<Encounter>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiEncountersUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiEncountersUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiEncountersUpdate>>>
    export type ApiEncountersUpdateMutationBody = NonReadonly<Encounter>
    export type ApiEncountersUpdateMutationError = null

    /**
 * @summary Update encounter
 */
export const useApiEncountersUpdate = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiEncountersUpdate>>, TError,{id: number;data: NonReadonly<Encounter>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiEncountersUpdate>>,
        TError,
        {id: number;data: NonReadonly<Encounter>},
        TContext
      > => {

      const mutationOptions = getApiEncountersUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Partially update encounter
 */
export const apiEncountersPartialUpdate = (
    id: number,
    patchedEncounter: NonReadonly<PatchedEncounter>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<Encounter>(
      {url: `/api/encounters/${id}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedEncounter
    },
      options);
    }
  


export const getApiEncountersPartialUpdateMutationOptions = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiEncountersPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedEncounter>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiEncountersPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedEncounter>}, TContext> => {

const mutationKey = ['apiEncountersPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiEncountersPartialUpdate>>, {id: number;data: NonReadonly<PatchedEncounter>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiEncountersPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiEncountersPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiEncountersPartialUpdate>>>
    export type ApiEncountersPartialUpdateMutationBody = NonReadonly<PatchedEncounter>
    export type ApiEncountersPartialUpdateMutationError = null

    /**
 * @summary Partially update encounter
 */
export const useApiEncountersPartialUpdate = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiEncountersPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedEncounter>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiEncountersPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedEncounter>},
        TContext
      > => {

      const mutationOptions = getApiEncountersPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Delete encounter
 */
export const apiEncountersDestroy = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<null>(
      {url: `/api/encounters/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getApiEncountersDestroyMutationOptions = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiEncountersDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiEncountersDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['apiEncountersDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiEncountersDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  apiEncountersDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiEncountersDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof apiEncountersDestroy>>>
    
    export type ApiEncountersDestroyMutationError = null

    /**
 * @summary Delete encounter
 */
export const useApiEncountersDestroy = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiEncountersDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiEncountersDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getApiEncountersDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary List lab results
 */
export const apiLabsList = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<LabResult[]>(
      {url: `/api/labs`, method: 'GET', signal
    },
      options);
    }
  

export const getApiLabsListQueryKey = () => {
    return [`/api/labs`] as const;
    }

    
export const getApiLabsListQueryOptions = <TData = Awaited<ReturnType<typeof apiLabsList>>, TError = null>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiLabsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiLabsListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiLabsList>>> = ({ signal }) => apiLabsList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiLabsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiLabsListQueryResult = NonNullable<Awaited<ReturnType<typeof apiLabsList>>>
export type ApiLabsListQueryError = null


export function useApiLabsList<TData = Awaited<ReturnType<typeof apiLabsList>>, TError = null>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiLabsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiLabsList>>,
          TError,
          Awaited<ReturnType<typeof apiLabsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiLabsList<TData = Awaited<ReturnType<typeof apiLabsList>>, TError = null>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiLabsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiLabsList>>,
          TError,
          Awaited<ReturnType<typeof apiLabsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiLabsList<TData = Awaited<ReturnType<typeof apiLabsList>>, TError = null>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiLabsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List lab results
 */

export function useApiLabsList<TData = Awaited<ReturnType<typeof apiLabsList>>, TError = null>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiLabsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiLabsListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create lab result
 */
export const apiLabsCreate = (
    labResult: NonReadonly<LabResult>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<LabResult>(
      {url: `/api/labs`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: labResult, signal
    },
      options);
    }
  


export const getApiLabsCreateMutationOptions = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiLabsCreate>>, TError,{data: NonReadonly<LabResult>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiLabsCreate>>, TError,{data: NonReadonly<LabResult>}, TContext> => {

const mutationKey = ['apiLabsCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiLabsCreate>>, {data: NonReadonly<LabResult>}> = (props) => {
          const {data} = props ?? {};

          return  apiLabsCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiLabsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiLabsCreate>>>
    export type ApiLabsCreateMutationBody = NonReadonly<LabResult>
    export type ApiLabsCreateMutationError = null

    /**
 * @summary Create lab result
 */
export const useApiLabsCreate = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiLabsCreate>>, TError,{data: NonReadonly<LabResult>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiLabsCreate>>,
        TError,
        {data: NonReadonly<LabResult>},
        TContext
      > => {

      const mutationOptions = getApiLabsCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get lab result
 */
export const apiLabsRetrieve = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<LabResult>(
      {url: `/api/labs/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getApiLabsRetrieveQueryKey = (id?: number,) => {
    return [`/api/labs/${id}`] as const;
    }

    
export const getApiLabsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiLabsRetrieve>>, TError = null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiLabsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiLabsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiLabsRetrieve>>> = ({ signal }) => apiLabsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiLabsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiLabsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiLabsRetrieve>>>
export type ApiLabsRetrieveQueryError = null


export function useApiLabsRetrieve<TData = Awaited<ReturnType<typeof apiLabsRetrieve>>, TError = null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiLabsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiLabsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiLabsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiLabsRetrieve<TData = Awaited<ReturnType<typeof apiLabsRetrieve>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiLabsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiLabsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiLabsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiLabsRetrieve<TData = Awaited<ReturnType<typeof apiLabsRetrieve>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiLabsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get lab result
 */

export function useApiLabsRetrieve<TData = Awaited<ReturnType<typeof apiLabsRetrieve>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiLabsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiLabsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update lab result
 */
export const apiLabsUpdate = (
    id: number,
    labResult: NonReadonly<LabResult>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<LabResult>(
      {url: `/api/labs/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: labResult
    },
      options);
    }
  


export const getApiLabsUpdateMutationOptions = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiLabsUpdate>>, TError,{id: number;data: NonReadonly<LabResult>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiLabsUpdate>>, TError,{id: number;data: NonReadonly<LabResult>}, TContext> => {

const mutationKey = ['apiLabsUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiLabsUpdate>>, {id: number;data: NonReadonly<LabResult>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiLabsUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiLabsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiLabsUpdate>>>
    export type ApiLabsUpdateMutationBody = NonReadonly<LabResult>
    export type ApiLabsUpdateMutationError = null

    /**
 * @summary Update lab result
 */
export const useApiLabsUpdate = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiLabsUpdate>>, TError,{id: number;data: NonReadonly<LabResult>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiLabsUpdate>>,
        TError,
        {id: number;data: NonReadonly<LabResult>},
        TContext
      > => {

      const mutationOptions = getApiLabsUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Partially update lab result
 */
export const apiLabsPartialUpdate = (
    id: number,
    patchedLabResult: NonReadonly<PatchedLabResult>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<LabResult>(
      {url: `/api/labs/${id}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedLabResult
    },
      options);
    }
  


export const getApiLabsPartialUpdateMutationOptions = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiLabsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedLabResult>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiLabsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedLabResult>}, TContext> => {

const mutationKey = ['apiLabsPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiLabsPartialUpdate>>, {id: number;data: NonReadonly<PatchedLabResult>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiLabsPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiLabsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiLabsPartialUpdate>>>
    export type ApiLabsPartialUpdateMutationBody = NonReadonly<PatchedLabResult>
    export type ApiLabsPartialUpdateMutationError = null

    /**
 * @summary Partially update lab result
 */
export const useApiLabsPartialUpdate = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiLabsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedLabResult>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiLabsPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedLabResult>},
        TContext
      > => {

      const mutationOptions = getApiLabsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Delete lab result
 */
export const apiLabsDestroy = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<null>(
      {url: `/api/labs/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getApiLabsDestroyMutationOptions = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiLabsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiLabsDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['apiLabsDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiLabsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  apiLabsDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiLabsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof apiLabsDestroy>>>
    
    export type ApiLabsDestroyMutationError = null

    /**
 * @summary Delete lab result
 */
export const useApiLabsDestroy = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiLabsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiLabsDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getApiLabsDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary List medication orders
 */
export const apiMedsList = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<MedicationOrder[]>(
      {url: `/api/meds`, method: 'GET', signal
    },
      options);
    }
  

export const getApiMedsListQueryKey = () => {
    return [`/api/meds`] as const;
    }

    
export const getApiMedsListQueryOptions = <TData = Awaited<ReturnType<typeof apiMedsList>>, TError = null>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMedsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiMedsListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiMedsList>>> = ({ signal }) => apiMedsList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiMedsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiMedsListQueryResult = NonNullable<Awaited<ReturnType<typeof apiMedsList>>>
export type ApiMedsListQueryError = null


export function useApiMedsList<TData = Awaited<ReturnType<typeof apiMedsList>>, TError = null>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMedsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiMedsList>>,
          TError,
          Awaited<ReturnType<typeof apiMedsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiMedsList<TData = Awaited<ReturnType<typeof apiMedsList>>, TError = null>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMedsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiMedsList>>,
          TError,
          Awaited<ReturnType<typeof apiMedsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiMedsList<TData = Awaited<ReturnType<typeof apiMedsList>>, TError = null>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMedsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List medication orders
 */

export function useApiMedsList<TData = Awaited<ReturnType<typeof apiMedsList>>, TError = null>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMedsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiMedsListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create medication order
 */
export const apiMedsCreate = (
    medicationOrder: NonReadonly<MedicationOrder>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<MedicationOrder>(
      {url: `/api/meds`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: medicationOrder, signal
    },
      options);
    }
  


export const getApiMedsCreateMutationOptions = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiMedsCreate>>, TError,{data: NonReadonly<MedicationOrder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiMedsCreate>>, TError,{data: NonReadonly<MedicationOrder>}, TContext> => {

const mutationKey = ['apiMedsCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiMedsCreate>>, {data: NonReadonly<MedicationOrder>}> = (props) => {
          const {data} = props ?? {};

          return  apiMedsCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiMedsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiMedsCreate>>>
    export type ApiMedsCreateMutationBody = NonReadonly<MedicationOrder>
    export type ApiMedsCreateMutationError = null

    /**
 * @summary Create medication order
 */
export const useApiMedsCreate = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiMedsCreate>>, TError,{data: NonReadonly<MedicationOrder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiMedsCreate>>,
        TError,
        {data: NonReadonly<MedicationOrder>},
        TContext
      > => {

      const mutationOptions = getApiMedsCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get medication order
 */
export const apiMedsRetrieve = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<MedicationOrder>(
      {url: `/api/meds/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getApiMedsRetrieveQueryKey = (id?: number,) => {
    return [`/api/meds/${id}`] as const;
    }

    
export const getApiMedsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiMedsRetrieve>>, TError = null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMedsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiMedsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiMedsRetrieve>>> = ({ signal }) => apiMedsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiMedsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiMedsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiMedsRetrieve>>>
export type ApiMedsRetrieveQueryError = null


export function useApiMedsRetrieve<TData = Awaited<ReturnType<typeof apiMedsRetrieve>>, TError = null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMedsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiMedsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiMedsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiMedsRetrieve<TData = Awaited<ReturnType<typeof apiMedsRetrieve>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMedsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiMedsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiMedsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiMedsRetrieve<TData = Awaited<ReturnType<typeof apiMedsRetrieve>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMedsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get medication order
 */

export function useApiMedsRetrieve<TData = Awaited<ReturnType<typeof apiMedsRetrieve>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMedsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiMedsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update medication order
 */
export const apiMedsUpdate = (
    id: number,
    medicationOrder: NonReadonly<MedicationOrder>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<MedicationOrder>(
      {url: `/api/meds/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: medicationOrder
    },
      options);
    }
  


export const getApiMedsUpdateMutationOptions = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiMedsUpdate>>, TError,{id: number;data: NonReadonly<MedicationOrder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiMedsUpdate>>, TError,{id: number;data: NonReadonly<MedicationOrder>}, TContext> => {

const mutationKey = ['apiMedsUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiMedsUpdate>>, {id: number;data: NonReadonly<MedicationOrder>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiMedsUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiMedsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiMedsUpdate>>>
    export type ApiMedsUpdateMutationBody = NonReadonly<MedicationOrder>
    export type ApiMedsUpdateMutationError = null

    /**
 * @summary Update medication order
 */
export const useApiMedsUpdate = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiMedsUpdate>>, TError,{id: number;data: NonReadonly<MedicationOrder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiMedsUpdate>>,
        TError,
        {id: number;data: NonReadonly<MedicationOrder>},
        TContext
      > => {

      const mutationOptions = getApiMedsUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Partially update medication order
 */
export const apiMedsPartialUpdate = (
    id: number,
    patchedMedicationOrder: NonReadonly<PatchedMedicationOrder>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<MedicationOrder>(
      {url: `/api/meds/${id}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedMedicationOrder
    },
      options);
    }
  


export const getApiMedsPartialUpdateMutationOptions = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiMedsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedMedicationOrder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiMedsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedMedicationOrder>}, TContext> => {

const mutationKey = ['apiMedsPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiMedsPartialUpdate>>, {id: number;data: NonReadonly<PatchedMedicationOrder>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiMedsPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiMedsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiMedsPartialUpdate>>>
    export type ApiMedsPartialUpdateMutationBody = NonReadonly<PatchedMedicationOrder>
    export type ApiMedsPartialUpdateMutationError = null

    /**
 * @summary Partially update medication order
 */
export const useApiMedsPartialUpdate = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiMedsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedMedicationOrder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiMedsPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedMedicationOrder>},
        TContext
      > => {

      const mutationOptions = getApiMedsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Delete medication order
 */
export const apiMedsDestroy = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<null>(
      {url: `/api/meds/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getApiMedsDestroyMutationOptions = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiMedsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiMedsDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['apiMedsDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiMedsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  apiMedsDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiMedsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof apiMedsDestroy>>>
    
    export type ApiMedsDestroyMutationError = null

    /**
 * @summary Delete medication order
 */
export const useApiMedsDestroy = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiMedsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiMedsDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getApiMedsDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary List patients
 */
export const apiPatientsList = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<Patient[]>(
      {url: `/api/patients`, method: 'GET', signal
    },
      options);
    }
  

export const getApiPatientsListQueryKey = () => {
    return [`/api/patients`] as const;
    }

    
export const getApiPatientsListQueryOptions = <TData = Awaited<ReturnType<typeof apiPatientsList>>, TError = null>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatientsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiPatientsListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiPatientsList>>> = ({ signal }) => apiPatientsList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiPatientsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiPatientsListQueryResult = NonNullable<Awaited<ReturnType<typeof apiPatientsList>>>
export type ApiPatientsListQueryError = null


export function useApiPatientsList<TData = Awaited<ReturnType<typeof apiPatientsList>>, TError = null>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatientsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiPatientsList>>,
          TError,
          Awaited<ReturnType<typeof apiPatientsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiPatientsList<TData = Awaited<ReturnType<typeof apiPatientsList>>, TError = null>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatientsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiPatientsList>>,
          TError,
          Awaited<ReturnType<typeof apiPatientsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiPatientsList<TData = Awaited<ReturnType<typeof apiPatientsList>>, TError = null>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatientsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List patients
 */

export function useApiPatientsList<TData = Awaited<ReturnType<typeof apiPatientsList>>, TError = null>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatientsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiPatientsListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create patient
 */
export const apiPatientsCreate = (
    patient: NonReadonly<Patient>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<Patient>(
      {url: `/api/patients`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: patient, signal
    },
      options);
    }
  


export const getApiPatientsCreateMutationOptions = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiPatientsCreate>>, TError,{data: NonReadonly<Patient>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiPatientsCreate>>, TError,{data: NonReadonly<Patient>}, TContext> => {

const mutationKey = ['apiPatientsCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiPatientsCreate>>, {data: NonReadonly<Patient>}> = (props) => {
          const {data} = props ?? {};

          return  apiPatientsCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiPatientsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiPatientsCreate>>>
    export type ApiPatientsCreateMutationBody = NonReadonly<Patient>
    export type ApiPatientsCreateMutationError = null

    /**
 * @summary Create patient
 */
export const useApiPatientsCreate = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiPatientsCreate>>, TError,{data: NonReadonly<Patient>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiPatientsCreate>>,
        TError,
        {data: NonReadonly<Patient>},
        TContext
      > => {

      const mutationOptions = getApiPatientsCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get patient
 */
export const apiPatientsRetrieve = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<Patient>(
      {url: `/api/patients/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getApiPatientsRetrieveQueryKey = (id?: number,) => {
    return [`/api/patients/${id}`] as const;
    }

    
export const getApiPatientsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiPatientsRetrieve>>, TError = null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatientsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiPatientsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiPatientsRetrieve>>> = ({ signal }) => apiPatientsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiPatientsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiPatientsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiPatientsRetrieve>>>
export type ApiPatientsRetrieveQueryError = null


export function useApiPatientsRetrieve<TData = Awaited<ReturnType<typeof apiPatientsRetrieve>>, TError = null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatientsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiPatientsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiPatientsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiPatientsRetrieve<TData = Awaited<ReturnType<typeof apiPatientsRetrieve>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatientsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiPatientsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiPatientsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiPatientsRetrieve<TData = Awaited<ReturnType<typeof apiPatientsRetrieve>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatientsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get patient
 */

export function useApiPatientsRetrieve<TData = Awaited<ReturnType<typeof apiPatientsRetrieve>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatientsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiPatientsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update patient
 */
export const apiPatientsUpdate = (
    id: number,
    patient: NonReadonly<Patient>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<Patient>(
      {url: `/api/patients/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: patient
    },
      options);
    }
  


export const getApiPatientsUpdateMutationOptions = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiPatientsUpdate>>, TError,{id: number;data: NonReadonly<Patient>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiPatientsUpdate>>, TError,{id: number;data: NonReadonly<Patient>}, TContext> => {

const mutationKey = ['apiPatientsUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiPatientsUpdate>>, {id: number;data: NonReadonly<Patient>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiPatientsUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiPatientsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiPatientsUpdate>>>
    export type ApiPatientsUpdateMutationBody = NonReadonly<Patient>
    export type ApiPatientsUpdateMutationError = null

    /**
 * @summary Update patient
 */
export const useApiPatientsUpdate = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiPatientsUpdate>>, TError,{id: number;data: NonReadonly<Patient>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiPatientsUpdate>>,
        TError,
        {id: number;data: NonReadonly<Patient>},
        TContext
      > => {

      const mutationOptions = getApiPatientsUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Partially update patient
 */
export const apiPatientsPartialUpdate = (
    id: number,
    patchedPatient: NonReadonly<PatchedPatient>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<Patient>(
      {url: `/api/patients/${id}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedPatient
    },
      options);
    }
  


export const getApiPatientsPartialUpdateMutationOptions = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiPatientsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedPatient>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiPatientsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedPatient>}, TContext> => {

const mutationKey = ['apiPatientsPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiPatientsPartialUpdate>>, {id: number;data: NonReadonly<PatchedPatient>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiPatientsPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiPatientsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiPatientsPartialUpdate>>>
    export type ApiPatientsPartialUpdateMutationBody = NonReadonly<PatchedPatient>
    export type ApiPatientsPartialUpdateMutationError = null

    /**
 * @summary Partially update patient
 */
export const useApiPatientsPartialUpdate = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiPatientsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedPatient>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiPatientsPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedPatient>},
        TContext
      > => {

      const mutationOptions = getApiPatientsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Delete patient
 */
export const apiPatientsDestroy = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<null>(
      {url: `/api/patients/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getApiPatientsDestroyMutationOptions = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiPatientsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiPatientsDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['apiPatientsDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiPatientsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  apiPatientsDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiPatientsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof apiPatientsDestroy>>>
    
    export type ApiPatientsDestroyMutationError = null

    /**
 * @summary Delete patient
 */
export const useApiPatientsDestroy = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiPatientsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiPatientsDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getApiPatientsDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ÿ™ÿß€åŸÖ‚ÄåŸÑÿß€åŸÜ ÿ™ÿ¨ŸÖ€åÿπ‚Äåÿ¥ÿØŸá €å⁄© ÿ®€åŸÖÿßÿ± ÿ±ÿß ÿ®ÿ±ŸÖ€å‚Äå⁄Øÿ±ÿØÿßŸÜÿØÿå ÿ¥ÿßŸÖŸÑ ŸÖŸàÿßÿ¨Ÿáÿßÿ™ ÿ®ÿßŸÑ€åŸÜ€åÿå ŸÜÿ™ÿß€åÿ¨ ÿ¢ÿ≤ŸÖÿß€åÿ¥ÿå ÿØÿ≥ÿ™Ÿàÿ±Ÿáÿß€å ÿØÿßÿ±Ÿà€å€å Ÿà ÿÆŸÑÿßÿµŸá‚ÄåŸáÿß€å ÿ™ŸàŸÑ€åÿØÿ¥ÿØŸá ÿ™Ÿàÿ≥ÿ∑ ÿ≤€åÿ±ÿ≥€åÿ≥ÿ™ŸÖ ŸáŸàÿ¥‚ÄåŸÖÿµŸÜŸàÿπ€å.

ÿ¨ÿ≤ÿ¶€åÿßÿ™:
- ÿß€åŸÜ ÿß⁄©ÿ¥ŸÜ ÿ®ÿ±ÿß€å €å⁄© ÿ®€åŸÖÿßÿ± ŸÖÿ¥ÿÆÿµ (ÿ®ÿ± Ÿæÿß€åŸá pk/URL) ÿßÿ¨ÿ±ÿß ŸÖ€å‚Äåÿ¥ŸàÿØ Ÿà ŸÖÿ¨ŸÖŸàÿπŸá‚ÄåŸáÿß€å ŸÖÿ±ÿ™ÿ®ÿ∑ ÿ±ÿß ÿ¨ÿØÿß⁄ØÿßŸÜŸá Ÿàÿß⁄©ÿ¥€å Ÿà ÿ≥ÿ±€åÿßŸÑÿß€åÿ≤ ŸÖ€å‚Äå⁄©ŸÜÿØ.
- ŸÖÿ≠ÿØŸàÿØ€åÿ™‚ÄåŸáÿß:
- Ÿæÿßÿ±ÿßŸÖÿ™ÿ± ⁄©Ÿàÿ¶ÿ±€å `limit` ÿ™ÿπ€å€åŸÜ‚Äå⁄©ŸÜŸÜÿØŸá ÿ≠ÿØÿß⁄©ÿ´ÿ± ÿ™ÿπÿØÿßÿØ ÿ¢€åÿ™ŸÖ‚ÄåŸáÿß ÿ®ÿ±ÿß€å Ÿáÿ± €å⁄© ÿßÿ≤ ŸÜŸàÿπ‚ÄåŸáÿß€å Encounterÿå LabResult Ÿà MedicationOrder ÿßÿ≥ÿ™. ŸÖŸÇÿØÿßÿ± Ÿæ€åÿ¥‚ÄåŸÅÿ±ÿ∂ 100 Ÿà ÿ®€åÿ¥€åŸÜŸá ŸÖÿ¨ÿßÿ≤ 500 ÿßÿ≥ÿ™ (ÿß⁄Øÿ± ŸÖŸÇÿØÿßÿ± ÿ®ÿ≤ÿ±⁄Ø‚Äåÿ™ÿ± ÿßÿ±ÿ≥ÿßŸÑ ÿ¥ŸàÿØ ÿ®Ÿá 500 ÿ™ŸÇŸÑ€åŸÑ ŸÖ€å‚Äå€åÿßÿ®ÿØ).
- AISummaryŸáÿß ŸÖÿ≥ÿ™ŸÇŸÑ ÿßÿ≤ `limit` ŸáŸÖŸàÿßÿ±Ÿá ÿ™ÿß 5 ŸÖŸàÿ±ÿØ ÿßÿÆ€åÿ± (ÿ®ÿ± ÿßÿ≥ÿßÿ≥ `created_at` ŸÜÿ≤ŸàŸÑ€å) ŸÖÿ≠ÿØŸàÿØ ŸÖ€å‚Äåÿ¥ŸàŸÜÿØ.
- ÿØÿßÿØŸá‚ÄåŸáÿß€å ÿ®ÿßÿ≤⁄Øÿ±ÿØÿßŸÜÿØŸá ÿ¥ÿØŸá:
- patient: ÿØÿßÿØŸá ÿ≥ÿ±€åÿßŸÑÿß€åÿ≤ÿ¥ÿØŸáŸî ÿ®€åŸÖÿßÿ±
- encounters: ŸÑ€åÿ≥ÿ™ ÿ≥ÿ±€åÿßŸÑÿß€åÿ≤ÿ¥ÿØŸáŸî EncounterŸáÿß ŸÖÿ±ÿ™ÿ®‚Äåÿ¥ÿØŸá ÿ®ÿ± ÿßÿ≥ÿßÿ≥ `occured_at` ŸÜÿ≤ŸàŸÑ€å (ÿ™ÿß `limit`)
- labs: ŸÑ€åÿ≥ÿ™ ÿ≥ÿ±€åÿßŸÑÿß€åÿ≤ÿ¥ÿØŸáŸî LabResultŸáÿß ŸÖÿ±ÿ™ÿ®‚Äåÿ¥ÿØŸá ÿ®ÿ± ÿßÿ≥ÿßÿ≥ `taken_at` ŸÜÿ≤ŸàŸÑ€å (ÿ™ÿß `limit`)
- medications: ŸÑ€åÿ≥ÿ™ ÿ≥ÿ±€åÿßŸÑÿß€åÿ≤ÿ¥ÿØŸáŸî MedicationOrderŸáÿß ŸÖÿ±ÿ™ÿ®‚Äåÿ¥ÿØŸá ÿ®ÿ± ÿßÿ≥ÿßÿ≥ `start_date` ŸÜÿ≤ŸàŸÑ€å (ÿ™ÿß `limit`)
- ai_summaries: ŸÑ€åÿ≥ÿ™ ÿ≥ÿ±€åÿßŸÑÿß€åÿ≤ÿ¥ÿØŸáŸî AISummaryŸáÿß (ÿ≠ÿØÿß⁄©ÿ´ÿ± 5 ŸÖŸàÿ±ÿØÿå ŸÖÿ±ÿ™ÿ® ÿ®ÿ± ÿßÿ≥ÿßÿ≥ `created_at` ŸÜÿ≤ŸàŸÑ€å)

ŸÜ⁄©ÿßÿ™ ŸÖÿ±ÿ™ÿ®ÿ∑ ÿ®ÿß ŸáŸàÿ¥‚ÄåŸÖÿµŸÜŸàÿπ€å Ÿà Ÿæÿ±ÿØÿßÿ≤ÿ¥:
- AISummaryŸáÿß ÿÆÿ±Ÿàÿ¨€å‚ÄåŸáÿß€å ÿ™ÿ≠ŸÑ€åŸÑ€å/ÿÆŸÑÿßÿµŸá‚Äåÿ≥ÿßÿ≤€å Ÿáÿ≥ÿ™ŸÜÿØ ⁄©Ÿá ŸÖŸÖ⁄©ŸÜ ÿßÿ≥ÿ™ ÿ®ÿ± Ÿæÿß€åŸá Ÿæÿ±ÿØÿßÿ≤ÿ¥‚ÄåŸáÿß€å ÿÆŸàÿØ⁄©ÿßÿ±ÿå ŸÖÿØŸÑ‚ÄåŸáÿß€å ÿ≤ÿ®ÿßŸÜ€å €åÿß ÿ¢ŸÜÿßŸÑ€åÿ≤Ÿáÿß€å ÿ®ÿßŸÑ€åŸÜ€å ÿ™ŸàŸÑ€åÿØ ÿ¥ÿØŸá ÿ®ÿßÿ¥ŸÜÿØÿõ ÿß€åŸÜ ŸÖŸàÿßÿ±ÿØ ŸÖ⁄©ŸÖŸÑ ÿØÿßÿØŸá‚ÄåŸáÿß€å ÿÆÿßŸÖ ÿ®ÿßŸÑ€åŸÜ€å Ÿáÿ≥ÿ™ŸÜÿØ Ÿà ÿ®ÿ±ÿß€å ŸÜŸÖÿß€åÿ¥ ÿÆŸÑÿßÿµŸáŸî Ÿàÿ∂ÿπ€åÿ™ €åÿß ŸÜ⁄©ÿßÿ™ ŸÖŸáŸÖ ÿ®€åŸÖÿßÿ± ÿßÿ±ÿßÿ¶Ÿá ŸÖ€å‚Äåÿ¥ŸàŸÜÿØ.
- ÿß€åŸÜ ÿß⁄©ÿ¥ŸÜ ÿµÿ±ŸÅÿßŸã ÿÆŸàÿßŸÜÿØŸÜ Ÿà ÿ≥ÿ±€åÿßŸÑÿß€åÿ≤ ⁄©ÿ±ÿØŸÜ ÿ±⁄©Ÿàÿ±ÿØŸáÿß€å AISummary ÿ±ÿß ÿßŸÜÿ¨ÿßŸÖ ŸÖ€å‚ÄåÿØŸáÿØ Ÿà Ÿá€å⁄Ü Ÿæÿ±ÿØÿßÿ≤ÿ¥ €åÿß ÿßÿ¨ÿ±ÿß€å ÿ™ÿ≥⁄© ÿ∂ŸÖŸÜ€å (ŸÖÿ´ŸÑ ŸÅÿ±ÿßÿÆŸàÿßŸÜ€å ŸÖÿØŸÑ €åÿß ÿß€åÿ¨ÿßÿØ Ÿàÿ∏€åŸÅŸá Ÿæÿ≥‚Äåÿ≤ŸÖ€åŸÜŸá) ÿ±ÿß ÿ±ÿßŸá‚ÄåÿßŸÜÿØÿßÿ≤€å ŸÜŸÖ€å‚Äå⁄©ŸÜÿØÿõ ÿß⁄Øÿ± ŸÜ€åÿßÿ≤ ÿ®Ÿá ÿ™ŸàŸÑ€åÿØ €åÿß ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿÆŸÑÿßÿµŸá‚ÄåŸáÿß€å ŸáŸàÿ¥‚ÄåŸÖÿµŸÜŸàÿπ€å ÿ®ÿßÿ¥ÿØÿå ÿ¢ŸÜ ÿπŸÖŸÑ€åÿßÿ™ ÿ®ÿß€åÿØ ÿßÿ≤ ŸÖÿ≥€åÿ±Ÿáÿß€å ÿ¨ÿØÿß⁄ØÿßŸÜŸá ŸÖÿØ€åÿ±€åÿ™ ÿ¥ŸàÿØ.

ÿπŸàÿßÿ±ÿ∂ ÿ¨ÿßŸÜÿ®€å Ÿà ÿÆÿ∑ÿßŸáÿß:
- ÿÆŸàÿØ ÿ™ÿßÿ®ÿπ ÿØÿßÿØŸá‚ÄåŸáÿß ÿ±ÿß ÿ™ÿ∫€å€åÿ± ŸÜŸÖ€å‚ÄåÿØŸáÿØÿõ ÿØÿ± ÿµŸàÿ±ÿ™ ŸÜÿ®ŸàÿØŸÜ ÿØÿ≥ÿ™ÿ±ÿ≥€å €åÿß Ÿàÿ¨ŸàÿØ ÿÆÿ∑ÿß ÿØÿ± ÿ®ÿßÿ≤€åÿßÿ®€å ÿ¢ÿ®ÿ¨⁄©ÿ™ ÿ®€åŸÖÿßÿ±ÿå ÿÆÿ∑ÿßŸáÿß€å ŸÖÿ±ÿ®Ÿàÿ∑ ÿ®Ÿá permissions €åÿß 404 ÿ™Ÿàÿ≥ÿ∑ ŸÖÿ™ÿØŸáÿß€å Ÿæÿß€åŸáŸî ViewSet/DRF ÿ™ŸàŸÑ€åÿØ ŸÖ€å‚Äåÿ¥ŸàŸÜÿØ.
 * @summary Get patient timeline
 */
export const apiPatientsTimelineRetrieve = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<Patient>(
      {url: `/api/patients/${id}/timeline`, method: 'GET', signal
    },
      options);
    }
  

export const getApiPatientsTimelineRetrieveQueryKey = (id?: number,) => {
    return [`/api/patients/${id}/timeline`] as const;
    }

    
export const getApiPatientsTimelineRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>, TError = null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiPatientsTimelineRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>> = ({ signal }) => apiPatientsTimelineRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiPatientsTimelineRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>>
export type ApiPatientsTimelineRetrieveQueryError = null


export function useApiPatientsTimelineRetrieve<TData = Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>, TError = null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiPatientsTimelineRetrieve<TData = Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiPatientsTimelineRetrieve<TData = Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get patient timeline
 */

export function useApiPatientsTimelineRetrieve<TData = Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiPatientsTimelineRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary List clinical references
 */
export const apiRefsList = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<ClinicalReference[]>(
      {url: `/api/refs`, method: 'GET', signal
    },
      options);
    }
  

export const getApiRefsListQueryKey = () => {
    return [`/api/refs`] as const;
    }

    
export const getApiRefsListQueryOptions = <TData = Awaited<ReturnType<typeof apiRefsList>>, TError = null>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRefsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiRefsListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiRefsList>>> = ({ signal }) => apiRefsList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiRefsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiRefsListQueryResult = NonNullable<Awaited<ReturnType<typeof apiRefsList>>>
export type ApiRefsListQueryError = null


export function useApiRefsList<TData = Awaited<ReturnType<typeof apiRefsList>>, TError = null>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRefsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiRefsList>>,
          TError,
          Awaited<ReturnType<typeof apiRefsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiRefsList<TData = Awaited<ReturnType<typeof apiRefsList>>, TError = null>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRefsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiRefsList>>,
          TError,
          Awaited<ReturnType<typeof apiRefsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiRefsList<TData = Awaited<ReturnType<typeof apiRefsList>>, TError = null>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRefsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List clinical references
 */

export function useApiRefsList<TData = Awaited<ReturnType<typeof apiRefsList>>, TError = null>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRefsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiRefsListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create clinical reference
 */
export const apiRefsCreate = (
    clinicalReference: NonReadonly<ClinicalReference>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<ClinicalReference>(
      {url: `/api/refs`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: clinicalReference, signal
    },
      options);
    }
  


export const getApiRefsCreateMutationOptions = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiRefsCreate>>, TError,{data: NonReadonly<ClinicalReference>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiRefsCreate>>, TError,{data: NonReadonly<ClinicalReference>}, TContext> => {

const mutationKey = ['apiRefsCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiRefsCreate>>, {data: NonReadonly<ClinicalReference>}> = (props) => {
          const {data} = props ?? {};

          return  apiRefsCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiRefsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiRefsCreate>>>
    export type ApiRefsCreateMutationBody = NonReadonly<ClinicalReference>
    export type ApiRefsCreateMutationError = null

    /**
 * @summary Create clinical reference
 */
export const useApiRefsCreate = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiRefsCreate>>, TError,{data: NonReadonly<ClinicalReference>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiRefsCreate>>,
        TError,
        {data: NonReadonly<ClinicalReference>},
        TContext
      > => {

      const mutationOptions = getApiRefsCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get clinical reference
 */
export const apiRefsRetrieve = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<ClinicalReference>(
      {url: `/api/refs/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getApiRefsRetrieveQueryKey = (id?: number,) => {
    return [`/api/refs/${id}`] as const;
    }

    
export const getApiRefsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiRefsRetrieve>>, TError = null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRefsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiRefsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiRefsRetrieve>>> = ({ signal }) => apiRefsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiRefsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiRefsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiRefsRetrieve>>>
export type ApiRefsRetrieveQueryError = null


export function useApiRefsRetrieve<TData = Awaited<ReturnType<typeof apiRefsRetrieve>>, TError = null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRefsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiRefsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiRefsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiRefsRetrieve<TData = Awaited<ReturnType<typeof apiRefsRetrieve>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRefsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiRefsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiRefsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiRefsRetrieve<TData = Awaited<ReturnType<typeof apiRefsRetrieve>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRefsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get clinical reference
 */

export function useApiRefsRetrieve<TData = Awaited<ReturnType<typeof apiRefsRetrieve>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRefsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiRefsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update clinical reference
 */
export const apiRefsUpdate = (
    id: number,
    clinicalReference: NonReadonly<ClinicalReference>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<ClinicalReference>(
      {url: `/api/refs/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: clinicalReference
    },
      options);
    }
  


export const getApiRefsUpdateMutationOptions = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiRefsUpdate>>, TError,{id: number;data: NonReadonly<ClinicalReference>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiRefsUpdate>>, TError,{id: number;data: NonReadonly<ClinicalReference>}, TContext> => {

const mutationKey = ['apiRefsUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiRefsUpdate>>, {id: number;data: NonReadonly<ClinicalReference>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiRefsUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiRefsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiRefsUpdate>>>
    export type ApiRefsUpdateMutationBody = NonReadonly<ClinicalReference>
    export type ApiRefsUpdateMutationError = null

    /**
 * @summary Update clinical reference
 */
export const useApiRefsUpdate = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiRefsUpdate>>, TError,{id: number;data: NonReadonly<ClinicalReference>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiRefsUpdate>>,
        TError,
        {id: number;data: NonReadonly<ClinicalReference>},
        TContext
      > => {

      const mutationOptions = getApiRefsUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Partially update clinical reference
 */
export const apiRefsPartialUpdate = (
    id: number,
    patchedClinicalReference: NonReadonly<PatchedClinicalReference>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<ClinicalReference>(
      {url: `/api/refs/${id}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedClinicalReference
    },
      options);
    }
  


export const getApiRefsPartialUpdateMutationOptions = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiRefsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedClinicalReference>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiRefsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedClinicalReference>}, TContext> => {

const mutationKey = ['apiRefsPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiRefsPartialUpdate>>, {id: number;data: NonReadonly<PatchedClinicalReference>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiRefsPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiRefsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiRefsPartialUpdate>>>
    export type ApiRefsPartialUpdateMutationBody = NonReadonly<PatchedClinicalReference>
    export type ApiRefsPartialUpdateMutationError = null

    /**
 * @summary Partially update clinical reference
 */
export const useApiRefsPartialUpdate = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiRefsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedClinicalReference>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiRefsPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedClinicalReference>},
        TContext
      > => {

      const mutationOptions = getApiRefsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Delete clinical reference
 */
export const apiRefsDestroy = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<null>(
      {url: `/api/refs/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getApiRefsDestroyMutationOptions = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiRefsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiRefsDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['apiRefsDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiRefsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  apiRefsDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiRefsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof apiRefsDestroy>>>
    
    export type ApiRefsDestroyMutationError = null

    /**
 * @summary Delete clinical reference
 */
export const useApiRefsDestroy = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiRefsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiRefsDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getApiRefsDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Takes a set of user credentials and returns an access and refresh JSON web
token pair to prove the authentication of those credentials.
 * @summary Obtain JWT token pair
 */
export const apiTokenCreate = (
    tokenObtainPair: NonReadonly<TokenObtainPair>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<TokenObtainPair>(
      {url: `/api/token`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: tokenObtainPair, signal
    },
      options);
    }
  


export const getApiTokenCreateMutationOptions = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiTokenCreate>>, TError,{data: NonReadonly<TokenObtainPair>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiTokenCreate>>, TError,{data: NonReadonly<TokenObtainPair>}, TContext> => {

const mutationKey = ['apiTokenCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiTokenCreate>>, {data: NonReadonly<TokenObtainPair>}> = (props) => {
          const {data} = props ?? {};

          return  apiTokenCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiTokenCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiTokenCreate>>>
    export type ApiTokenCreateMutationBody = NonReadonly<TokenObtainPair>
    export type ApiTokenCreateMutationError = null

    /**
 * @summary Obtain JWT token pair
 */
export const useApiTokenCreate = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiTokenCreate>>, TError,{data: NonReadonly<TokenObtainPair>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiTokenCreate>>,
        TError,
        {data: NonReadonly<TokenObtainPair>},
        TContext
      > => {

      const mutationOptions = getApiTokenCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Takes a refresh type JSON web token and returns an access type JSON web
token if the refresh token is valid.
 * @summary Refresh JWT access token
 */
export const apiTokenRefreshCreate = (
    tokenRefresh: NonReadonly<TokenRefresh>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<TokenRefresh>(
      {url: `/api/token/refresh`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: tokenRefresh, signal
    },
      options);
    }
  


export const getApiTokenRefreshCreateMutationOptions = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiTokenRefreshCreate>>, TError,{data: NonReadonly<TokenRefresh>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiTokenRefreshCreate>>, TError,{data: NonReadonly<TokenRefresh>}, TContext> => {

const mutationKey = ['apiTokenRefreshCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiTokenRefreshCreate>>, {data: NonReadonly<TokenRefresh>}> = (props) => {
          const {data} = props ?? {};

          return  apiTokenRefreshCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiTokenRefreshCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiTokenRefreshCreate>>>
    export type ApiTokenRefreshCreateMutationBody = NonReadonly<TokenRefresh>
    export type ApiTokenRefreshCreateMutationError = null

    /**
 * @summary Refresh JWT access token
 */
export const useApiTokenRefreshCreate = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiTokenRefreshCreate>>, TError,{data: NonReadonly<TokenRefresh>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiTokenRefreshCreate>>,
        TError,
        {data: NonReadonly<TokenRefresh>},
        TContext
      > => {

      const mutationOptions = getApiTokenRefreshCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get resource versions
 */
export const apiVersionsRetrieve = (
    resourceType: string,
    resourceId: string,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<null>(
      {url: `/api/versions/${resourceType}/${resourceId}`, method: 'GET', signal
    },
      options);
    }
  

export const getApiVersionsRetrieveQueryKey = (resourceType?: string,
    resourceId?: string,) => {
    return [`/api/versions/${resourceType}/${resourceId}`] as const;
    }

    
export const getApiVersionsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiVersionsRetrieve>>, TError = null>(resourceType: string,
    resourceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiVersionsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiVersionsRetrieveQueryKey(resourceType,resourceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiVersionsRetrieve>>> = ({ signal }) => apiVersionsRetrieve(resourceType,resourceId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(resourceType && resourceId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiVersionsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiVersionsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiVersionsRetrieve>>>
export type ApiVersionsRetrieveQueryError = null


export function useApiVersionsRetrieve<TData = Awaited<ReturnType<typeof apiVersionsRetrieve>>, TError = null>(
 resourceType: string,
    resourceId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiVersionsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiVersionsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiVersionsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiVersionsRetrieve<TData = Awaited<ReturnType<typeof apiVersionsRetrieve>>, TError = null>(
 resourceType: string,
    resourceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiVersionsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiVersionsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiVersionsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiVersionsRetrieve<TData = Awaited<ReturnType<typeof apiVersionsRetrieve>>, TError = null>(
 resourceType: string,
    resourceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiVersionsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get resource versions
 */

export function useApiVersionsRetrieve<TData = Awaited<ReturnType<typeof apiVersionsRetrieve>>, TError = null>(
 resourceType: string,
    resourceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiVersionsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiVersionsRetrieveQueryOptions(resourceType,resourceId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Revert resource to previous version
 */
export const apiVersionsRevertCreate = (
    resourceType: string,
    resourceId: string,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<null>(
      {url: `/api/versions/${resourceType}/${resourceId}/revert`, method: 'POST', signal
    },
      options);
    }
  


export const getApiVersionsRevertCreateMutationOptions = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiVersionsRevertCreate>>, TError,{resourceType: string;resourceId: string}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiVersionsRevertCreate>>, TError,{resourceType: string;resourceId: string}, TContext> => {

const mutationKey = ['apiVersionsRevertCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiVersionsRevertCreate>>, {resourceType: string;resourceId: string}> = (props) => {
          const {resourceType,resourceId} = props ?? {};

          return  apiVersionsRevertCreate(resourceType,resourceId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiVersionsRevertCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiVersionsRevertCreate>>>
    
    export type ApiVersionsRevertCreateMutationError = null

    /**
 * @summary Revert resource to previous version
 */
export const useApiVersionsRevertCreate = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiVersionsRevertCreate>>, TError,{resourceType: string;resourceId: string}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiVersionsRevertCreate>>,
        TError,
        {resourceType: string;resourceId: string},
        TContext
      > => {

      const mutationOptions = getApiVersionsRevertCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
