/**
 * Generated by orval v7.11.2 ğŸº
 * Do not edit manually.
 * Your API
 * Description here.
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import { createAxiosInstance } from '../http/axios-instance';

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;

/**
 * Serializer for AISummary model with enhanced fields
 */
export interface AISummary {
  readonly id: number;
  patient: number;
  /** @nullable */
  content_type?: number | null;
  /**
   * @maxLength 64
   * @nullable
   */
  object_id?: string | null;
  readonly resource_type: string;
  summary: string;
  readonly references: readonly string[];
  readonly created_at: string;
  readonly updated_at: string;
}

/**
 * Simplified serializer for listing AI summaries
 */
export interface AISummaryList {
  readonly id: number;
  patient: number;
  readonly resource_type: string;
  readonly summary_preview: string;
  readonly references_count: string;
  readonly created_at: string;
  readonly updated_at: string;
}

/**
 * Serializer for AnomalyDetection model
 */
export interface AnomalyDetection {
  readonly id: number;
  patient: number;
  anomaly_type: AnomalyTypeEnum;
  readonly anomaly_type_display: string;
  severity_level: SeverityLevelEnum;
  readonly severity_level_display: string;
  description: string;
  /**
   * @nullable
   * @pattern ^-?\d{0,6}(?:\.\d{0,4})?$
   */
  detected_value?: string | null;
  /**
   * @nullable
   * @pattern ^-?\d{0,6}(?:\.\d{0,4})?$
   */
  expected_value?: string | null;
  /** @pattern ^-?\d{0,2}(?:\.\d{0,3})?$ */
  deviation_score: string;
  is_acknowledged?: boolean;
  /** @nullable */
  acknowledged_by?: number | null;
  readonly acknowledged_by_name: string;
  /** @nullable */
  acknowledged_at?: string | null;
  readonly detected_at: string;
  data_timestamp: string;
}

/**
 * * `OUTLIER` - Ù†Ù‚Ø·Ù‡ Ù¾Ø±Øª Ø¢Ù…Ø§Ø±ÛŒ
* `SUDDEN_CHANGE` - ØªØºÛŒÛŒØ± Ù†Ø§Ú¯Ù‡Ø§Ù†ÛŒ
* `TREND_REVERSAL` - Ù…Ø¹Ú©ÙˆØ³ Ø´Ø¯Ù† Ø±ÙˆÙ†Ø¯
* `MISSING_DATA` - Ø¯Ø§Ø¯Ù‡ Ú¯Ù…Ø´Ø¯Ù‡
* `MED_SKIP` - Ø¹Ø¯Ù… Ù…ØµØ±Ù Ø¯Ø§Ø±Ùˆ
* `UNUSUAL_PATTERN` - Ø§Ù„Ú¯ÙˆÛŒ ØºÛŒØ±Ø¹Ø§Ø¯ÛŒ
 */
export type AnomalyTypeEnum = typeof AnomalyTypeEnum[keyof typeof AnomalyTypeEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AnomalyTypeEnum = {
  OUTLIER: 'OUTLIER',
  SUDDEN_CHANGE: 'SUDDEN_CHANGE',
  TREND_REVERSAL: 'TREND_REVERSAL',
  MISSING_DATA: 'MISSING_DATA',
  MED_SKIP: 'MED_SKIP',
  UNUSUAL_PATTERN: 'UNUSUAL_PATTERN',
} as const;

/**
 * Serializer for BaselineMetrics model
 */
export interface BaselineMetrics {
  patient: number;
  /**
   * @nullable
   * @pattern ^-?\d{0,2}(?:\.\d{0,2})?$
   */
  avg_hba1c?: string | null;
  /**
   * @nullable
   * @pattern ^-?\d{0,3}(?:\.\d{0,2})?$
   */
  avg_blood_glucose?: string | null;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   * @nullable
   */
  avg_systolic_bp?: number | null;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   * @nullable
   */
  avg_diastolic_bp?: number | null;
  /**
   * @nullable
   * @pattern ^-?\d{0,2}(?:\.\d{0,2})?$
   */
  std_hba1c?: string | null;
  /**
   * @nullable
   * @pattern ^-?\d{0,3}(?:\.\d{0,2})?$
   */
  std_blood_glucose?: string | null;
  /**
   * @nullable
   * @pattern ^-?\d{0,3}(?:\.\d{0,2})?$
   */
  std_systolic_bp?: string | null;
  /**
   * @nullable
   * @pattern ^-?\d{0,3}(?:\.\d{0,2})?$
   */
  std_diastolic_bp?: string | null;
  /**
   * @nullable
   * @pattern ^-?\d{0,2}(?:\.\d{0,2})?$
   */
  avg_encounters_per_month?: string | null;
  /**
   * @nullable
   * @pattern ^-?\d{0,2}(?:\.\d{0,2})?$
   */
  avg_labs_per_month?: string | null;
  /**
   * @nullable
   * @pattern ^-?\d{0,1}(?:\.\d{0,2})?$
   */
  medication_adherence_score?: string | null;
  readonly last_calculated: string;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  data_points_count?: number;
}

export type BlankEnum = typeof BlankEnum[keyof typeof BlankEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BlankEnum = {
  '': '',
} as const;

/**
 * * `MALE` - Male
 * `FEMALE` - Female
 * `OTHER` - Other
 */
export type SexEnum = typeof SexEnum[keyof typeof SexEnum];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SexEnum = {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER',
} as const;

/**
 * Serializer Ø¨Ø±Ø§ÛŒ Ù‡Ø´Ø¯Ø§Ø±Ù‡Ø§ÛŒ Ø¨Ø§Ù„ÛŒÙ†ÛŒ
 */
export interface ClinicalAlert {
  readonly id: number;
  alert_type: ClinicalAlertAlertTypeEnum;
  severity?: ClinicalAlertSeverityEnum;
  /**
   * @nullable
   * @pattern ^-?\d{0,6}(?:\.\d{0,4})?$
   */
  trigger_value?: string | null;
  /**
   * @nullable
   * @pattern ^-?\d{0,6}(?:\.\d{0,4})?$
   */
  threshold_value?: string | null;
  message: string;
  is_active?: boolean;
  /** @nullable */
  readonly acknowledged_at: string | null;
  readonly created_at: string;
  readonly patient_name: string;
  readonly acknowledged_by_name: string;
}

/**
 * * `HIGH_HBA1C` - HbA1c Ø¨Ø§Ù„Ø§
* `LOW_GLUCOSE` - Ù‚Ù†Ø¯ Ø®ÙˆÙ† Ù¾Ø§ÛŒÛŒÙ†
* `HIGH_GLUCOSE` - Ù‚Ù†Ø¯ Ø®ÙˆÙ† Ø¨Ø§Ù„Ø§
* `MISSED_APPOINTMENT` - Ø¹Ø¯Ù… Ø­Ø¶ÙˆØ± Ø¯Ø± ÙˆÛŒØ²ÛŒØª
* `DRUG_INTERACTION` - ØªØ¯Ø§Ø®Ù„ Ø¯Ø§Ø±ÙˆÛŒÛŒ
* `ABNORMAL_TREND` - Ø±ÙˆÙ†Ø¯ ØºÛŒØ±Ø·Ø¨ÛŒØ¹ÛŒ
 */
export type ClinicalAlertAlertTypeEnum = typeof ClinicalAlertAlertTypeEnum[keyof typeof ClinicalAlertAlertTypeEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ClinicalAlertAlertTypeEnum = {
  HIGH_HBA1C: 'HIGH_HBA1C',
  LOW_GLUCOSE: 'LOW_GLUCOSE',
  HIGH_GLUCOSE: 'HIGH_GLUCOSE',
  MISSED_APPOINTMENT: 'MISSED_APPOINTMENT',
  DRUG_INTERACTION: 'DRUG_INTERACTION',
  ABNORMAL_TREND: 'ABNORMAL_TREND',
} as const;

/**
 * * `LOW` - Ù¾Ø§ÛŒÛŒÙ†
* `MEDIUM` - Ù…ØªÙˆØ³Ø·
* `HIGH` - Ø¨Ø§Ù„Ø§
* `CRITICAL` - Ø¨Ø­Ø±Ø§Ù†ÛŒ
 */
export type ClinicalAlertSeverityEnum = typeof ClinicalAlertSeverityEnum[keyof typeof ClinicalAlertSeverityEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ClinicalAlertSeverityEnum = {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL',
} as const;

export interface ClinicalReference {
  readonly id: number;
  /** @maxLength 200 */
  title: string;
  /** @maxLength 120 */
  source: string;
  /**
   * @minimum 1900
   * @maximum 9223372036854776000
   */
  year: number;
  /** @maxLength 200 */
  url?: string;
  /** @maxLength 80 */
  topic: string;
}

/**
 * Serializer for creating AI summaries with content to be processed
 */
export interface CreateAISummary {
  patient_id: number;
  /** Raw medical content to be summarized by AI */
  content: string;
  /** Model name for generic relation (e.g., 'encounter', 'lab_result') */
  content_type_model?: string;
  /** Object ID for generic relation */
  object_id?: string;
  /** Optional patient context for better summarization */
  context?: string;
  /** Type of summary for specialized AI prompts

* `medical_record` - Medical Record
* `encounter` - Patient Encounter
* `lab_results` - Laboratory Results
* `medications` - Medications */
  summary_type?: SummaryTypeEnum;
  /** Topic hint for linking clinical references */
  topic_hint?: string;
  /** Process summary asynchronously using background task */
  async_processing?: boolean;
}

/**
 * * `WEEKLY` - Ù‡ÙØªÚ¯ÛŒ
* `MONTHLY` - Ù…Ø§Ù‡Ø§Ù†Ù‡
* `QUARTERLY` - Ø³Ù‡â€ŒÙ…Ø§Ù‡Ù‡
* `BIANNUALLY` - Ø´Ø´â€ŒÙ…Ø§Ù‡Ù‡
* `ANNUALLY` - Ø³Ø§Ù„Ø§Ù†Ù‡
* `CUSTOM` - Ø³ÙØ§Ø±Ø´ÛŒ
 */
export type DefaultFrequencyEnum = typeof DefaultFrequencyEnum[keyof typeof DefaultFrequencyEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DefaultFrequencyEnum = {
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY',
  QUARTERLY: 'QUARTERLY',
  BIANNUALLY: 'BIANNUALLY',
  ANNUALLY: 'ANNUALLY',
  CUSTOM: 'CUSTOM',
} as const;

/**
 * * `LOW` - Ù¾Ø§ÛŒÛŒÙ†
* `MEDIUM` - Ù…ØªÙˆØ³Ø·
* `HIGH` - Ø¨Ø§Ù„Ø§
* `URGENT` - ÙÙˆØ±ÛŒ
 */
export type DefaultPriorityEnum = typeof DefaultPriorityEnum[keyof typeof DefaultPriorityEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DefaultPriorityEnum = {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT',
} as const;

/**
 * Ø³Ø±ÛŒØ§Ù„Ø§ÛŒØ²Ø± Ø¨Ø±Ø§ÛŒ Ø¢Ù…Ø§Ø±Ù‡Ø§ÛŒ Ù¾Ø²Ø´Ú©
 */
export interface DoctorAnalytics {
  readonly id: number;
  doctor: number;
  readonly doctor_name: string;
  date?: string;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  total_patients?: number;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  active_patients?: number;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  new_patients?: number;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  total_encounters?: number;
  /** @nullable */
  avg_encounters_per_patient?: number | null;
  /**
   * @minimum 4
   * @maximum 18
   * @nullable
   */
  avg_patient_hba1c?: number | null;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  patients_at_goal?: number;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  patients_above_goal?: number;
  readonly goal_achievement_rate: string;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  total_alerts?: number;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  critical_alerts?: number;
  readonly alert_response_rate: string;
  /**
   * @minimum 0
   * @maximum 100
   * @nullable
   */
  performance_score?: number | null;
  readonly created_at: string;
  readonly updated_at: string;
}

export interface Encounter {
  readonly id: number;
  patient: number;
  occurred_at: string;
  subjective?: string;
  objective?: unknown;
  assessment?: unknown;
  plan?: unknown;
  readonly created_by: number;
  readonly created_at: string;
}

/**
 * * `ENCOUNTER` - Ù…ÙˆØ§Ø¬Ù‡Ù‡ Ø¨Ø§Ù„ÛŒÙ†ÛŒ
* `LAB_RESULT` - Ù†ØªÛŒØ¬Ù‡ Ø¢Ø²Ù…Ø§ÛŒØ´
* `MEDICATION` - Ø¯Ø§Ø±Ùˆ
* `PHYSICAL_EXAM` - Ù…Ø¹Ø§ÛŒÙ†Ù‡ ÙÛŒØ²ÛŒÚ©ÛŒ
* `DIAGNOSTIC_TEST` - ØªØ³Øª ØªØ´Ø®ÛŒØµÛŒ
* `PROCEDURE` - Ø§Ù‚Ø¯Ø§Ù… Ø¯Ø±Ù…Ø§Ù†ÛŒ
* `DIET_PLAN` - Ø¨Ø±Ù†Ø§Ù…Ù‡ ØºØ°Ø§ÛŒÛŒ
* `EXERCISE` - ÙˆØ±Ø²Ø´
* `ALERT` - Ù‡Ø´Ø¯Ø§Ø± Ø¨Ø§Ù„ÛŒÙ†ÛŒ
* `REMINDER` - ÛŒØ§Ø¯Ø¢ÙˆØ±ÛŒ
 */
export type EventTypeEnum = typeof EventTypeEnum[keyof typeof EventTypeEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EventTypeEnum = {
  ENCOUNTER: 'ENCOUNTER',
  LAB_RESULT: 'LAB_RESULT',
  MEDICATION: 'MEDICATION',
  PHYSICAL_EXAM: 'PHYSICAL_EXAM',
  DIAGNOSTIC_TEST: 'DIAGNOSTIC_TEST',
  PROCEDURE: 'PROCEDURE',
  DIET_PLAN: 'DIET_PLAN',
  EXERCISE: 'EXERCISE',
  ALERT: 'ALERT',
  REMINDER: 'REMINDER',
} as const;

/**
 * * `pdf` - PDF
* `excel` - Excel
* `csv` - CSV
 */
export type FormatEnum = typeof FormatEnum[keyof typeof FormatEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FormatEnum = {
  pdf: 'pdf',
  excel: 'excel',
  csv: 'csv',
} as const;

/**
 * * `WEEKLY` - Ù‡ÙØªÚ¯ÛŒ
* `MONTHLY` - Ù…Ø§Ù‡Ø§Ù†Ù‡
* `QUARTERLY` - Ø³Ù‡â€ŒÙ…Ø§Ù‡Ù‡
* `BIANNUALLY` - Ø´Ø´â€ŒÙ…Ø§Ù‡Ù‡
* `ANNUALLY` - Ø³Ø§Ù„Ø§Ù†Ù‡
* `CUSTOM` - Ø³ÙØ§Ø±Ø´ÛŒ
 */
export type FrequencyAc7Enum = typeof FrequencyAc7Enum[keyof typeof FrequencyAc7Enum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FrequencyAc7Enum = {
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY',
  QUARTERLY: 'QUARTERLY',
  BIANNUALLY: 'BIANNUALLY',
  ANNUALLY: 'ANNUALLY',
  CUSTOM: 'CUSTOM',
} as const;

/**
 * * `improving` - Ø¯Ø± Ø­Ø§Ù„ Ø¨Ù‡Ø¨ÙˆØ¯
* `stable` - Ø«Ø§Ø¨Øª
* `worsening` - Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø¯ØªØ± Ø´Ø¯Ù†
 */
export type GlucoseTrendEnum = typeof GlucoseTrendEnum[keyof typeof GlucoseTrendEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GlucoseTrendEnum = {
  improving: 'improving',
  stable: 'stable',
  worsening: 'worsening',
} as const;

/**
 * * `improving` - Ø¯Ø± Ø­Ø§Ù„ Ø¨Ù‡Ø¨ÙˆØ¯
* `stable` - Ø«Ø§Ø¨Øª
* `worsening` - Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø¯ØªØ± Ø´Ø¯Ù†
 */
export type Hba1cTrendEnum = typeof Hba1cTrendEnum[keyof typeof Hba1cTrendEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Hba1cTrendEnum = {
  improving: 'improving',
  stable: 'stable',
  worsening: 'worsening',
} as const;

export interface LabResult {
  readonly id: number;
  patient: number;
  /** @nullable */
  encounter?: number | null;
  /** @maxLength 40 */
  loinc: string;
  /** @pattern ^-?\d{0,6}(?:\.\d{0,4})?$ */
  value: string;
  /** @maxLength 16 */
  unit: string;
  taken_at: string;
}

/**
 * Ø³Ø±ÛŒØ§Ù„Ø§ÛŒØ²Ø± Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´ Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§ÛŒ ØªØ§ÛŒÙ…â€ŒÙ„Ø§ÛŒÙ† Ù¾Ø²Ø´Ú©ÛŒ
 */
export interface MedicalTimeline {
  readonly id: number;
  patient: number;
  readonly patient_name: string;
  event_type: EventTypeEnum;
  readonly event_type_display: string;
  /** @maxLength 200 */
  title: string;
  description?: string;
  occurred_at: string;
  metadata?: unknown;
  severity?: MedicalTimelineSeverityEnum;
  readonly severity_display: string;
  readonly created_by: number;
  readonly created_by_name: string;
  readonly created_at: string;
  is_visible?: boolean;
  readonly content_type_name: string;
  readonly content_object_data: string;
}

/**
 * * `LOW` - Ù¾Ø§ÛŒÛŒÙ†
* `NORMAL` - Ø¹Ø§Ø¯ÛŒ
* `HIGH` - Ø¨Ø§Ù„Ø§
* `CRITICAL` - Ø¨Ø­Ø±Ø§Ù†ÛŒ
 */
export type MedicalTimelineSeverityEnum = typeof MedicalTimelineSeverityEnum[keyof typeof MedicalTimelineSeverityEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MedicalTimelineSeverityEnum = {
  LOW: 'LOW',
  NORMAL: 'NORMAL',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL',
} as const;

export interface MedicationOrder {
  readonly id: number;
  patient: number;
  /** @nullable */
  encounter?: number | null;
  /**
   * ATC classification code (e.g., A10BA02 for Metformin)
   * @maxLength 20
   * @pattern ^[A-Z]\d{2}[A-Z]{1,2}\d{2}$
   */
  atc: string;
  /** @maxLength 100 */
  name: string;
  /**
   * Ø¯ÙˆØ² Ø¯Ø§Ø±Ùˆ (Ù…Ø«Ø§Ù„: 500mg, 1.5g, 10units)
   * @maxLength 50
   */
  dose: string;
  frequency?: MedicationOrderFrequencyEnum;
  start_date: string;
  /** @nullable */
  end_date?: string | null;
}

/**
 * * `QD` - Once daily
* `BID` - Twice daily
* `TID` - Three times daily
* `QID` - Four times daily
* `Q6H` - Every 6 hours
* `Q8H` - Every 8 hours
* `Q12H` - Every 12 hours
* `PRN` - As needed
* `QW` - Weekly
* `QM` - Monthly
 */
export type MedicationOrderFrequencyEnum = typeof MedicationOrderFrequencyEnum[keyof typeof MedicationOrderFrequencyEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MedicationOrderFrequencyEnum = {
  QD: 'QD',
  BID: 'BID',
  TID: 'TID',
  QID: 'QID',
  Q6H: 'Q6H',
  Q8H: 'Q8H',
  Q12H: 'Q12H',
  PRN: 'PRN',
  QW: 'QW',
  QM: 'QM',
} as const;

/**
 * Serializer Ø¨Ø±Ø§ÛŒ Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒâ€ŒÙ‡Ø§
 */
export interface Notification {
  readonly id: number;
  /** @maxLength 200 */
  title: string;
  message: string;
  notification_type?: NotificationTypeEnum;
  priority?: Priority95eEnum;
  /**
   * @maxLength 64
   * @nullable
   */
  patient_id?: string | null;
  /**
   * @maxLength 50
   * @nullable
   */
  resource_type?: string | null;
  /**
   * @maxLength 64
   * @nullable
   */
  resource_id?: string | null;
  is_read?: boolean;
  /** @nullable */
  readonly read_at: string | null;
  readonly created_at: string;
  /** @nullable */
  expires_at?: string | null;
  readonly recipient_name: string;
}

/**
 * * `INFO` - Ø§Ø·Ù„Ø§Ø¹Ø§Øª
* `WARNING` - Ù‡Ø´Ø¯Ø§Ø±
* `CRITICAL` - Ø¨Ø­Ø±Ø§Ù†ÛŒ
* `REMINDER` - ÛŒØ§Ø¯Ø¢ÙˆØ±ÛŒ
* `AI_SUMMARY` - Ø®Ù„Ø§ØµÙ‡ Ù‡ÙˆØ´Ù…Ù†Ø¯
 */
export type NotificationTypeEnum = typeof NotificationTypeEnum[keyof typeof NotificationTypeEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NotificationTypeEnum = {
  INFO: 'INFO',
  WARNING: 'WARNING',
  CRITICAL: 'CRITICAL',
  REMINDER: 'REMINDER',
  AI_SUMMARY: 'AI_SUMMARY',
} as const;

export type NullEnum = typeof NullEnum[keyof typeof NullEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NullEnum = {
} as const;

/**
 * Serializer for AISummary model with enhanced fields
 */
export interface PatchedAISummary {
  readonly id?: number;
  patient?: number;
  /** @nullable */
  content_type?: number | null;
  /**
   * @maxLength 64
   * @nullable
   */
  object_id?: string | null;
  readonly resource_type?: string;
  summary?: string;
  readonly references?: readonly string[];
  readonly created_at?: string;
  readonly updated_at?: string;
}

export interface PatchedClinicalReference {
  readonly id?: number;
  /** @maxLength 200 */
  title?: string;
  /** @maxLength 120 */
  source?: string;
  /**
   * @minimum 1900
   * @maximum 9223372036854776000
   */
  year?: number;
  /** @maxLength 200 */
  url?: string;
  /** @maxLength 80 */
  topic?: string;
}

/**
 * Ø³Ø±ÛŒØ§Ù„Ø§ÛŒØ²Ø± Ø¨Ø±Ø§ÛŒ Ø¢Ù…Ø§Ø±Ù‡Ø§ÛŒ Ù¾Ø²Ø´Ú©
 */
export interface PatchedDoctorAnalytics {
  readonly id?: number;
  doctor?: number;
  readonly doctor_name?: string;
  date?: string;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  total_patients?: number;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  active_patients?: number;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  new_patients?: number;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  total_encounters?: number;
  /** @nullable */
  avg_encounters_per_patient?: number | null;
  /**
   * @minimum 4
   * @maximum 18
   * @nullable
   */
  avg_patient_hba1c?: number | null;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  patients_at_goal?: number;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  patients_above_goal?: number;
  readonly goal_achievement_rate?: string;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  total_alerts?: number;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  critical_alerts?: number;
  readonly alert_response_rate?: string;
  /**
   * @minimum 0
   * @maximum 100
   * @nullable
   */
  performance_score?: number | null;
  readonly created_at?: string;
  readonly updated_at?: string;
}

export interface PatchedEncounter {
  readonly id?: number;
  patient?: number;
  occurred_at?: string;
  subjective?: string;
  objective?: unknown;
  assessment?: unknown;
  plan?: unknown;
  readonly created_by?: number;
  readonly created_at?: string;
}

export interface PatchedLabResult {
  readonly id?: number;
  patient?: number;
  /** @nullable */
  encounter?: number | null;
  /** @maxLength 40 */
  loinc?: string;
  /** @pattern ^-?\d{0,6}(?:\.\d{0,4})?$ */
  value?: string;
  /** @maxLength 16 */
  unit?: string;
  taken_at?: string;
}

/**
 * Ø³Ø±ÛŒØ§Ù„Ø§ÛŒØ²Ø± Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´ Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§ÛŒ ØªØ§ÛŒÙ…â€ŒÙ„Ø§ÛŒÙ† Ù¾Ø²Ø´Ú©ÛŒ
 */
export interface PatchedMedicalTimeline {
  readonly id?: number;
  patient?: number;
  readonly patient_name?: string;
  event_type?: EventTypeEnum;
  readonly event_type_display?: string;
  /** @maxLength 200 */
  title?: string;
  description?: string;
  occurred_at?: string;
  metadata?: unknown;
  severity?: MedicalTimelineSeverityEnum;
  readonly severity_display?: string;
  readonly created_by?: number;
  readonly created_by_name?: string;
  readonly created_at?: string;
  is_visible?: boolean;
  readonly content_type_name?: string;
  readonly content_object_data?: string;
}

export interface PatchedMedicationOrder {
  readonly id?: number;
  patient?: number;
  /** @nullable */
  encounter?: number | null;
  /**
   * ATC classification code (e.g., A10BA02 for Metformin)
   * @maxLength 20
   * @pattern ^[A-Z]\d{2}[A-Z]{1,2}\d{2}$
   */
  atc?: string;
  /** @maxLength 100 */
  name?: string;
  /**
   * Ø¯ÙˆØ² Ø¯Ø§Ø±Ùˆ (Ù…Ø«Ø§Ù„: 500mg, 1.5g, 10units)
   * @maxLength 50
   */
  dose?: string;
  frequency?: MedicationOrderFrequencyEnum;
  start_date?: string;
  /** @nullable */
  end_date?: string | null;
}

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PatchedPatientSex = {...SexEnum,...BlankEnum,...NullEnum,} as const
/**
 * @nullable
 */
export type PatchedPatientSex = typeof PatchedPatientSex[keyof typeof PatchedPatientSex]  | null;

export interface PatchedPatient {
  readonly id?: number;
  /** @nullable */
  user?: number | null;
  /**
   * Ú©Ø¯ Ù…Ù„ÛŒ 10 Ø±Ù‚Ù…ÛŒ
   * @maxLength 20
   * @nullable
   */
  national_id?: string | null;
  /** @maxLength 120 */
  full_name?: string;
  /**
   * ØªØ§Ø±ÛŒØ® ØªÙˆÙ„Ø¯
   * @nullable
   */
  dob?: string | null;
  /** @nullable */
  sex?: PatchedPatientSex;
  /** @nullable */
  primary_doctor?: number | null;
  readonly primary_doctor_id?: number;
  readonly created_at?: string;
}

/**
 * Ø³Ø±ÛŒØ§Ù„Ø§ÛŒØ²Ø± Ø¨Ø±Ø§ÛŒ Ø¢Ù…Ø§Ø±Ù‡Ø§ÛŒ Ø¨ÛŒÙ…Ø§Ø±
 */
export interface PatchedPatientAnalytics {
  readonly id?: number;
  patient?: number;
  readonly patient_name?: string;
  date?: string;
  /**
   * @minimum 20
   * @maximum 800
   * @nullable
   */
  avg_glucose?: number | null;
  /**
   * @minimum 20
   * @maximum 800
   * @nullable
   */
  min_glucose?: number | null;
  /**
   * @minimum 20
   * @maximum 800
   * @nullable
   */
  max_glucose?: number | null;
  /** @nullable */
  glucose_std_dev?: number | null;
  glucose_trend?: GlucoseTrendEnum;
  readonly glucose_in_range_percentage?: string;
  /**
   * @minimum 4
   * @maximum 18
   * @nullable
   */
  avg_hba1c?: number | null;
  hba1c_trend?: Hba1cTrendEnum;
  readonly hba1c_status?: string;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   * @nullable
   */
  avg_systolic?: number | null;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   * @nullable
   */
  avg_diastolic?: number | null;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  encounters_count?: number;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  medications_count?: number;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  lab_tests_count?: number;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  alerts_count?: number;
  /**
   * @minimum 0
   * @maximum 100
   * @nullable
   */
  compliance_score?: number | null;
  readonly created_at?: string;
  readonly updated_at?: string;
}

/**
 * Ø³Ø±ÛŒØ§Ù„Ø§ÛŒØ²Ø± Ø¨Ø±Ø§ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª ØªØ§ÛŒÙ…â€ŒÙ„Ø§ÛŒÙ† Ø¨ÛŒÙ…Ø§Ø±
 */
export interface PatchedPatientTimelinePreference {
  patient?: number;
  readonly patient_name?: string;
  show_lab_results?: boolean;
  show_medications?: boolean;
  show_encounters?: boolean;
  show_alerts?: boolean;
  show_reminders?: boolean;
  enable_email_reminders?: boolean;
  enable_sms_reminders?: boolean;
  /**
   * @minimum 0
   * @maximum 9223372036854776000
   */
  default_timeline_range_days?: number;
}

export interface PatchedReminder {
  readonly id?: number;
  patient?: number;
  readonly patient_name?: string;
  reminder_type?: ReminderTypeEnum;
  /** @maxLength 200 */
  title?: string;
  description?: string;
  due_at?: string;
  /** @nullable */
  snooze_until?: string | null;
  readonly status?: ReminderStatusEnum;
  priority?: ReminderPriorityEnum;
  /** @nullable */
  readonly completed_at?: string | null;
  readonly created_at?: string;
  readonly is_due?: boolean;
  /** @nullable */
  readonly created_by?: number | null;
}

/**
 * Ø³Ø±ÛŒØ§Ù„Ø§ÛŒØ²Ø± Ø¨Ø±Ø§ÛŒ Ú¯Ø²Ø§Ø±Ø´â€ŒÙ‡Ø§
 */
export interface PatchedReport {
  readonly id?: number;
  report_type?: ReportTypeEnum;
  format?: FormatEnum;
  status?: ReportStatusEnum;
  /** @nullable */
  requested_by?: number | null;
  readonly requested_by_name?: string;
  /** @nullable */
  start_date?: string | null;
  /** @nullable */
  end_date?: string | null;
  /** @nullable */
  patient?: number | null;
  readonly patient_name?: string;
  /** @nullable */
  doctor?: number | null;
  readonly doctor_name?: string;
  /** @nullable */
  readonly file_path?: string | null;
  /** @nullable */
  readonly error_message?: string | null;
  metadata?: unknown;
  readonly created_at?: string;
  /** @nullable */
  readonly completed_at?: string | null;
  readonly duration?: string;
}

/**
 * Ø³Ø±ÛŒØ§Ù„Ø§ÛŒØ²Ø± Ø¨Ø±Ø§ÛŒ Ø¢Ù…Ø§Ø±Ù‡Ø§ÛŒ Ø³ÛŒØ³ØªÙ…
 */
export interface PatchedSystemAnalytics {
  readonly id?: number;
  date?: string;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  total_users?: number;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  active_users?: number;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  total_doctors?: number;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  total_patients?: number;
  readonly user_engagement_rate?: string;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  total_encounters?: number;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  total_lab_tests?: number;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  total_medications?: number;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  total_alerts?: number;
  /**
   * @minimum 4
   * @maximum 18
   * @nullable
   */
  avg_system_hba1c?: number | null;
  /**
   * @minimum 0
   * @maximum 100
   * @nullable
   */
  system_goal_achievement?: number | null;
  readonly data_completeness_score?: string;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  daily_active_users?: number;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  api_calls?: number;
  readonly created_at?: string;
  readonly updated_at?: string;
}

/**
 * Ø³Ø±ÛŒØ§Ù„Ø§ÛŒØ²Ø± Ø¨Ø±Ø§ÛŒ ÛŒØ§Ø¯Ø¢ÙˆØ±Ù‡Ø§ÛŒ Ø¢Ø²Ù…Ø§ÛŒØ´Ø§Øª
 */
export interface PatchedTestReminder {
  readonly id?: number;
  patient?: number;
  readonly patient_name?: string;
  test_type?: TestTypeEnum;
  readonly test_type_display?: string;
  frequency?: FrequencyAc7Enum;
  readonly frequency_display?: string;
  priority?: Priority95eEnum;
  readonly priority_display?: string;
  /** @nullable */
  last_performed?: string | null;
  next_due?: string;
  /**
   * @minimum 0
   * @maximum 9223372036854776000
   */
  reminder_days_before?: number;
  is_active?: boolean;
  notes?: string;
  /**
   * ÙØ§ØµÙ„Ù‡ Ø³ÙØ§Ø±Ø´ÛŒ Ø¨Ù‡ Ø±ÙˆØ² (ÙÙ‚Ø· Ø¨Ø±Ø§ÛŒ Ù†ÙˆØ¹ CUSTOM)
   * @minimum 0
   * @maximum 9223372036854776000
   * @nullable
   */
  custom_interval_days?: number | null;
  readonly created_by?: number;
  readonly created_by_name?: string;
  readonly created_at?: string;
  readonly updated_at?: string;
  readonly is_overdue?: string;
  readonly days_until_due?: string;
  readonly should_send_reminder?: string;
}

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PatientSex = {...SexEnum,...BlankEnum,...NullEnum,} as const
/**
 * @nullable
 */
export type PatientSex = typeof PatientSex[keyof typeof PatientSex]  | null;

export interface Patient {
  readonly id: number;
  /** @nullable */
  user?: number | null;
  /**
   * Ú©Ø¯ Ù…Ù„ÛŒ 10 Ø±Ù‚Ù…ÛŒ
   * @maxLength 20
   * @nullable
   */
  national_id?: string | null;
  /** @maxLength 120 */
  full_name?: string;
  /**
   * ØªØ§Ø±ÛŒØ® ØªÙˆÙ„Ø¯
   * @nullable
   */
  dob?: string | null;
  /** @nullable */
  sex?: PatientSex;
  /** @nullable */
  primary_doctor?: number | null;
  readonly primary_doctor_id: number;
  readonly created_at: string;
}

/**
 * Ø³Ø±ÛŒØ§Ù„Ø§ÛŒØ²Ø± Ø¨Ø±Ø§ÛŒ Ø¢Ù…Ø§Ø±Ù‡Ø§ÛŒ Ø¨ÛŒÙ…Ø§Ø±
 */
export interface PatientAnalytics {
  readonly id: number;
  patient: number;
  readonly patient_name: string;
  date?: string;
  /**
   * @minimum 20
   * @maximum 800
   * @nullable
   */
  avg_glucose?: number | null;
  /**
   * @minimum 20
   * @maximum 800
   * @nullable
   */
  min_glucose?: number | null;
  /**
   * @minimum 20
   * @maximum 800
   * @nullable
   */
  max_glucose?: number | null;
  /** @nullable */
  glucose_std_dev?: number | null;
  glucose_trend?: GlucoseTrendEnum;
  readonly glucose_in_range_percentage: string;
  /**
   * @minimum 4
   * @maximum 18
   * @nullable
   */
  avg_hba1c?: number | null;
  hba1c_trend?: Hba1cTrendEnum;
  readonly hba1c_status: string;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   * @nullable
   */
  avg_systolic?: number | null;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   * @nullable
   */
  avg_diastolic?: number | null;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  encounters_count?: number;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  medications_count?: number;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  lab_tests_count?: number;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  alerts_count?: number;
  /**
   * @minimum 0
   * @maximum 100
   * @nullable
   */
  compliance_score?: number | null;
  readonly created_at: string;
  readonly updated_at: string;
}

/**
 * Ø³Ø±ÛŒØ§Ù„Ø§ÛŒØ²Ø± Ø¨Ø±Ø§ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª ØªØ§ÛŒÙ…â€ŒÙ„Ø§ÛŒÙ† Ø¨ÛŒÙ…Ø§Ø±
 */
export interface PatientTimelinePreference {
  patient: number;
  readonly patient_name: string;
  show_lab_results?: boolean;
  show_medications?: boolean;
  show_encounters?: boolean;
  show_alerts?: boolean;
  show_reminders?: boolean;
  enable_email_reminders?: boolean;
  enable_sms_reminders?: boolean;
  /**
   * @minimum 0
   * @maximum 9223372036854776000
   */
  default_timeline_range_days?: number;
}

/**
 * Serializer for PatternAlert model
 */
export interface PatternAlert {
  readonly id: number;
  patient: number;
  alert_type: PatternAlertAlertTypeEnum;
  readonly alert_type_display: string;
  priority: PatternAlertPriorityEnum;
  readonly priority_display: string;
  /** @maxLength 200 */
  title: string;
  message: string;
  readonly related_patterns_count: string;
  readonly related_anomalies_count: string;
  is_active?: boolean;
  is_resolved?: boolean;
  /** @nullable */
  resolved_by?: number | null;
  readonly resolved_by_name: string;
  /** @nullable */
  resolved_at?: string | null;
  resolution_notes?: string;
  readonly created_at: string;
  /** @nullable */
  expires_at?: string | null;
}

/**
 * * `DETERIORATING` - Ø¨Ø¯ØªØ± Ø´Ø¯Ù† Ú©Ù†ØªØ±Ù„
* `NON_ADHERENCE` - Ø¹Ø¯Ù… Ù¾Ø§ÛŒØ¨Ù†Ø¯ÛŒ Ø¯Ø§Ø±ÙˆÛŒÛŒ
* `MISSED_APPT` - Ø¹Ø¯Ù… Ø­Ø¶ÙˆØ± Ø¯Ø± ÙˆÛŒØ²ÛŒØª
* `UNUSUAL_LAB` - Ø§Ù„Ú¯ÙˆÛŒ ØºÛŒØ±Ø¹Ø§Ø¯ÛŒ Ø¢Ø²Ù…Ø§ÛŒØ´
* `EMERGENCY` - Ø§Ù„Ú¯ÙˆÛŒ Ø§ÙˆØ±Ú˜Ø§Ù†Ø³ÛŒ
 */
export type PatternAlertAlertTypeEnum = typeof PatternAlertAlertTypeEnum[keyof typeof PatternAlertAlertTypeEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PatternAlertAlertTypeEnum = {
  DETERIORATING: 'DETERIORATING',
  NON_ADHERENCE: 'NON_ADHERENCE',
  MISSED_APPT: 'MISSED_APPT',
  UNUSUAL_LAB: 'UNUSUAL_LAB',
  EMERGENCY: 'EMERGENCY',
} as const;

/**
 * * `LOW` - Ú©Ù…
* `MEDIUM` - Ù…ØªÙˆØ³Ø·
* `HIGH` - Ø¨Ø§Ù„Ø§
* `URGENT` - ÙÙˆØ±ÛŒ
 */
export type PatternAlertPriorityEnum = typeof PatternAlertPriorityEnum[keyof typeof PatternAlertPriorityEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PatternAlertPriorityEnum = {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT',
} as const;

/**
 * Serializer for PatternAnalysis model
 */
export interface PatternAnalysis {
  readonly id: number;
  patient: number;
  pattern_type: PatternTypeEnum;
  readonly pattern_type_display: string;
  trend_direction: TrendDirectionEnum;
  readonly trend_direction_display: string;
  analysis_result?: unknown;
  /** @pattern ^-?\d{0,1}(?:\.\d{0,2})?$ */
  confidence_score: string;
  /**
   * @nullable
   * @pattern ^-?\d{0,1}(?:\.\d{0,3})?$
   */
  statistical_significance?: string | null;
  analysis_start_date: string;
  analysis_end_date: string;
  readonly created_at: string;
}

/**
 * * `GLUCOSE_TREND` - Ø±ÙˆÙ†Ø¯ Ù‚Ù†Ø¯ Ø®ÙˆÙ†
* `HBA1C_TREND` - Ø±ÙˆÙ†Ø¯ HbA1c
* `BP_TREND` - Ø±ÙˆÙ†Ø¯ ÙØ´Ø§Ø± Ø®ÙˆÙ†
* `MED_ADHERENCE` - Ù¾Ø§ÛŒØ¨Ù†Ø¯ÛŒ Ø¯Ø§Ø±ÙˆÛŒÛŒ
* `VISIT_FREQ` - ÙØ±Ø§ÙˆØ§Ù†ÛŒ ÙˆÛŒØ²ÛŒØª
* `LAB_FREQ` - ÙØ±Ø§ÙˆØ§Ù†ÛŒ Ø¢Ø²Ù…Ø§ÛŒØ´
 */
export type PatternTypeEnum = typeof PatternTypeEnum[keyof typeof PatternTypeEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PatternTypeEnum = {
  GLUCOSE_TREND: 'GLUCOSE_TREND',
  HBA1C_TREND: 'HBA1C_TREND',
  BP_TREND: 'BP_TREND',
  MED_ADHERENCE: 'MED_ADHERENCE',
  VISIT_FREQ: 'VISIT_FREQ',
  LAB_FREQ: 'LAB_FREQ',
} as const;

/**
 * * `LOW` - Ù¾Ø§ÛŒÛŒÙ†
* `MEDIUM` - Ù…ØªÙˆØ³Ø·
* `HIGH` - Ø¨Ø§Ù„Ø§
* `URGENT` - ÙÙˆØ±ÛŒ
 */
export type Priority95eEnum = typeof Priority95eEnum[keyof typeof Priority95eEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Priority95eEnum = {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT',
} as const;

/**
 * Serializer for regenerating existing AI summaries
 */
export interface RegenerateAISummary {
  summary_id: string;
  /** New content to summarize */
  content: string;
  /** Optional patient context */
  context?: string;
  summary_type?: SummaryTypeEnum;
}

export interface Reminder {
  readonly id: number;
  patient: number;
  readonly patient_name: string;
  reminder_type: ReminderTypeEnum;
  /** @maxLength 200 */
  title: string;
  description?: string;
  due_at: string;
  /** @nullable */
  snooze_until?: string | null;
  readonly status: ReminderStatusEnum;
  priority?: ReminderPriorityEnum;
  /** @nullable */
  readonly completed_at: string | null;
  readonly created_at: string;
  readonly is_due: boolean;
  /** @nullable */
  readonly created_by: number | null;
}

/**
 * * `LOW` - Low
* `MEDIUM` - Medium
* `HIGH` - High
* `URGENT` - Urgent
 */
export type ReminderPriorityEnum = typeof ReminderPriorityEnum[keyof typeof ReminderPriorityEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReminderPriorityEnum = {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT',
} as const;

/**
 * * `PENDING` - Pending
* `SENT` - Sent
* `COMPLETED` - Completed
* `CANCELLED` - Cancelled
 */
export type ReminderStatusEnum = typeof ReminderStatusEnum[keyof typeof ReminderStatusEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReminderStatusEnum = {
  PENDING: 'PENDING',
  SENT: 'SENT',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
} as const;

/**
 * Ø³Ø±ÛŒØ§Ù„Ø§ÛŒØ²Ø± Ø¨Ø±Ø§ÛŒ Ù‚Ø§Ù„Ø¨â€ŒÙ‡Ø§ÛŒ ÛŒØ§Ø¯Ø¢ÙˆØ±ÛŒ
 */
export interface ReminderTemplate {
  readonly id: number;
  test_type: TestTypeEnum;
  readonly test_type_display: string;
  default_frequency: DefaultFrequencyEnum;
  readonly default_frequency_display: string;
  default_priority?: DefaultPriorityEnum;
  readonly default_priority_display: string;
  /**
   * @minimum 0
   * @maximum 9223372036854776000
   */
  default_reminder_days?: number;
  instructions?: string;
  preparation_notes?: string;
  is_active?: boolean;
}

/**
 * * `HBA1C` - HbA1c
* `FBS` - Fasting Blood Sugar
* `2HPP` - 2-Hour Postprandial Glucose
* `BUN` - Blood Urea Nitrogen
* `CR` - Creatinine
* `ALT` - Alanine Transaminase
* `AST` - Aspartate Transaminase
* `ALP` - Alkaline Phosphatase
* `PR_URINE_24H` - 24h Urine Protein
* `EYE_EXAM` - Eye Physical Exam
* `EMG` - EMG
* `NCV` - NCV
* `TSH` - Thyroid Stimulating Hormone
* `BMI` - Body Mass Index
* `DIET` - Diet/Nutrition Review
* `OTHER` - Other
 */
export type ReminderTypeEnum = typeof ReminderTypeEnum[keyof typeof ReminderTypeEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReminderTypeEnum = {
  HBA1C: 'HBA1C',
  FBS: 'FBS',
  '2HPP': '2HPP',
  BUN: 'BUN',
  CR: 'CR',
  ALT: 'ALT',
  AST: 'AST',
  ALP: 'ALP',
  PR_URINE_24H: 'PR_URINE_24H',
  EYE_EXAM: 'EYE_EXAM',
  EMG: 'EMG',
  NCV: 'NCV',
  TSH: 'TSH',
  BMI: 'BMI',
  DIET: 'DIET',
  OTHER: 'OTHER',
} as const;

/**
 * Ø³Ø±ÛŒØ§Ù„Ø§ÛŒØ²Ø± Ø¨Ø±Ø§ÛŒ Ú¯Ø²Ø§Ø±Ø´â€ŒÙ‡Ø§
 */
export interface Report {
  readonly id: number;
  report_type: ReportTypeEnum;
  format?: FormatEnum;
  status?: ReportStatusEnum;
  /** @nullable */
  requested_by?: number | null;
  readonly requested_by_name: string;
  /** @nullable */
  start_date?: string | null;
  /** @nullable */
  end_date?: string | null;
  /** @nullable */
  patient?: number | null;
  readonly patient_name: string;
  /** @nullable */
  doctor?: number | null;
  readonly doctor_name: string;
  /** @nullable */
  readonly file_path: string | null;
  /** @nullable */
  readonly error_message: string | null;
  metadata?: unknown;
  readonly created_at: string;
  /** @nullable */
  readonly completed_at: string | null;
  readonly duration: string;
}

/**
 * * `pending` - Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø±
* `processing` - Ø¯Ø± Ø­Ø§Ù„ Ù¾Ø±Ø¯Ø§Ø²Ø´
* `completed` - ØªÚ©Ù…ÛŒÙ„ Ø´Ø¯Ù‡
* `failed` - Ù†Ø§Ù…ÙˆÙÙ‚
 */
export type ReportStatusEnum = typeof ReportStatusEnum[keyof typeof ReportStatusEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReportStatusEnum = {
  pending: 'pending',
  processing: 'processing',
  completed: 'completed',
  failed: 'failed',
} as const;

/**
 * * `patient_summary` - Ø®Ù„Ø§ØµÙ‡ Ø¨ÛŒÙ…Ø§Ø±
* `doctor_performance` - Ø¹Ù…Ù„Ú©Ø±Ø¯ Ù¾Ø²Ø´Ú©
* `system_overview` - Ù†Ù…Ø§ÛŒ Ú©Ù„ÛŒ Ø³ÛŒØ³ØªÙ…
* `custom` - Ø³ÙØ§Ø±Ø´ÛŒ
 */
export type ReportTypeEnum = typeof ReportTypeEnum[keyof typeof ReportTypeEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReportTypeEnum = {
  patient_summary: 'patient_summary',
  doctor_performance: 'doctor_performance',
  system_overview: 'system_overview',
  custom: 'custom',
} as const;

/**
 * * `LOW` - Ú©Ù…
* `MEDIUM` - Ù…ØªÙˆØ³Ø·
* `HIGH` - Ø¨Ø§Ù„Ø§
* `CRITICAL` - Ø¨Ø­Ø±Ø§Ù†ÛŒ
 */
export type SeverityLevelEnum = typeof SeverityLevelEnum[keyof typeof SeverityLevelEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SeverityLevelEnum = {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL',
} as const;

// SexEnum moved to earlier in file to avoid usage before declaration

/**
 * * `medical_record` - Medical Record
* `encounter` - Patient Encounter
* `lab_results` - Laboratory Results
* `medications` - Medications
 */
export type SummaryTypeEnum = typeof SummaryTypeEnum[keyof typeof SummaryTypeEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SummaryTypeEnum = {
  medical_record: 'medical_record',
  encounter: 'encounter',
  lab_results: 'lab_results',
  medications: 'medications',
} as const;

/**
 * Ø³Ø±ÛŒØ§Ù„Ø§ÛŒØ²Ø± Ø¨Ø±Ø§ÛŒ Ø¢Ù…Ø§Ø±Ù‡Ø§ÛŒ Ø³ÛŒØ³ØªÙ…
 */
export interface SystemAnalytics {
  readonly id: number;
  date?: string;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  total_users?: number;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  active_users?: number;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  total_doctors?: number;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  total_patients?: number;
  readonly user_engagement_rate: string;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  total_encounters?: number;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  total_lab_tests?: number;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  total_medications?: number;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  total_alerts?: number;
  /**
   * @minimum 4
   * @maximum 18
   * @nullable
   */
  avg_system_hba1c?: number | null;
  /**
   * @minimum 0
   * @maximum 100
   * @nullable
   */
  system_goal_achievement?: number | null;
  readonly data_completeness_score: string;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  daily_active_users?: number;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  api_calls?: number;
  readonly created_at: string;
  readonly updated_at: string;
}

/**
 * Ø³Ø±ÛŒØ§Ù„Ø§ÛŒØ²Ø± Ø¨Ø±Ø§ÛŒ ÛŒØ§Ø¯Ø¢ÙˆØ±Ù‡Ø§ÛŒ Ø¢Ø²Ù…Ø§ÛŒØ´Ø§Øª
 */
export interface TestReminder {
  readonly id: number;
  patient: number;
  readonly patient_name: string;
  test_type: TestTypeEnum;
  readonly test_type_display: string;
  frequency: FrequencyAc7Enum;
  readonly frequency_display: string;
  priority?: Priority95eEnum;
  readonly priority_display: string;
  /** @nullable */
  last_performed?: string | null;
  next_due: string;
  /**
   * @minimum 0
   * @maximum 9223372036854776000
   */
  reminder_days_before?: number;
  is_active?: boolean;
  notes?: string;
  /**
   * ÙØ§ØµÙ„Ù‡ Ø³ÙØ§Ø±Ø´ÛŒ Ø¨Ù‡ Ø±ÙˆØ² (ÙÙ‚Ø· Ø¨Ø±Ø§ÛŒ Ù†ÙˆØ¹ CUSTOM)
   * @minimum 0
   * @maximum 9223372036854776000
   * @nullable
   */
  custom_interval_days?: number | null;
  readonly created_by: number;
  readonly created_by_name: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly is_overdue: string;
  readonly days_until_due: string;
  readonly should_send_reminder: string;
}

/**
 * * `HBA1C` - HbA1c (Ù‡Ù…ÙˆÚ¯Ù„ÙˆØ¨ÛŒÙ† Ú¯Ù„ÛŒÚ©ÙˆØ²ÛŒÙ„Ù‡)
* `FBS` - Ù‚Ù†Ø¯ Ù†Ø§Ø´ØªØ§ (Fasting Blood Sugar)
* `2HPP` - Ù‚Ù†Ø¯ Û² Ø³Ø§Ø¹Øª Ø¨Ø¹Ø¯ Ø§Ø² ØºØ°Ø§ (2-Hour Post-Prandial)
* `BUN` - Ø§ÙˆØ±Ù‡ Ø®ÙˆÙ† (Blood Urea Nitrogen)
* `CR` - Ú©Ø±Ø§ØªÛŒÙ†ÛŒÙ† (Creatinine)
* `ALT` - Ø¢Ù„Ø§Ù†ÛŒÙ† Ø¢Ù…ÛŒÙ†ÙˆØªØ±Ø§Ù†Ø³ÙØ±Ø§Ø²
* `AST` - Ø¢Ø³Ù¾Ø§Ø±ØªØ§Øª Ø¢Ù…ÛŒÙ†ÙˆØªØ±Ø§Ù†Ø³ÙØ±Ø§Ø²
* `ALP` - Ø¢Ù„Ú©Ø§Ù„ÛŒÙ† ÙØ³ÙØ§ØªØ§Ø²
* `TSH` - Ù‡ÙˆØ±Ù…ÙˆÙ† Ù…Ø­Ø±Ú© ØªÛŒØ±ÙˆØ¦ÛŒØ¯
* `PR_URINE_24` - Ù¾Ø±ÙˆØªØ¦ÛŒÙ† Ø§Ø¯Ø±Ø§Ø± Û²Û´ Ø³Ø§Ø¹ØªÙ‡
* `EYE_EXAM` - Ù…Ø¹Ø§ÛŒÙ†Ù‡ Ú†Ø´Ù…
* `EMG` - Ø§Ù„Ú©ØªØ±ÙˆÙ…Ø§ÛŒÙˆÚ¯Ø±Ø§ÙÛŒ
* `NCV` - Ø³Ø±Ø¹Øª Ø±Ø³Ø§Ù†Ø´ Ø¹ØµØ¨ÛŒ
* `BMI` - Ø´Ø§Ø®Øµ ØªÙˆØ¯Ù‡ Ø¨Ø¯Ù†ÛŒ
* `BP` - ÙØ´Ø§Ø± Ø®ÙˆÙ†
* `DIET` - Ù…Ø´Ø§ÙˆØ±Ù‡ ØªØºØ°ÛŒÙ‡
* `EXERCISE` - Ø¨Ø±Ù†Ø§Ù…Ù‡ ÙˆØ±Ø²Ø´ÛŒ
 */
export type TestTypeEnum = typeof TestTypeEnum[keyof typeof TestTypeEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TestTypeEnum = {
  HBA1C: 'HBA1C',
  FBS: 'FBS',
  '2HPP': '2HPP',
  BUN: 'BUN',
  CR: 'CR',
  ALT: 'ALT',
  AST: 'AST',
  ALP: 'ALP',
  TSH: 'TSH',
  PR_URINE_24: 'PR_URINE_24',
  EYE_EXAM: 'EYE_EXAM',
  EMG: 'EMG',
  NCV: 'NCV',
  BMI: 'BMI',
  BP: 'BP',
  DIET: 'DIET',
  EXERCISE: 'EXERCISE',
} as const;

/**
 * Ø³Ø±ÛŒØ§Ù„Ø§ÛŒØ²Ø± Ø¨Ø±Ø§ÛŒ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§ÛŒ ØªØ§ÛŒÙ…â€ŒÙ„Ø§ÛŒÙ†
 */
export interface TimelineEventCategory {
  readonly id: number;
  /** @maxLength 100 */
  name: string;
  description?: string;
  /** @maxLength 7 */
  color?: string;
  /** @maxLength 50 */
  icon?: string;
}

export interface TokenObtainPair {
  email: string;
  password: string;
  readonly access: string;
  readonly refresh: string;
}

export interface TokenRefresh {
  readonly access: string;
  refresh: string;
}

/**
 * * `IMPROVING` - Ø¨Ù‡Ø¨ÙˆØ¯
* `STABLE` - Ù¾Ø§ÛŒØ¯Ø§Ø±
* `WORSENING` - Ø¨Ø¯ØªØ± Ø´Ø¯Ù†
* `FLUCTUATING` - Ù†ÙˆØ³Ø§Ù†
 */
export type TrendDirectionEnum = typeof TrendDirectionEnum[keyof typeof TrendDirectionEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TrendDirectionEnum = {
  IMPROVING: 'IMPROVING',
  STABLE: 'STABLE',
  WORSENING: 'WORSENING',
  FLUCTUATING: 'FLUCTUATING',
} as const;

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * List all AI summaries with optional filtering by patient
 * @summary List AI summaries
 */
export const apiAiSummariesList = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<AISummaryList[]>(
      {url: `/api/ai-summaries/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiAiSummariesListQueryKey = () => {
    return [`/api/ai-summaries/`] as const;
    }

    
export const getApiAiSummariesListQueryOptions = <TData = Awaited<ReturnType<typeof apiAiSummariesList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiAiSummariesListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiAiSummariesList>>> = ({ signal }) => apiAiSummariesList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiAiSummariesListQueryResult = NonNullable<Awaited<ReturnType<typeof apiAiSummariesList>>>
export type ApiAiSummariesListQueryError = unknown


export function useApiAiSummariesList<TData = Awaited<ReturnType<typeof apiAiSummariesList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAiSummariesList>>,
          TError,
          Awaited<ReturnType<typeof apiAiSummariesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAiSummariesList<TData = Awaited<ReturnType<typeof apiAiSummariesList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAiSummariesList>>,
          TError,
          Awaited<ReturnType<typeof apiAiSummariesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAiSummariesList<TData = Awaited<ReturnType<typeof apiAiSummariesList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List AI summaries
 */

export function useApiAiSummariesList<TData = Awaited<ReturnType<typeof apiAiSummariesList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiAiSummariesListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new AI summary using GapGPT/OpenAI
 * @summary Create AI summary
 */
export const apiAiSummariesCreate = (
    createAISummary: CreateAISummary,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<CreateAISummary>(
      {url: `/api/ai-summaries/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createAISummary, signal
    },
      options);
    }
  


export const getApiAiSummariesCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesCreate>>, TError,{data: CreateAISummary}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesCreate>>, TError,{data: CreateAISummary}, TContext> => {

const mutationKey = ['apiAiSummariesCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAiSummariesCreate>>, {data: CreateAISummary}> = (props) => {
          const {data} = props ?? {};

          return  apiAiSummariesCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAiSummariesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAiSummariesCreate>>>
    export type ApiAiSummariesCreateMutationBody = CreateAISummary
    export type ApiAiSummariesCreateMutationError = unknown

    /**
 * @summary Create AI summary
 */
export const useApiAiSummariesCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesCreate>>, TError,{data: CreateAISummary}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAiSummariesCreate>>,
        TError,
        {data: CreateAISummary},
        TContext
      > => {

      const mutationOptions = getApiAiSummariesCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a specific AI summary by ID
 * @summary Get AI summary
 */
export const apiAiSummariesRetrieve = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<AISummary>(
      {url: `/api/ai-summaries/${id}/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiAiSummariesRetrieveQueryKey = (id?: number,) => {
    return [`/api/ai-summaries/${id}/`] as const;
    }

    
export const getApiAiSummariesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiAiSummariesRetrieve>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiAiSummariesRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiAiSummariesRetrieve>>> = ({ signal }) => apiAiSummariesRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiAiSummariesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiAiSummariesRetrieve>>>
export type ApiAiSummariesRetrieveQueryError = unknown


export function useApiAiSummariesRetrieve<TData = Awaited<ReturnType<typeof apiAiSummariesRetrieve>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAiSummariesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAiSummariesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAiSummariesRetrieve<TData = Awaited<ReturnType<typeof apiAiSummariesRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAiSummariesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAiSummariesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAiSummariesRetrieve<TData = Awaited<ReturnType<typeof apiAiSummariesRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get AI summary
 */

export function useApiAiSummariesRetrieve<TData = Awaited<ReturnType<typeof apiAiSummariesRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiAiSummariesRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet for AI summaries with GapGPT/OpenAI integration
 */
export const apiAiSummariesUpdate = (
    id: number,
    aISummary: NonReadonly<AISummary>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<AISummary>(
      {url: `/api/ai-summaries/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: aISummary
    },
      options);
    }
  


export const getApiAiSummariesUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesUpdate>>, TError,{id: number;data: NonReadonly<AISummary>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesUpdate>>, TError,{id: number;data: NonReadonly<AISummary>}, TContext> => {

const mutationKey = ['apiAiSummariesUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAiSummariesUpdate>>, {id: number;data: NonReadonly<AISummary>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiAiSummariesUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAiSummariesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAiSummariesUpdate>>>
    export type ApiAiSummariesUpdateMutationBody = NonReadonly<AISummary>
    export type ApiAiSummariesUpdateMutationError = unknown

    export const useApiAiSummariesUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesUpdate>>, TError,{id: number;data: NonReadonly<AISummary>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAiSummariesUpdate>>,
        TError,
        {id: number;data: NonReadonly<AISummary>},
        TContext
      > => {

      const mutationOptions = getApiAiSummariesUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ViewSet for AI summaries with GapGPT/OpenAI integration
 */
export const apiAiSummariesPartialUpdate = (
    id: number,
    patchedAISummary: NonReadonly<PatchedAISummary>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<AISummary>(
      {url: `/api/ai-summaries/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedAISummary
    },
      options);
    }
  


export const getApiAiSummariesPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedAISummary>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedAISummary>}, TContext> => {

const mutationKey = ['apiAiSummariesPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAiSummariesPartialUpdate>>, {id: number;data: NonReadonly<PatchedAISummary>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiAiSummariesPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAiSummariesPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAiSummariesPartialUpdate>>>
    export type ApiAiSummariesPartialUpdateMutationBody = NonReadonly<PatchedAISummary>
    export type ApiAiSummariesPartialUpdateMutationError = unknown

    export const useApiAiSummariesPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedAISummary>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAiSummariesPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedAISummary>},
        TContext
      > => {

      const mutationOptions = getApiAiSummariesPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete an AI summary
 * @summary Delete AI summary
 */
export const apiAiSummariesDestroy = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<null>(
      {url: `/api/ai-summaries/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getApiAiSummariesDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['apiAiSummariesDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAiSummariesDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  apiAiSummariesDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAiSummariesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof apiAiSummariesDestroy>>>
    
    export type ApiAiSummariesDestroyMutationError = unknown

    /**
 * @summary Delete AI summary
 */
export const useApiAiSummariesDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAiSummariesDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getApiAiSummariesDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Regenerate AI summary for existing record with new content
 * @summary Regenerate AI summary
 */
export const apiAiSummariesRegenerateCreate = (
    id: number,
    regenerateAISummary: RegenerateAISummary,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<AISummary>(
      {url: `/api/ai-summaries/${id}/regenerate/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: regenerateAISummary, signal
    },
      options);
    }
  


export const getApiAiSummariesRegenerateCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesRegenerateCreate>>, TError,{id: number;data: RegenerateAISummary}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesRegenerateCreate>>, TError,{id: number;data: RegenerateAISummary}, TContext> => {

const mutationKey = ['apiAiSummariesRegenerateCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAiSummariesRegenerateCreate>>, {id: number;data: RegenerateAISummary}> = (props) => {
          const {id,data} = props ?? {};

          return  apiAiSummariesRegenerateCreate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAiSummariesRegenerateCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAiSummariesRegenerateCreate>>>
    export type ApiAiSummariesRegenerateCreateMutationBody = RegenerateAISummary
    export type ApiAiSummariesRegenerateCreateMutationError = unknown

    /**
 * @summary Regenerate AI summary
 */
export const useApiAiSummariesRegenerateCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesRegenerateCreate>>, TError,{id: number;data: RegenerateAISummary}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAiSummariesRegenerateCreate>>,
        TError,
        {id: number;data: RegenerateAISummary},
        TContext
      > => {

      const mutationOptions = getApiAiSummariesRegenerateCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get statistics about AI summaries
 * @summary Get summary statistics
 */
export const apiAiSummariesStatsRetrieve = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<AISummary>(
      {url: `/api/ai-summaries/stats/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiAiSummariesStatsRetrieveQueryKey = () => {
    return [`/api/ai-summaries/stats/`] as const;
    }

    
export const getApiAiSummariesStatsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiAiSummariesStatsRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>> = ({ signal }) => apiAiSummariesStatsRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiAiSummariesStatsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>>
export type ApiAiSummariesStatsRetrieveQueryError = unknown


export function useApiAiSummariesStatsRetrieve<TData = Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAiSummariesStatsRetrieve<TData = Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAiSummariesStatsRetrieve<TData = Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get summary statistics
 */

export function useApiAiSummariesStatsRetrieve<TData = Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiAiSummariesStatsRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Test the AI service connection and generate a simple summary
 * @summary Test AI service
 */
export const apiAiSummariesTestCreate = (
    aISummary: NonReadonly<AISummary>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<AISummary>(
      {url: `/api/ai-summaries/test/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: aISummary, signal
    },
      options);
    }
  


export const getApiAiSummariesTestCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesTestCreate>>, TError,{data: NonReadonly<AISummary>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesTestCreate>>, TError,{data: NonReadonly<AISummary>}, TContext> => {

const mutationKey = ['apiAiSummariesTestCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAiSummariesTestCreate>>, {data: NonReadonly<AISummary>}> = (props) => {
          const {data} = props ?? {};

          return  apiAiSummariesTestCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAiSummariesTestCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAiSummariesTestCreate>>>
    export type ApiAiSummariesTestCreateMutationBody = NonReadonly<AISummary>
    export type ApiAiSummariesTestCreateMutationError = unknown

    /**
 * @summary Test AI service
 */
export const useApiAiSummariesTestCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesTestCreate>>, TError,{data: NonReadonly<AISummary>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAiSummariesTestCreate>>,
        TError,
        {data: NonReadonly<AISummary>},
        TContext
      > => {

      const mutationOptions = getApiAiSummariesTestCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Test the clinical references linking function with sample text
 * @summary Test clinical references linking
 */
export const apiAiSummariesTestReferencesCreate = (
    aISummary: NonReadonly<AISummary>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<AISummary>(
      {url: `/api/ai-summaries/test-references/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: aISummary, signal
    },
      options);
    }
  


export const getApiAiSummariesTestReferencesCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesTestReferencesCreate>>, TError,{data: NonReadonly<AISummary>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesTestReferencesCreate>>, TError,{data: NonReadonly<AISummary>}, TContext> => {

const mutationKey = ['apiAiSummariesTestReferencesCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAiSummariesTestReferencesCreate>>, {data: NonReadonly<AISummary>}> = (props) => {
          const {data} = props ?? {};

          return  apiAiSummariesTestReferencesCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAiSummariesTestReferencesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAiSummariesTestReferencesCreate>>>
    export type ApiAiSummariesTestReferencesCreateMutationBody = NonReadonly<AISummary>
    export type ApiAiSummariesTestReferencesCreateMutationError = unknown

    /**
 * @summary Test clinical references linking
 */
export const useApiAiSummariesTestReferencesCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAiSummariesTestReferencesCreate>>, TError,{data: NonReadonly<AISummary>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAiSummariesTestReferencesCreate>>,
        TError,
        {data: NonReadonly<AISummary>},
        TContext
      > => {

      const mutationOptions = getApiAiSummariesTestReferencesCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ù‡Ø´Ø¯Ø§Ø±Ù‡Ø§ÛŒ Ø¨Ø§Ù„ÛŒÙ†ÛŒ
 */
export const apiAlertsList = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<ClinicalAlert[]>(
      {url: `/api/alerts/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiAlertsListQueryKey = () => {
    return [`/api/alerts/`] as const;
    }

    
export const getApiAlertsListQueryOptions = <TData = Awaited<ReturnType<typeof apiAlertsList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAlertsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiAlertsListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiAlertsList>>> = ({ signal }) => apiAlertsList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiAlertsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiAlertsListQueryResult = NonNullable<Awaited<ReturnType<typeof apiAlertsList>>>
export type ApiAlertsListQueryError = unknown


export function useApiAlertsList<TData = Awaited<ReturnType<typeof apiAlertsList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAlertsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAlertsList>>,
          TError,
          Awaited<ReturnType<typeof apiAlertsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAlertsList<TData = Awaited<ReturnType<typeof apiAlertsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAlertsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAlertsList>>,
          TError,
          Awaited<ReturnType<typeof apiAlertsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAlertsList<TData = Awaited<ReturnType<typeof apiAlertsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAlertsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiAlertsList<TData = Awaited<ReturnType<typeof apiAlertsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAlertsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiAlertsListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ù‡Ø´Ø¯Ø§Ø±Ù‡Ø§ÛŒ Ø¨Ø§Ù„ÛŒÙ†ÛŒ
 */
export const apiAlertsRetrieve = (
    id: string,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<ClinicalAlert>(
      {url: `/api/alerts/${id}/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiAlertsRetrieveQueryKey = (id?: string,) => {
    return [`/api/alerts/${id}/`] as const;
    }

    
export const getApiAlertsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiAlertsRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAlertsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiAlertsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiAlertsRetrieve>>> = ({ signal }) => apiAlertsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiAlertsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiAlertsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiAlertsRetrieve>>>
export type ApiAlertsRetrieveQueryError = unknown


export function useApiAlertsRetrieve<TData = Awaited<ReturnType<typeof apiAlertsRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAlertsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAlertsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAlertsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAlertsRetrieve<TData = Awaited<ReturnType<typeof apiAlertsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAlertsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAlertsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAlertsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAlertsRetrieve<TData = Awaited<ReturnType<typeof apiAlertsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAlertsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiAlertsRetrieve<TData = Awaited<ReturnType<typeof apiAlertsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAlertsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiAlertsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ØªØ§ÛŒÛŒØ¯ Ù‡Ø´Ø¯Ø§Ø± ØªÙˆØ³Ø· Ù¾Ø²Ø´Ú©
 */
export const apiAlertsAcknowledgeCreate = (
    id: string,
    clinicalAlert: NonReadonly<ClinicalAlert>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<ClinicalAlert>(
      {url: `/api/alerts/${id}/acknowledge/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: clinicalAlert, signal
    },
      options);
    }
  


export const getApiAlertsAcknowledgeCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAlertsAcknowledgeCreate>>, TError,{id: string;data: NonReadonly<ClinicalAlert>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAlertsAcknowledgeCreate>>, TError,{id: string;data: NonReadonly<ClinicalAlert>}, TContext> => {

const mutationKey = ['apiAlertsAcknowledgeCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAlertsAcknowledgeCreate>>, {id: string;data: NonReadonly<ClinicalAlert>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiAlertsAcknowledgeCreate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAlertsAcknowledgeCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAlertsAcknowledgeCreate>>>
    export type ApiAlertsAcknowledgeCreateMutationBody = NonReadonly<ClinicalAlert>
    export type ApiAlertsAcknowledgeCreateMutationError = unknown

    export const useApiAlertsAcknowledgeCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAlertsAcknowledgeCreate>>, TError,{id: string;data: NonReadonly<ClinicalAlert>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAlertsAcknowledgeCreate>>,
        TError,
        {id: string;data: NonReadonly<ClinicalAlert>},
        TContext
      > => {

      const mutationOptions = getApiAlertsAcknowledgeCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ØªØ¹Ø¯Ø§Ø¯ Ù‡Ø´Ø¯Ø§Ø±Ù‡Ø§ÛŒ ÙØ¹Ø§Ù„
 */
export const apiAlertsActiveCountRetrieve = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<ClinicalAlert>(
      {url: `/api/alerts/active_count/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiAlertsActiveCountRetrieveQueryKey = () => {
    return [`/api/alerts/active_count/`] as const;
    }

    
export const getApiAlertsActiveCountRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiAlertsActiveCountRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAlertsActiveCountRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiAlertsActiveCountRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiAlertsActiveCountRetrieve>>> = ({ signal }) => apiAlertsActiveCountRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiAlertsActiveCountRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiAlertsActiveCountRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiAlertsActiveCountRetrieve>>>
export type ApiAlertsActiveCountRetrieveQueryError = unknown


export function useApiAlertsActiveCountRetrieve<TData = Awaited<ReturnType<typeof apiAlertsActiveCountRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAlertsActiveCountRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAlertsActiveCountRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAlertsActiveCountRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAlertsActiveCountRetrieve<TData = Awaited<ReturnType<typeof apiAlertsActiveCountRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAlertsActiveCountRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAlertsActiveCountRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAlertsActiveCountRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAlertsActiveCountRetrieve<TData = Awaited<ReturnType<typeof apiAlertsActiveCountRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAlertsActiveCountRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiAlertsActiveCountRetrieve<TData = Awaited<ReturnType<typeof apiAlertsActiveCountRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAlertsActiveCountRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiAlertsActiveCountRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Ø®Ù„Ø§ØµÙ‡ Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯ Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø± ÙØ¹Ù„ÛŒ
 */
export const apiAnalyticsDashboardSummaryRetrieve = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<null>(
      {url: `/api/analytics/dashboard/summary/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiAnalyticsDashboardSummaryRetrieveQueryKey = () => {
    return [`/api/analytics/dashboard/summary/`] as const;
    }

    
export const getApiAnalyticsDashboardSummaryRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiAnalyticsDashboardSummaryRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDashboardSummaryRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiAnalyticsDashboardSummaryRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiAnalyticsDashboardSummaryRetrieve>>> = ({ signal }) => apiAnalyticsDashboardSummaryRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDashboardSummaryRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiAnalyticsDashboardSummaryRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsDashboardSummaryRetrieve>>>
export type ApiAnalyticsDashboardSummaryRetrieveQueryError = unknown


export function useApiAnalyticsDashboardSummaryRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsDashboardSummaryRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDashboardSummaryRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsDashboardSummaryRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsDashboardSummaryRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsDashboardSummaryRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsDashboardSummaryRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDashboardSummaryRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsDashboardSummaryRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsDashboardSummaryRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsDashboardSummaryRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsDashboardSummaryRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDashboardSummaryRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiAnalyticsDashboardSummaryRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsDashboardSummaryRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDashboardSummaryRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiAnalyticsDashboardSummaryRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Ø¯Ø±ÛŒØ§ÙØª ÙˆÛŒØ¬Øªâ€ŒÙ‡Ø§ÛŒ Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯
 */
export const apiAnalyticsDashboardWidgetsRetrieve = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<null>(
      {url: `/api/analytics/dashboard/widgets/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiAnalyticsDashboardWidgetsRetrieveQueryKey = () => {
    return [`/api/analytics/dashboard/widgets/`] as const;
    }

    
export const getApiAnalyticsDashboardWidgetsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiAnalyticsDashboardWidgetsRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDashboardWidgetsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiAnalyticsDashboardWidgetsRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiAnalyticsDashboardWidgetsRetrieve>>> = ({ signal }) => apiAnalyticsDashboardWidgetsRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDashboardWidgetsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiAnalyticsDashboardWidgetsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsDashboardWidgetsRetrieve>>>
export type ApiAnalyticsDashboardWidgetsRetrieveQueryError = unknown


export function useApiAnalyticsDashboardWidgetsRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsDashboardWidgetsRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDashboardWidgetsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsDashboardWidgetsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsDashboardWidgetsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsDashboardWidgetsRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsDashboardWidgetsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDashboardWidgetsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsDashboardWidgetsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsDashboardWidgetsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsDashboardWidgetsRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsDashboardWidgetsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDashboardWidgetsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiAnalyticsDashboardWidgetsRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsDashboardWidgetsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDashboardWidgetsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiAnalyticsDashboardWidgetsRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØªÛŒÚ©Ø³ Ù¾Ø²Ø´Ú©Ø§Ù†
 */
export const apiAnalyticsDoctorAnalyticsList = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<DoctorAnalytics[]>(
      {url: `/api/analytics/doctor-analytics/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiAnalyticsDoctorAnalyticsListQueryKey = () => {
    return [`/api/analytics/doctor-analytics/`] as const;
    }

    
export const getApiAnalyticsDoctorAnalyticsListQueryOptions = <TData = Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiAnalyticsDoctorAnalyticsListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsList>>> = ({ signal }) => apiAnalyticsDoctorAnalyticsList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiAnalyticsDoctorAnalyticsListQueryResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsList>>>
export type ApiAnalyticsDoctorAnalyticsListQueryError = unknown


export function useApiAnalyticsDoctorAnalyticsList<TData = Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsList>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsDoctorAnalyticsList<TData = Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsList>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsDoctorAnalyticsList<TData = Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiAnalyticsDoctorAnalyticsList<TData = Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiAnalyticsDoctorAnalyticsListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØªÛŒÚ©Ø³ Ù¾Ø²Ø´Ú©Ø§Ù†
 */
export const apiAnalyticsDoctorAnalyticsCreate = (
    doctorAnalytics: NonReadonly<DoctorAnalytics>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<DoctorAnalytics>(
      {url: `/api/analytics/doctor-analytics/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: doctorAnalytics, signal
    },
      options);
    }
  


export const getApiAnalyticsDoctorAnalyticsCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsCreate>>, TError,{data: NonReadonly<DoctorAnalytics>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsCreate>>, TError,{data: NonReadonly<DoctorAnalytics>}, TContext> => {

const mutationKey = ['apiAnalyticsDoctorAnalyticsCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsCreate>>, {data: NonReadonly<DoctorAnalytics>}> = (props) => {
          const {data} = props ?? {};

          return  apiAnalyticsDoctorAnalyticsCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAnalyticsDoctorAnalyticsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsCreate>>>
    export type ApiAnalyticsDoctorAnalyticsCreateMutationBody = NonReadonly<DoctorAnalytics>
    export type ApiAnalyticsDoctorAnalyticsCreateMutationError = unknown

    export const useApiAnalyticsDoctorAnalyticsCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsCreate>>, TError,{data: NonReadonly<DoctorAnalytics>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsCreate>>,
        TError,
        {data: NonReadonly<DoctorAnalytics>},
        TContext
      > => {

      const mutationOptions = getApiAnalyticsDoctorAnalyticsCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØªÛŒÚ©Ø³ Ù¾Ø²Ø´Ú©Ø§Ù†
 */
export const apiAnalyticsDoctorAnalyticsRetrieve = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<DoctorAnalytics>(
      {url: `/api/analytics/doctor-analytics/${id}/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiAnalyticsDoctorAnalyticsRetrieveQueryKey = (id?: number,) => {
    return [`/api/analytics/doctor-analytics/${id}/`] as const;
    }

    
export const getApiAnalyticsDoctorAnalyticsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsRetrieve>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiAnalyticsDoctorAnalyticsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsRetrieve>>> = ({ signal }) => apiAnalyticsDoctorAnalyticsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiAnalyticsDoctorAnalyticsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsRetrieve>>>
export type ApiAnalyticsDoctorAnalyticsRetrieveQueryError = unknown


export function useApiAnalyticsDoctorAnalyticsRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsRetrieve>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsDoctorAnalyticsRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsDoctorAnalyticsRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiAnalyticsDoctorAnalyticsRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiAnalyticsDoctorAnalyticsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØªÛŒÚ©Ø³ Ù¾Ø²Ø´Ú©Ø§Ù†
 */
export const apiAnalyticsDoctorAnalyticsUpdate = (
    id: number,
    doctorAnalytics: NonReadonly<DoctorAnalytics>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<DoctorAnalytics>(
      {url: `/api/analytics/doctor-analytics/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: doctorAnalytics
    },
      options);
    }
  


export const getApiAnalyticsDoctorAnalyticsUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsUpdate>>, TError,{id: number;data: NonReadonly<DoctorAnalytics>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsUpdate>>, TError,{id: number;data: NonReadonly<DoctorAnalytics>}, TContext> => {

const mutationKey = ['apiAnalyticsDoctorAnalyticsUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsUpdate>>, {id: number;data: NonReadonly<DoctorAnalytics>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiAnalyticsDoctorAnalyticsUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAnalyticsDoctorAnalyticsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsUpdate>>>
    export type ApiAnalyticsDoctorAnalyticsUpdateMutationBody = NonReadonly<DoctorAnalytics>
    export type ApiAnalyticsDoctorAnalyticsUpdateMutationError = unknown

    export const useApiAnalyticsDoctorAnalyticsUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsUpdate>>, TError,{id: number;data: NonReadonly<DoctorAnalytics>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsUpdate>>,
        TError,
        {id: number;data: NonReadonly<DoctorAnalytics>},
        TContext
      > => {

      const mutationOptions = getApiAnalyticsDoctorAnalyticsUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØªÛŒÚ©Ø³ Ù¾Ø²Ø´Ú©Ø§Ù†
 */
export const apiAnalyticsDoctorAnalyticsPartialUpdate = (
    id: number,
    patchedDoctorAnalytics: NonReadonly<PatchedDoctorAnalytics>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<DoctorAnalytics>(
      {url: `/api/analytics/doctor-analytics/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedDoctorAnalytics
    },
      options);
    }
  


export const getApiAnalyticsDoctorAnalyticsPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedDoctorAnalytics>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedDoctorAnalytics>}, TContext> => {

const mutationKey = ['apiAnalyticsDoctorAnalyticsPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPartialUpdate>>, {id: number;data: NonReadonly<PatchedDoctorAnalytics>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiAnalyticsDoctorAnalyticsPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAnalyticsDoctorAnalyticsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPartialUpdate>>>
    export type ApiAnalyticsDoctorAnalyticsPartialUpdateMutationBody = NonReadonly<PatchedDoctorAnalytics>
    export type ApiAnalyticsDoctorAnalyticsPartialUpdateMutationError = unknown

    export const useApiAnalyticsDoctorAnalyticsPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedDoctorAnalytics>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedDoctorAnalytics>},
        TContext
      > => {

      const mutationOptions = getApiAnalyticsDoctorAnalyticsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØªÛŒÚ©Ø³ Ù¾Ø²Ø´Ú©Ø§Ù†
 */
export const apiAnalyticsDoctorAnalyticsDestroy = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<null>(
      {url: `/api/analytics/doctor-analytics/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getApiAnalyticsDoctorAnalyticsDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['apiAnalyticsDoctorAnalyticsDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  apiAnalyticsDoctorAnalyticsDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAnalyticsDoctorAnalyticsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsDestroy>>>
    
    export type ApiAnalyticsDoctorAnalyticsDestroyMutationError = unknown

    export const useApiAnalyticsDoctorAnalyticsDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getApiAnalyticsDoctorAnalyticsDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Ø¯Ø±ÛŒØ§ÙØª Ù†Ù…ÙˆØ¯Ø§Ø± ØªÙˆØ²ÛŒØ¹ Ø¨ÛŒÙ…Ø§Ø±Ø§Ù†
 */
export const apiAnalyticsDoctorAnalyticsPatientDistributionRetrieve = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<DoctorAnalytics>(
      {url: `/api/analytics/doctor-analytics/${id}/patient_distribution/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiAnalyticsDoctorAnalyticsPatientDistributionRetrieveQueryKey = (id?: number,) => {
    return [`/api/analytics/doctor-analytics/${id}/patient_distribution/`] as const;
    }

    
export const getApiAnalyticsDoctorAnalyticsPatientDistributionRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPatientDistributionRetrieve>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPatientDistributionRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiAnalyticsDoctorAnalyticsPatientDistributionRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPatientDistributionRetrieve>>> = ({ signal }) => apiAnalyticsDoctorAnalyticsPatientDistributionRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPatientDistributionRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiAnalyticsDoctorAnalyticsPatientDistributionRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPatientDistributionRetrieve>>>
export type ApiAnalyticsDoctorAnalyticsPatientDistributionRetrieveQueryError = unknown


export function useApiAnalyticsDoctorAnalyticsPatientDistributionRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPatientDistributionRetrieve>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPatientDistributionRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPatientDistributionRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPatientDistributionRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsDoctorAnalyticsPatientDistributionRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPatientDistributionRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPatientDistributionRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPatientDistributionRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPatientDistributionRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsDoctorAnalyticsPatientDistributionRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPatientDistributionRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPatientDistributionRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiAnalyticsDoctorAnalyticsPatientDistributionRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPatientDistributionRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPatientDistributionRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiAnalyticsDoctorAnalyticsPatientDistributionRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¢Ù†Ø§Ù„ÛŒØªÛŒÚ©Ø³ Ø¨Ø±Ø§ÛŒ ÛŒÚ© Ù¾Ø²Ø´Ú©
 */
export const apiAnalyticsDoctorAnalyticsCalculateCreate = (
    doctorAnalytics: NonReadonly<DoctorAnalytics>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<DoctorAnalytics>(
      {url: `/api/analytics/doctor-analytics/calculate/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: doctorAnalytics, signal
    },
      options);
    }
  


export const getApiAnalyticsDoctorAnalyticsCalculateCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsCalculateCreate>>, TError,{data: NonReadonly<DoctorAnalytics>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsCalculateCreate>>, TError,{data: NonReadonly<DoctorAnalytics>}, TContext> => {

const mutationKey = ['apiAnalyticsDoctorAnalyticsCalculateCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsCalculateCreate>>, {data: NonReadonly<DoctorAnalytics>}> = (props) => {
          const {data} = props ?? {};

          return  apiAnalyticsDoctorAnalyticsCalculateCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAnalyticsDoctorAnalyticsCalculateCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsCalculateCreate>>>
    export type ApiAnalyticsDoctorAnalyticsCalculateCreateMutationBody = NonReadonly<DoctorAnalytics>
    export type ApiAnalyticsDoctorAnalyticsCalculateCreateMutationError = unknown

    export const useApiAnalyticsDoctorAnalyticsCalculateCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsCalculateCreate>>, TError,{data: NonReadonly<DoctorAnalytics>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsCalculateCreate>>,
        TError,
        {data: NonReadonly<DoctorAnalytics>},
        TContext
      > => {

      const mutationOptions = getApiAnalyticsDoctorAnalyticsCalculateCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Ù…Ù‚Ø§ÛŒØ³Ù‡ Ø¹Ù…Ù„Ú©Ø±Ø¯ Ù¾Ø²Ø´Ú©Ø§Ù†
 */
export const apiAnalyticsDoctorAnalyticsPerformanceComparisonRetrieve = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<DoctorAnalytics>(
      {url: `/api/analytics/doctor-analytics/performance_comparison/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiAnalyticsDoctorAnalyticsPerformanceComparisonRetrieveQueryKey = () => {
    return [`/api/analytics/doctor-analytics/performance_comparison/`] as const;
    }

    
export const getApiAnalyticsDoctorAnalyticsPerformanceComparisonRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPerformanceComparisonRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPerformanceComparisonRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiAnalyticsDoctorAnalyticsPerformanceComparisonRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPerformanceComparisonRetrieve>>> = ({ signal }) => apiAnalyticsDoctorAnalyticsPerformanceComparisonRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPerformanceComparisonRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiAnalyticsDoctorAnalyticsPerformanceComparisonRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPerformanceComparisonRetrieve>>>
export type ApiAnalyticsDoctorAnalyticsPerformanceComparisonRetrieveQueryError = unknown


export function useApiAnalyticsDoctorAnalyticsPerformanceComparisonRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPerformanceComparisonRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPerformanceComparisonRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPerformanceComparisonRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPerformanceComparisonRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsDoctorAnalyticsPerformanceComparisonRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPerformanceComparisonRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPerformanceComparisonRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPerformanceComparisonRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPerformanceComparisonRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsDoctorAnalyticsPerformanceComparisonRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPerformanceComparisonRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPerformanceComparisonRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiAnalyticsDoctorAnalyticsPerformanceComparisonRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPerformanceComparisonRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsDoctorAnalyticsPerformanceComparisonRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiAnalyticsDoctorAnalyticsPerformanceComparisonRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØªÛŒÚ©Ø³ Ø¨ÛŒÙ…Ø§Ø±Ø§Ù†
 */
export const apiAnalyticsPatientAnalyticsList = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<PatientAnalytics[]>(
      {url: `/api/analytics/patient-analytics/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiAnalyticsPatientAnalyticsListQueryKey = () => {
    return [`/api/analytics/patient-analytics/`] as const;
    }

    
export const getApiAnalyticsPatientAnalyticsListQueryOptions = <TData = Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiAnalyticsPatientAnalyticsListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsList>>> = ({ signal }) => apiAnalyticsPatientAnalyticsList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiAnalyticsPatientAnalyticsListQueryResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsList>>>
export type ApiAnalyticsPatientAnalyticsListQueryError = unknown


export function useApiAnalyticsPatientAnalyticsList<TData = Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsList>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsPatientAnalyticsList<TData = Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsList>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsPatientAnalyticsList<TData = Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiAnalyticsPatientAnalyticsList<TData = Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiAnalyticsPatientAnalyticsListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØªÛŒÚ©Ø³ Ø¨ÛŒÙ…Ø§Ø±Ø§Ù†
 */
export const apiAnalyticsPatientAnalyticsCreate = (
    patientAnalytics: NonReadonly<PatientAnalytics>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<PatientAnalytics>(
      {url: `/api/analytics/patient-analytics/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: patientAnalytics, signal
    },
      options);
    }
  


export const getApiAnalyticsPatientAnalyticsCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsCreate>>, TError,{data: NonReadonly<PatientAnalytics>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsCreate>>, TError,{data: NonReadonly<PatientAnalytics>}, TContext> => {

const mutationKey = ['apiAnalyticsPatientAnalyticsCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsCreate>>, {data: NonReadonly<PatientAnalytics>}> = (props) => {
          const {data} = props ?? {};

          return  apiAnalyticsPatientAnalyticsCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAnalyticsPatientAnalyticsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsCreate>>>
    export type ApiAnalyticsPatientAnalyticsCreateMutationBody = NonReadonly<PatientAnalytics>
    export type ApiAnalyticsPatientAnalyticsCreateMutationError = unknown

    export const useApiAnalyticsPatientAnalyticsCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsCreate>>, TError,{data: NonReadonly<PatientAnalytics>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsCreate>>,
        TError,
        {data: NonReadonly<PatientAnalytics>},
        TContext
      > => {

      const mutationOptions = getApiAnalyticsPatientAnalyticsCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØªÛŒÚ©Ø³ Ø¨ÛŒÙ…Ø§Ø±Ø§Ù†
 */
export const apiAnalyticsPatientAnalyticsRetrieve = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<PatientAnalytics>(
      {url: `/api/analytics/patient-analytics/${id}/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiAnalyticsPatientAnalyticsRetrieveQueryKey = (id?: number,) => {
    return [`/api/analytics/patient-analytics/${id}/`] as const;
    }

    
export const getApiAnalyticsPatientAnalyticsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsRetrieve>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiAnalyticsPatientAnalyticsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsRetrieve>>> = ({ signal }) => apiAnalyticsPatientAnalyticsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiAnalyticsPatientAnalyticsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsRetrieve>>>
export type ApiAnalyticsPatientAnalyticsRetrieveQueryError = unknown


export function useApiAnalyticsPatientAnalyticsRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsRetrieve>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsPatientAnalyticsRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsPatientAnalyticsRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiAnalyticsPatientAnalyticsRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiAnalyticsPatientAnalyticsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØªÛŒÚ©Ø³ Ø¨ÛŒÙ…Ø§Ø±Ø§Ù†
 */
export const apiAnalyticsPatientAnalyticsUpdate = (
    id: number,
    patientAnalytics: NonReadonly<PatientAnalytics>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<PatientAnalytics>(
      {url: `/api/analytics/patient-analytics/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: patientAnalytics
    },
      options);
    }
  


export const getApiAnalyticsPatientAnalyticsUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsUpdate>>, TError,{id: number;data: NonReadonly<PatientAnalytics>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsUpdate>>, TError,{id: number;data: NonReadonly<PatientAnalytics>}, TContext> => {

const mutationKey = ['apiAnalyticsPatientAnalyticsUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsUpdate>>, {id: number;data: NonReadonly<PatientAnalytics>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiAnalyticsPatientAnalyticsUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAnalyticsPatientAnalyticsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsUpdate>>>
    export type ApiAnalyticsPatientAnalyticsUpdateMutationBody = NonReadonly<PatientAnalytics>
    export type ApiAnalyticsPatientAnalyticsUpdateMutationError = unknown

    export const useApiAnalyticsPatientAnalyticsUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsUpdate>>, TError,{id: number;data: NonReadonly<PatientAnalytics>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatientAnalytics>},
        TContext
      > => {

      const mutationOptions = getApiAnalyticsPatientAnalyticsUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØªÛŒÚ©Ø³ Ø¨ÛŒÙ…Ø§Ø±Ø§Ù†
 */
export const apiAnalyticsPatientAnalyticsPartialUpdate = (
    id: number,
    patchedPatientAnalytics: NonReadonly<PatchedPatientAnalytics>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<PatientAnalytics>(
      {url: `/api/analytics/patient-analytics/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedPatientAnalytics
    },
      options);
    }
  


export const getApiAnalyticsPatientAnalyticsPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedPatientAnalytics>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedPatientAnalytics>}, TContext> => {

const mutationKey = ['apiAnalyticsPatientAnalyticsPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsPartialUpdate>>, {id: number;data: NonReadonly<PatchedPatientAnalytics>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiAnalyticsPatientAnalyticsPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAnalyticsPatientAnalyticsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsPartialUpdate>>>
    export type ApiAnalyticsPatientAnalyticsPartialUpdateMutationBody = NonReadonly<PatchedPatientAnalytics>
    export type ApiAnalyticsPatientAnalyticsPartialUpdateMutationError = unknown

    export const useApiAnalyticsPatientAnalyticsPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedPatientAnalytics>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedPatientAnalytics>},
        TContext
      > => {

      const mutationOptions = getApiAnalyticsPatientAnalyticsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØªÛŒÚ©Ø³ Ø¨ÛŒÙ…Ø§Ø±Ø§Ù†
 */
export const apiAnalyticsPatientAnalyticsDestroy = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<null>(
      {url: `/api/analytics/patient-analytics/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getApiAnalyticsPatientAnalyticsDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['apiAnalyticsPatientAnalyticsDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  apiAnalyticsPatientAnalyticsDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAnalyticsPatientAnalyticsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsDestroy>>>
    
    export type ApiAnalyticsPatientAnalyticsDestroyMutationError = unknown

    export const useApiAnalyticsPatientAnalyticsDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getApiAnalyticsPatientAnalyticsDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù†Ù…ÙˆØ¯Ø§Ø± Ù‚Ù†Ø¯ Ø®ÙˆÙ†
 */
export const apiAnalyticsPatientAnalyticsGlucoseChartRetrieve = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<PatientAnalytics>(
      {url: `/api/analytics/patient-analytics/${id}/glucose_chart/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiAnalyticsPatientAnalyticsGlucoseChartRetrieveQueryKey = (id?: number,) => {
    return [`/api/analytics/patient-analytics/${id}/glucose_chart/`] as const;
    }

    
export const getApiAnalyticsPatientAnalyticsGlucoseChartRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsGlucoseChartRetrieve>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsGlucoseChartRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiAnalyticsPatientAnalyticsGlucoseChartRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsGlucoseChartRetrieve>>> = ({ signal }) => apiAnalyticsPatientAnalyticsGlucoseChartRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsGlucoseChartRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiAnalyticsPatientAnalyticsGlucoseChartRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsGlucoseChartRetrieve>>>
export type ApiAnalyticsPatientAnalyticsGlucoseChartRetrieveQueryError = unknown


export function useApiAnalyticsPatientAnalyticsGlucoseChartRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsGlucoseChartRetrieve>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsGlucoseChartRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsGlucoseChartRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsGlucoseChartRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsPatientAnalyticsGlucoseChartRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsGlucoseChartRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsGlucoseChartRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsGlucoseChartRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsGlucoseChartRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsPatientAnalyticsGlucoseChartRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsGlucoseChartRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsGlucoseChartRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiAnalyticsPatientAnalyticsGlucoseChartRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsGlucoseChartRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsGlucoseChartRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiAnalyticsPatientAnalyticsGlucoseChartRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø±ÙˆÙ†Ø¯ HbA1c
 */
export const apiAnalyticsPatientAnalyticsHba1cTrendRetrieve = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<PatientAnalytics>(
      {url: `/api/analytics/patient-analytics/${id}/hba1c_trend/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiAnalyticsPatientAnalyticsHba1cTrendRetrieveQueryKey = (id?: number,) => {
    return [`/api/analytics/patient-analytics/${id}/hba1c_trend/`] as const;
    }

    
export const getApiAnalyticsPatientAnalyticsHba1cTrendRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsHba1cTrendRetrieve>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsHba1cTrendRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiAnalyticsPatientAnalyticsHba1cTrendRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsHba1cTrendRetrieve>>> = ({ signal }) => apiAnalyticsPatientAnalyticsHba1cTrendRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsHba1cTrendRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiAnalyticsPatientAnalyticsHba1cTrendRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsHba1cTrendRetrieve>>>
export type ApiAnalyticsPatientAnalyticsHba1cTrendRetrieveQueryError = unknown


export function useApiAnalyticsPatientAnalyticsHba1cTrendRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsHba1cTrendRetrieve>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsHba1cTrendRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsHba1cTrendRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsHba1cTrendRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsPatientAnalyticsHba1cTrendRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsHba1cTrendRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsHba1cTrendRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsHba1cTrendRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsHba1cTrendRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsPatientAnalyticsHba1cTrendRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsHba1cTrendRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsHba1cTrendRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiAnalyticsPatientAnalyticsHba1cTrendRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsHba1cTrendRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsHba1cTrendRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiAnalyticsPatientAnalyticsHba1cTrendRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Ø¯Ø±ÛŒØ§ÙØª Ø¢Ù†Ø§Ù„ÛŒØªÛŒÚ©Ø³ Ø¨Ø±Ø§ÛŒ Ú†Ù†Ø¯ Ø¨ÛŒÙ…Ø§Ø±
 */
export const apiAnalyticsPatientAnalyticsBatchAnalyticsRetrieve = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<PatientAnalytics>(
      {url: `/api/analytics/patient-analytics/batch_analytics/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiAnalyticsPatientAnalyticsBatchAnalyticsRetrieveQueryKey = () => {
    return [`/api/analytics/patient-analytics/batch_analytics/`] as const;
    }

    
export const getApiAnalyticsPatientAnalyticsBatchAnalyticsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsBatchAnalyticsRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsBatchAnalyticsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiAnalyticsPatientAnalyticsBatchAnalyticsRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsBatchAnalyticsRetrieve>>> = ({ signal }) => apiAnalyticsPatientAnalyticsBatchAnalyticsRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsBatchAnalyticsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiAnalyticsPatientAnalyticsBatchAnalyticsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsBatchAnalyticsRetrieve>>>
export type ApiAnalyticsPatientAnalyticsBatchAnalyticsRetrieveQueryError = unknown


export function useApiAnalyticsPatientAnalyticsBatchAnalyticsRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsBatchAnalyticsRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsBatchAnalyticsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsBatchAnalyticsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsBatchAnalyticsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsPatientAnalyticsBatchAnalyticsRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsBatchAnalyticsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsBatchAnalyticsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsBatchAnalyticsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsBatchAnalyticsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsPatientAnalyticsBatchAnalyticsRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsBatchAnalyticsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsBatchAnalyticsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiAnalyticsPatientAnalyticsBatchAnalyticsRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsBatchAnalyticsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsBatchAnalyticsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiAnalyticsPatientAnalyticsBatchAnalyticsRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¢Ù†Ø§Ù„ÛŒØªÛŒÚ©Ø³ Ø¨Ø±Ø§ÛŒ ÛŒÚ© Ø¨ÛŒÙ…Ø§Ø±
 */
export const apiAnalyticsPatientAnalyticsCalculateCreate = (
    patientAnalytics: NonReadonly<PatientAnalytics>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<PatientAnalytics>(
      {url: `/api/analytics/patient-analytics/calculate/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: patientAnalytics, signal
    },
      options);
    }
  


export const getApiAnalyticsPatientAnalyticsCalculateCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsCalculateCreate>>, TError,{data: NonReadonly<PatientAnalytics>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsCalculateCreate>>, TError,{data: NonReadonly<PatientAnalytics>}, TContext> => {

const mutationKey = ['apiAnalyticsPatientAnalyticsCalculateCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsCalculateCreate>>, {data: NonReadonly<PatientAnalytics>}> = (props) => {
          const {data} = props ?? {};

          return  apiAnalyticsPatientAnalyticsCalculateCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAnalyticsPatientAnalyticsCalculateCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsCalculateCreate>>>
    export type ApiAnalyticsPatientAnalyticsCalculateCreateMutationBody = NonReadonly<PatientAnalytics>
    export type ApiAnalyticsPatientAnalyticsCalculateCreateMutationError = unknown

    export const useApiAnalyticsPatientAnalyticsCalculateCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsCalculateCreate>>, TError,{data: NonReadonly<PatientAnalytics>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAnalyticsPatientAnalyticsCalculateCreate>>,
        TError,
        {data: NonReadonly<PatientAnalytics>},
        TContext
      > => {

      const mutationOptions = getApiAnalyticsPatientAnalyticsCalculateCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª Ú¯Ø²Ø§Ø±Ø´â€ŒÙ‡Ø§
 */
export const apiAnalyticsReportsList = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<Report[]>(
      {url: `/api/analytics/reports/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiAnalyticsReportsListQueryKey = () => {
    return [`/api/analytics/reports/`] as const;
    }

    
export const getApiAnalyticsReportsListQueryOptions = <TData = Awaited<ReturnType<typeof apiAnalyticsReportsList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsReportsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiAnalyticsReportsListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiAnalyticsReportsList>>> = ({ signal }) => apiAnalyticsReportsList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsReportsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiAnalyticsReportsListQueryResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsReportsList>>>
export type ApiAnalyticsReportsListQueryError = unknown


export function useApiAnalyticsReportsList<TData = Awaited<ReturnType<typeof apiAnalyticsReportsList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsReportsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsReportsList>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsReportsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsReportsList<TData = Awaited<ReturnType<typeof apiAnalyticsReportsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsReportsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsReportsList>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsReportsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsReportsList<TData = Awaited<ReturnType<typeof apiAnalyticsReportsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsReportsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiAnalyticsReportsList<TData = Awaited<ReturnType<typeof apiAnalyticsReportsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsReportsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiAnalyticsReportsListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Ø§ÛŒØ¬Ø§Ø¯ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ú¯Ø²Ø§Ø±Ø´ Ø¬Ø¯ÛŒØ¯
 */
export const apiAnalyticsReportsCreate = (
    report: NonReadonly<Report>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<Report>(
      {url: `/api/analytics/reports/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: report, signal
    },
      options);
    }
  


export const getApiAnalyticsReportsCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsReportsCreate>>, TError,{data: NonReadonly<Report>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsReportsCreate>>, TError,{data: NonReadonly<Report>}, TContext> => {

const mutationKey = ['apiAnalyticsReportsCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAnalyticsReportsCreate>>, {data: NonReadonly<Report>}> = (props) => {
          const {data} = props ?? {};

          return  apiAnalyticsReportsCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAnalyticsReportsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsReportsCreate>>>
    export type ApiAnalyticsReportsCreateMutationBody = NonReadonly<Report>
    export type ApiAnalyticsReportsCreateMutationError = unknown

    export const useApiAnalyticsReportsCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsReportsCreate>>, TError,{data: NonReadonly<Report>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAnalyticsReportsCreate>>,
        TError,
        {data: NonReadonly<Report>},
        TContext
      > => {

      const mutationOptions = getApiAnalyticsReportsCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª Ú¯Ø²Ø§Ø±Ø´â€ŒÙ‡Ø§
 */
export const apiAnalyticsReportsRetrieve = (
    id: string,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<Report>(
      {url: `/api/analytics/reports/${id}/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiAnalyticsReportsRetrieveQueryKey = (id?: string,) => {
    return [`/api/analytics/reports/${id}/`] as const;
    }

    
export const getApiAnalyticsReportsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiAnalyticsReportsRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsReportsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiAnalyticsReportsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiAnalyticsReportsRetrieve>>> = ({ signal }) => apiAnalyticsReportsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsReportsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiAnalyticsReportsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsReportsRetrieve>>>
export type ApiAnalyticsReportsRetrieveQueryError = unknown


export function useApiAnalyticsReportsRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsReportsRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsReportsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsReportsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsReportsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsReportsRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsReportsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsReportsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsReportsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsReportsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsReportsRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsReportsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsReportsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiAnalyticsReportsRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsReportsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsReportsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiAnalyticsReportsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª Ú¯Ø²Ø§Ø±Ø´â€ŒÙ‡Ø§
 */
export const apiAnalyticsReportsUpdate = (
    id: string,
    report: NonReadonly<Report>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<Report>(
      {url: `/api/analytics/reports/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: report
    },
      options);
    }
  


export const getApiAnalyticsReportsUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsReportsUpdate>>, TError,{id: string;data: NonReadonly<Report>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsReportsUpdate>>, TError,{id: string;data: NonReadonly<Report>}, TContext> => {

const mutationKey = ['apiAnalyticsReportsUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAnalyticsReportsUpdate>>, {id: string;data: NonReadonly<Report>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiAnalyticsReportsUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAnalyticsReportsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsReportsUpdate>>>
    export type ApiAnalyticsReportsUpdateMutationBody = NonReadonly<Report>
    export type ApiAnalyticsReportsUpdateMutationError = unknown

    export const useApiAnalyticsReportsUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsReportsUpdate>>, TError,{id: string;data: NonReadonly<Report>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAnalyticsReportsUpdate>>,
        TError,
        {id: string;data: NonReadonly<Report>},
        TContext
      > => {

      const mutationOptions = getApiAnalyticsReportsUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª Ú¯Ø²Ø§Ø±Ø´â€ŒÙ‡Ø§
 */
export const apiAnalyticsReportsPartialUpdate = (
    id: string,
    patchedReport: NonReadonly<PatchedReport>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<Report>(
      {url: `/api/analytics/reports/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedReport
    },
      options);
    }
  


export const getApiAnalyticsReportsPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsReportsPartialUpdate>>, TError,{id: string;data: NonReadonly<PatchedReport>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsReportsPartialUpdate>>, TError,{id: string;data: NonReadonly<PatchedReport>}, TContext> => {

const mutationKey = ['apiAnalyticsReportsPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAnalyticsReportsPartialUpdate>>, {id: string;data: NonReadonly<PatchedReport>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiAnalyticsReportsPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAnalyticsReportsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsReportsPartialUpdate>>>
    export type ApiAnalyticsReportsPartialUpdateMutationBody = NonReadonly<PatchedReport>
    export type ApiAnalyticsReportsPartialUpdateMutationError = unknown

    export const useApiAnalyticsReportsPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsReportsPartialUpdate>>, TError,{id: string;data: NonReadonly<PatchedReport>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAnalyticsReportsPartialUpdate>>,
        TError,
        {id: string;data: NonReadonly<PatchedReport>},
        TContext
      > => {

      const mutationOptions = getApiAnalyticsReportsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª Ú¯Ø²Ø§Ø±Ø´â€ŒÙ‡Ø§
 */
export const apiAnalyticsReportsDestroy = (
    id: string,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<null>(
      {url: `/api/analytics/reports/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getApiAnalyticsReportsDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsReportsDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsReportsDestroy>>, TError,{id: string}, TContext> => {

const mutationKey = ['apiAnalyticsReportsDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAnalyticsReportsDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  apiAnalyticsReportsDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAnalyticsReportsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsReportsDestroy>>>
    
    export type ApiAnalyticsReportsDestroyMutationError = unknown

    export const useApiAnalyticsReportsDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsReportsDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAnalyticsReportsDestroy>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getApiAnalyticsReportsDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Ø¯Ø§Ù†Ù„ÙˆØ¯ ÙØ§ÛŒÙ„ Ú¯Ø²Ø§Ø±Ø´
 */
export const apiAnalyticsReportsDownloadRetrieve = (
    id: string,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<Report>(
      {url: `/api/analytics/reports/${id}/download/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiAnalyticsReportsDownloadRetrieveQueryKey = (id?: string,) => {
    return [`/api/analytics/reports/${id}/download/`] as const;
    }

    
export const getApiAnalyticsReportsDownloadRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiAnalyticsReportsDownloadRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsReportsDownloadRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiAnalyticsReportsDownloadRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiAnalyticsReportsDownloadRetrieve>>> = ({ signal }) => apiAnalyticsReportsDownloadRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsReportsDownloadRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiAnalyticsReportsDownloadRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsReportsDownloadRetrieve>>>
export type ApiAnalyticsReportsDownloadRetrieveQueryError = unknown


export function useApiAnalyticsReportsDownloadRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsReportsDownloadRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsReportsDownloadRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsReportsDownloadRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsReportsDownloadRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsReportsDownloadRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsReportsDownloadRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsReportsDownloadRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsReportsDownloadRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsReportsDownloadRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsReportsDownloadRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsReportsDownloadRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsReportsDownloadRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiAnalyticsReportsDownloadRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsReportsDownloadRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsReportsDownloadRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiAnalyticsReportsDownloadRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Ø§Ø±Ø³Ø§Ù„ Ú¯Ø²Ø§Ø±Ø´ Ø§Ø² Ø·Ø±ÛŒÙ‚ Ø§ÛŒÙ…ÛŒÙ„
 */
export const apiAnalyticsReportsSendEmailCreate = (
    id: string,
    report: NonReadonly<Report>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<Report>(
      {url: `/api/analytics/reports/${id}/send_email/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: report, signal
    },
      options);
    }
  


export const getApiAnalyticsReportsSendEmailCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsReportsSendEmailCreate>>, TError,{id: string;data: NonReadonly<Report>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsReportsSendEmailCreate>>, TError,{id: string;data: NonReadonly<Report>}, TContext> => {

const mutationKey = ['apiAnalyticsReportsSendEmailCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAnalyticsReportsSendEmailCreate>>, {id: string;data: NonReadonly<Report>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiAnalyticsReportsSendEmailCreate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAnalyticsReportsSendEmailCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsReportsSendEmailCreate>>>
    export type ApiAnalyticsReportsSendEmailCreateMutationBody = NonReadonly<Report>
    export type ApiAnalyticsReportsSendEmailCreateMutationError = unknown

    export const useApiAnalyticsReportsSendEmailCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsReportsSendEmailCreate>>, TError,{id: string;data: NonReadonly<Report>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAnalyticsReportsSendEmailCreate>>,
        TError,
        {id: string;data: NonReadonly<Report>},
        TContext
      > => {

      const mutationOptions = getApiAnalyticsReportsSendEmailCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Ø¯Ø±ÛŒØ§ÙØª Ù‚Ø§Ù„Ø¨â€ŒÙ‡Ø§ÛŒ Ú¯Ø²Ø§Ø±Ø´
 */
export const apiAnalyticsReportsTemplatesRetrieve = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<Report>(
      {url: `/api/analytics/reports/templates/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiAnalyticsReportsTemplatesRetrieveQueryKey = () => {
    return [`/api/analytics/reports/templates/`] as const;
    }

    
export const getApiAnalyticsReportsTemplatesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiAnalyticsReportsTemplatesRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsReportsTemplatesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiAnalyticsReportsTemplatesRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiAnalyticsReportsTemplatesRetrieve>>> = ({ signal }) => apiAnalyticsReportsTemplatesRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsReportsTemplatesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiAnalyticsReportsTemplatesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsReportsTemplatesRetrieve>>>
export type ApiAnalyticsReportsTemplatesRetrieveQueryError = unknown


export function useApiAnalyticsReportsTemplatesRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsReportsTemplatesRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsReportsTemplatesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsReportsTemplatesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsReportsTemplatesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsReportsTemplatesRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsReportsTemplatesRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsReportsTemplatesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsReportsTemplatesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsReportsTemplatesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsReportsTemplatesRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsReportsTemplatesRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsReportsTemplatesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiAnalyticsReportsTemplatesRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsReportsTemplatesRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsReportsTemplatesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiAnalyticsReportsTemplatesRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØªÛŒÚ©Ø³ Ø³ÛŒØ³ØªÙ…
 */
export const apiAnalyticsSystemAnalyticsList = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<SystemAnalytics[]>(
      {url: `/api/analytics/system-analytics/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiAnalyticsSystemAnalyticsListQueryKey = () => {
    return [`/api/analytics/system-analytics/`] as const;
    }

    
export const getApiAnalyticsSystemAnalyticsListQueryOptions = <TData = Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiAnalyticsSystemAnalyticsListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsList>>> = ({ signal }) => apiAnalyticsSystemAnalyticsList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiAnalyticsSystemAnalyticsListQueryResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsList>>>
export type ApiAnalyticsSystemAnalyticsListQueryError = unknown


export function useApiAnalyticsSystemAnalyticsList<TData = Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsList>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsSystemAnalyticsList<TData = Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsList>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsSystemAnalyticsList<TData = Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiAnalyticsSystemAnalyticsList<TData = Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiAnalyticsSystemAnalyticsListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØªÛŒÚ©Ø³ Ø³ÛŒØ³ØªÙ…
 */
export const apiAnalyticsSystemAnalyticsCreate = (
    systemAnalytics: NonReadonly<SystemAnalytics>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<SystemAnalytics>(
      {url: `/api/analytics/system-analytics/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: systemAnalytics, signal
    },
      options);
    }
  


export const getApiAnalyticsSystemAnalyticsCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsCreate>>, TError,{data: NonReadonly<SystemAnalytics>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsCreate>>, TError,{data: NonReadonly<SystemAnalytics>}, TContext> => {

const mutationKey = ['apiAnalyticsSystemAnalyticsCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsCreate>>, {data: NonReadonly<SystemAnalytics>}> = (props) => {
          const {data} = props ?? {};

          return  apiAnalyticsSystemAnalyticsCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAnalyticsSystemAnalyticsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsCreate>>>
    export type ApiAnalyticsSystemAnalyticsCreateMutationBody = NonReadonly<SystemAnalytics>
    export type ApiAnalyticsSystemAnalyticsCreateMutationError = unknown

    export const useApiAnalyticsSystemAnalyticsCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsCreate>>, TError,{data: NonReadonly<SystemAnalytics>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsCreate>>,
        TError,
        {data: NonReadonly<SystemAnalytics>},
        TContext
      > => {

      const mutationOptions = getApiAnalyticsSystemAnalyticsCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØªÛŒÚ©Ø³ Ø³ÛŒØ³ØªÙ…
 */
export const apiAnalyticsSystemAnalyticsRetrieve = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<SystemAnalytics>(
      {url: `/api/analytics/system-analytics/${id}/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiAnalyticsSystemAnalyticsRetrieveQueryKey = (id?: number,) => {
    return [`/api/analytics/system-analytics/${id}/`] as const;
    }

    
export const getApiAnalyticsSystemAnalyticsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsRetrieve>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiAnalyticsSystemAnalyticsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsRetrieve>>> = ({ signal }) => apiAnalyticsSystemAnalyticsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiAnalyticsSystemAnalyticsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsRetrieve>>>
export type ApiAnalyticsSystemAnalyticsRetrieveQueryError = unknown


export function useApiAnalyticsSystemAnalyticsRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsRetrieve>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsSystemAnalyticsRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsSystemAnalyticsRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiAnalyticsSystemAnalyticsRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiAnalyticsSystemAnalyticsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØªÛŒÚ©Ø³ Ø³ÛŒØ³ØªÙ…
 */
export const apiAnalyticsSystemAnalyticsUpdate = (
    id: number,
    systemAnalytics: NonReadonly<SystemAnalytics>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<SystemAnalytics>(
      {url: `/api/analytics/system-analytics/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: systemAnalytics
    },
      options);
    }
  


export const getApiAnalyticsSystemAnalyticsUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsUpdate>>, TError,{id: number;data: NonReadonly<SystemAnalytics>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsUpdate>>, TError,{id: number;data: NonReadonly<SystemAnalytics>}, TContext> => {

const mutationKey = ['apiAnalyticsSystemAnalyticsUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsUpdate>>, {id: number;data: NonReadonly<SystemAnalytics>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiAnalyticsSystemAnalyticsUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAnalyticsSystemAnalyticsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsUpdate>>>
    export type ApiAnalyticsSystemAnalyticsUpdateMutationBody = NonReadonly<SystemAnalytics>
    export type ApiAnalyticsSystemAnalyticsUpdateMutationError = unknown

    export const useApiAnalyticsSystemAnalyticsUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsUpdate>>, TError,{id: number;data: NonReadonly<SystemAnalytics>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsUpdate>>,
        TError,
        {id: number;data: NonReadonly<SystemAnalytics>},
        TContext
      > => {

      const mutationOptions = getApiAnalyticsSystemAnalyticsUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØªÛŒÚ©Ø³ Ø³ÛŒØ³ØªÙ…
 */
export const apiAnalyticsSystemAnalyticsPartialUpdate = (
    id: number,
    patchedSystemAnalytics: NonReadonly<PatchedSystemAnalytics>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<SystemAnalytics>(
      {url: `/api/analytics/system-analytics/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedSystemAnalytics
    },
      options);
    }
  


export const getApiAnalyticsSystemAnalyticsPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedSystemAnalytics>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedSystemAnalytics>}, TContext> => {

const mutationKey = ['apiAnalyticsSystemAnalyticsPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsPartialUpdate>>, {id: number;data: NonReadonly<PatchedSystemAnalytics>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiAnalyticsSystemAnalyticsPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAnalyticsSystemAnalyticsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsPartialUpdate>>>
    export type ApiAnalyticsSystemAnalyticsPartialUpdateMutationBody = NonReadonly<PatchedSystemAnalytics>
    export type ApiAnalyticsSystemAnalyticsPartialUpdateMutationError = unknown

    export const useApiAnalyticsSystemAnalyticsPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedSystemAnalytics>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedSystemAnalytics>},
        TContext
      > => {

      const mutationOptions = getApiAnalyticsSystemAnalyticsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØªÛŒÚ©Ø³ Ø³ÛŒØ³ØªÙ…
 */
export const apiAnalyticsSystemAnalyticsDestroy = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<null>(
      {url: `/api/analytics/system-analytics/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getApiAnalyticsSystemAnalyticsDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['apiAnalyticsSystemAnalyticsDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  apiAnalyticsSystemAnalyticsDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAnalyticsSystemAnalyticsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsDestroy>>>
    
    export type ApiAnalyticsSystemAnalyticsDestroyMutationError = unknown

    export const useApiAnalyticsSystemAnalyticsDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getApiAnalyticsSystemAnalyticsDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¢Ù†Ø§Ù„ÛŒØªÛŒÚ©Ø³ Ø³ÛŒØ³ØªÙ…
 */
export const apiAnalyticsSystemAnalyticsCalculateCreate = (
    systemAnalytics: NonReadonly<SystemAnalytics>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<SystemAnalytics>(
      {url: `/api/analytics/system-analytics/calculate/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: systemAnalytics, signal
    },
      options);
    }
  


export const getApiAnalyticsSystemAnalyticsCalculateCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsCalculateCreate>>, TError,{data: NonReadonly<SystemAnalytics>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsCalculateCreate>>, TError,{data: NonReadonly<SystemAnalytics>}, TContext> => {

const mutationKey = ['apiAnalyticsSystemAnalyticsCalculateCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsCalculateCreate>>, {data: NonReadonly<SystemAnalytics>}> = (props) => {
          const {data} = props ?? {};

          return  apiAnalyticsSystemAnalyticsCalculateCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAnalyticsSystemAnalyticsCalculateCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsCalculateCreate>>>
    export type ApiAnalyticsSystemAnalyticsCalculateCreateMutationBody = NonReadonly<SystemAnalytics>
    export type ApiAnalyticsSystemAnalyticsCalculateCreateMutationError = unknown

    export const useApiAnalyticsSystemAnalyticsCalculateCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsCalculateCreate>>, TError,{data: NonReadonly<SystemAnalytics>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsCalculateCreate>>,
        TError,
        {data: NonReadonly<SystemAnalytics>},
        TContext
      > => {

      const mutationOptions = getApiAnalyticsSystemAnalyticsCalculateCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Ø¨Ø±Ø±Ø³ÛŒ Ø³Ù„Ø§Ù…Øª Ø³ÛŒØ³ØªÙ…
 */
export const apiAnalyticsSystemAnalyticsHealthCheckRetrieve = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<SystemAnalytics>(
      {url: `/api/analytics/system-analytics/health_check/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiAnalyticsSystemAnalyticsHealthCheckRetrieveQueryKey = () => {
    return [`/api/analytics/system-analytics/health_check/`] as const;
    }

    
export const getApiAnalyticsSystemAnalyticsHealthCheckRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsHealthCheckRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsHealthCheckRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiAnalyticsSystemAnalyticsHealthCheckRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsHealthCheckRetrieve>>> = ({ signal }) => apiAnalyticsSystemAnalyticsHealthCheckRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsHealthCheckRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiAnalyticsSystemAnalyticsHealthCheckRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsHealthCheckRetrieve>>>
export type ApiAnalyticsSystemAnalyticsHealthCheckRetrieveQueryError = unknown


export function useApiAnalyticsSystemAnalyticsHealthCheckRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsHealthCheckRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsHealthCheckRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsHealthCheckRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsHealthCheckRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsSystemAnalyticsHealthCheckRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsHealthCheckRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsHealthCheckRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsHealthCheckRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsHealthCheckRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsSystemAnalyticsHealthCheckRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsHealthCheckRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsHealthCheckRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiAnalyticsSystemAnalyticsHealthCheckRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsHealthCheckRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsHealthCheckRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiAnalyticsSystemAnalyticsHealthCheckRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Ø¯Ø±ÛŒØ§ÙØª Ù†Ù…Ø§ÛŒ Ú©Ù„ÛŒ Ø³ÛŒØ³ØªÙ…
 */
export const apiAnalyticsSystemAnalyticsOverviewRetrieve = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<SystemAnalytics>(
      {url: `/api/analytics/system-analytics/overview/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiAnalyticsSystemAnalyticsOverviewRetrieveQueryKey = () => {
    return [`/api/analytics/system-analytics/overview/`] as const;
    }

    
export const getApiAnalyticsSystemAnalyticsOverviewRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsOverviewRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsOverviewRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiAnalyticsSystemAnalyticsOverviewRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsOverviewRetrieve>>> = ({ signal }) => apiAnalyticsSystemAnalyticsOverviewRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsOverviewRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiAnalyticsSystemAnalyticsOverviewRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsOverviewRetrieve>>>
export type ApiAnalyticsSystemAnalyticsOverviewRetrieveQueryError = unknown


export function useApiAnalyticsSystemAnalyticsOverviewRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsOverviewRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsOverviewRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsOverviewRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsOverviewRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsSystemAnalyticsOverviewRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsOverviewRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsOverviewRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsOverviewRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsOverviewRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsSystemAnalyticsOverviewRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsOverviewRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsOverviewRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiAnalyticsSystemAnalyticsOverviewRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsOverviewRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsOverviewRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiAnalyticsSystemAnalyticsOverviewRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Ø¯Ø±ÛŒØ§ÙØª Ù†Ù…ÙˆØ¯Ø§Ø± Ø±ÙˆÙ†Ø¯
 */
export const apiAnalyticsSystemAnalyticsTrendChartRetrieve = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<SystemAnalytics>(
      {url: `/api/analytics/system-analytics/trend_chart/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiAnalyticsSystemAnalyticsTrendChartRetrieveQueryKey = () => {
    return [`/api/analytics/system-analytics/trend_chart/`] as const;
    }

    
export const getApiAnalyticsSystemAnalyticsTrendChartRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsTrendChartRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsTrendChartRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiAnalyticsSystemAnalyticsTrendChartRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsTrendChartRetrieve>>> = ({ signal }) => apiAnalyticsSystemAnalyticsTrendChartRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsTrendChartRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiAnalyticsSystemAnalyticsTrendChartRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsTrendChartRetrieve>>>
export type ApiAnalyticsSystemAnalyticsTrendChartRetrieveQueryError = unknown


export function useApiAnalyticsSystemAnalyticsTrendChartRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsTrendChartRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsTrendChartRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsTrendChartRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsTrendChartRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsSystemAnalyticsTrendChartRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsTrendChartRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsTrendChartRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsTrendChartRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsTrendChartRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnalyticsSystemAnalyticsTrendChartRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsTrendChartRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsTrendChartRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiAnalyticsSystemAnalyticsTrendChartRetrieve<TData = Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsTrendChartRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnalyticsSystemAnalyticsTrendChartRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiAnalyticsSystemAnalyticsTrendChartRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * List all detected anomalies with optional filtering
 * @summary List anomaly detections
 */
export const apiAnomalyDetectionsList = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<AnomalyDetection[]>(
      {url: `/api/anomaly-detections/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiAnomalyDetectionsListQueryKey = () => {
    return [`/api/anomaly-detections/`] as const;
    }

    
export const getApiAnomalyDetectionsListQueryOptions = <TData = Awaited<ReturnType<typeof apiAnomalyDetectionsList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnomalyDetectionsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiAnomalyDetectionsListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiAnomalyDetectionsList>>> = ({ signal }) => apiAnomalyDetectionsList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiAnomalyDetectionsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiAnomalyDetectionsListQueryResult = NonNullable<Awaited<ReturnType<typeof apiAnomalyDetectionsList>>>
export type ApiAnomalyDetectionsListQueryError = unknown


export function useApiAnomalyDetectionsList<TData = Awaited<ReturnType<typeof apiAnomalyDetectionsList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnomalyDetectionsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnomalyDetectionsList>>,
          TError,
          Awaited<ReturnType<typeof apiAnomalyDetectionsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnomalyDetectionsList<TData = Awaited<ReturnType<typeof apiAnomalyDetectionsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnomalyDetectionsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnomalyDetectionsList>>,
          TError,
          Awaited<ReturnType<typeof apiAnomalyDetectionsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnomalyDetectionsList<TData = Awaited<ReturnType<typeof apiAnomalyDetectionsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnomalyDetectionsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List anomaly detections
 */

export function useApiAnomalyDetectionsList<TData = Awaited<ReturnType<typeof apiAnomalyDetectionsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnomalyDetectionsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiAnomalyDetectionsListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve a specific anomaly detection by ID
 * @summary Get anomaly detection
 */
export const apiAnomalyDetectionsRetrieve = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<AnomalyDetection>(
      {url: `/api/anomaly-detections/${id}/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiAnomalyDetectionsRetrieveQueryKey = (id?: number,) => {
    return [`/api/anomaly-detections/${id}/`] as const;
    }

    
export const getApiAnomalyDetectionsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiAnomalyDetectionsRetrieve>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnomalyDetectionsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiAnomalyDetectionsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiAnomalyDetectionsRetrieve>>> = ({ signal }) => apiAnomalyDetectionsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiAnomalyDetectionsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiAnomalyDetectionsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiAnomalyDetectionsRetrieve>>>
export type ApiAnomalyDetectionsRetrieveQueryError = unknown


export function useApiAnomalyDetectionsRetrieve<TData = Awaited<ReturnType<typeof apiAnomalyDetectionsRetrieve>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnomalyDetectionsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnomalyDetectionsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAnomalyDetectionsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnomalyDetectionsRetrieve<TData = Awaited<ReturnType<typeof apiAnomalyDetectionsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnomalyDetectionsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiAnomalyDetectionsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiAnomalyDetectionsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAnomalyDetectionsRetrieve<TData = Awaited<ReturnType<typeof apiAnomalyDetectionsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnomalyDetectionsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get anomaly detection
 */

export function useApiAnomalyDetectionsRetrieve<TData = Awaited<ReturnType<typeof apiAnomalyDetectionsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiAnomalyDetectionsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiAnomalyDetectionsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Mark an anomaly as acknowledged by the current user
 * @summary Acknowledge anomaly
 */
export const apiAnomalyDetectionsAcknowledgeCreate = (
    id: number,
    anomalyDetection: NonReadonly<AnomalyDetection>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<AnomalyDetection>(
      {url: `/api/anomaly-detections/${id}/acknowledge/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: anomalyDetection, signal
    },
      options);
    }
  


export const getApiAnomalyDetectionsAcknowledgeCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnomalyDetectionsAcknowledgeCreate>>, TError,{id: number;data: NonReadonly<AnomalyDetection>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiAnomalyDetectionsAcknowledgeCreate>>, TError,{id: number;data: NonReadonly<AnomalyDetection>}, TContext> => {

const mutationKey = ['apiAnomalyDetectionsAcknowledgeCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAnomalyDetectionsAcknowledgeCreate>>, {id: number;data: NonReadonly<AnomalyDetection>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiAnomalyDetectionsAcknowledgeCreate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiAnomalyDetectionsAcknowledgeCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAnomalyDetectionsAcknowledgeCreate>>>
    export type ApiAnomalyDetectionsAcknowledgeCreateMutationBody = NonReadonly<AnomalyDetection>
    export type ApiAnomalyDetectionsAcknowledgeCreateMutationError = unknown

    /**
 * @summary Acknowledge anomaly
 */
export const useApiAnomalyDetectionsAcknowledgeCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiAnomalyDetectionsAcknowledgeCreate>>, TError,{id: number;data: NonReadonly<AnomalyDetection>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiAnomalyDetectionsAcknowledgeCreate>>,
        TError,
        {id: number;data: NonReadonly<AnomalyDetection>},
        TContext
      > => {

      const mutationOptions = getApiAnomalyDetectionsAcknowledgeCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Takes a set of user credentials and returns an access and refresh JSON web
token pair to prove the authentication of those credentials.
 */
export const apiApiTokenCreate = (
    tokenObtainPair: NonReadonly<TokenObtainPair>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<TokenObtainPair>(
      {url: `/api/api/token/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: tokenObtainPair, signal
    },
      options);
    }
  


export const getApiApiTokenCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiApiTokenCreate>>, TError,{data: NonReadonly<TokenObtainPair>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiApiTokenCreate>>, TError,{data: NonReadonly<TokenObtainPair>}, TContext> => {

const mutationKey = ['apiApiTokenCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiApiTokenCreate>>, {data: NonReadonly<TokenObtainPair>}> = (props) => {
          const {data} = props ?? {};

          return  apiApiTokenCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiApiTokenCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiApiTokenCreate>>>
    export type ApiApiTokenCreateMutationBody = NonReadonly<TokenObtainPair>
    export type ApiApiTokenCreateMutationError = unknown

    export const useApiApiTokenCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiApiTokenCreate>>, TError,{data: NonReadonly<TokenObtainPair>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiApiTokenCreate>>,
        TError,
        {data: NonReadonly<TokenObtainPair>},
        TContext
      > => {

      const mutationOptions = getApiApiTokenCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Takes a refresh type JSON web token and returns an access type JSON web
token if the refresh token is valid.
 */
export const apiApiTokenRefreshCreate = (
    tokenRefresh: NonReadonly<TokenRefresh>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<TokenRefresh>(
      {url: `/api/api/token/refresh/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: tokenRefresh, signal
    },
      options);
    }
  


export const getApiApiTokenRefreshCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiApiTokenRefreshCreate>>, TError,{data: NonReadonly<TokenRefresh>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiApiTokenRefreshCreate>>, TError,{data: NonReadonly<TokenRefresh>}, TContext> => {

const mutationKey = ['apiApiTokenRefreshCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiApiTokenRefreshCreate>>, {data: NonReadonly<TokenRefresh>}> = (props) => {
          const {data} = props ?? {};

          return  apiApiTokenRefreshCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiApiTokenRefreshCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiApiTokenRefreshCreate>>>
    export type ApiApiTokenRefreshCreateMutationBody = NonReadonly<TokenRefresh>
    export type ApiApiTokenRefreshCreateMutationError = unknown

    export const useApiApiTokenRefreshCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiApiTokenRefreshCreate>>, TError,{data: NonReadonly<TokenRefresh>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiApiTokenRefreshCreate>>,
        TError,
        {data: NonReadonly<TokenRefresh>},
        TContext
      > => {

      const mutationOptions = getApiApiTokenRefreshCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * List baseline metrics for patients
 * @summary List baseline metrics
 */
export const apiBaselineMetricsList = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<BaselineMetrics[]>(
      {url: `/api/baseline-metrics/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiBaselineMetricsListQueryKey = () => {
    return [`/api/baseline-metrics/`] as const;
    }

    
export const getApiBaselineMetricsListQueryOptions = <TData = Awaited<ReturnType<typeof apiBaselineMetricsList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBaselineMetricsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiBaselineMetricsListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiBaselineMetricsList>>> = ({ signal }) => apiBaselineMetricsList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiBaselineMetricsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiBaselineMetricsListQueryResult = NonNullable<Awaited<ReturnType<typeof apiBaselineMetricsList>>>
export type ApiBaselineMetricsListQueryError = unknown


export function useApiBaselineMetricsList<TData = Awaited<ReturnType<typeof apiBaselineMetricsList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBaselineMetricsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiBaselineMetricsList>>,
          TError,
          Awaited<ReturnType<typeof apiBaselineMetricsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiBaselineMetricsList<TData = Awaited<ReturnType<typeof apiBaselineMetricsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBaselineMetricsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiBaselineMetricsList>>,
          TError,
          Awaited<ReturnType<typeof apiBaselineMetricsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiBaselineMetricsList<TData = Awaited<ReturnType<typeof apiBaselineMetricsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBaselineMetricsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List baseline metrics
 */

export function useApiBaselineMetricsList<TData = Awaited<ReturnType<typeof apiBaselineMetricsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBaselineMetricsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiBaselineMetricsListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve baseline metrics for a specific patient
 * @summary Get baseline metrics
 */
export const apiBaselineMetricsRetrieve = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<BaselineMetrics>(
      {url: `/api/baseline-metrics/${id}/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiBaselineMetricsRetrieveQueryKey = (id?: number,) => {
    return [`/api/baseline-metrics/${id}/`] as const;
    }

    
export const getApiBaselineMetricsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiBaselineMetricsRetrieve>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBaselineMetricsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiBaselineMetricsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiBaselineMetricsRetrieve>>> = ({ signal }) => apiBaselineMetricsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiBaselineMetricsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiBaselineMetricsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiBaselineMetricsRetrieve>>>
export type ApiBaselineMetricsRetrieveQueryError = unknown


export function useApiBaselineMetricsRetrieve<TData = Awaited<ReturnType<typeof apiBaselineMetricsRetrieve>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBaselineMetricsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiBaselineMetricsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiBaselineMetricsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiBaselineMetricsRetrieve<TData = Awaited<ReturnType<typeof apiBaselineMetricsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBaselineMetricsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiBaselineMetricsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiBaselineMetricsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiBaselineMetricsRetrieve<TData = Awaited<ReturnType<typeof apiBaselineMetricsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBaselineMetricsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get baseline metrics
 */

export function useApiBaselineMetricsRetrieve<TData = Awaited<ReturnType<typeof apiBaselineMetricsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBaselineMetricsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiBaselineMetricsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Calculate or recalculate baseline metrics for a patient
 * @summary Calculate baseline metrics
 */
export const apiBaselineMetricsCalculateCreate = (
    baselineMetrics: NonReadonly<BaselineMetrics>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<BaselineMetrics>(
      {url: `/api/baseline-metrics/calculate/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: baselineMetrics, signal
    },
      options);
    }
  


export const getApiBaselineMetricsCalculateCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiBaselineMetricsCalculateCreate>>, TError,{data: NonReadonly<BaselineMetrics>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiBaselineMetricsCalculateCreate>>, TError,{data: NonReadonly<BaselineMetrics>}, TContext> => {

const mutationKey = ['apiBaselineMetricsCalculateCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiBaselineMetricsCalculateCreate>>, {data: NonReadonly<BaselineMetrics>}> = (props) => {
          const {data} = props ?? {};

          return  apiBaselineMetricsCalculateCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiBaselineMetricsCalculateCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiBaselineMetricsCalculateCreate>>>
    export type ApiBaselineMetricsCalculateCreateMutationBody = NonReadonly<BaselineMetrics>
    export type ApiBaselineMetricsCalculateCreateMutationError = unknown

    /**
 * @summary Calculate baseline metrics
 */
export const useApiBaselineMetricsCalculateCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiBaselineMetricsCalculateCreate>>, TError,{data: NonReadonly<BaselineMetrics>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiBaselineMetricsCalculateCreate>>,
        TError,
        {data: NonReadonly<BaselineMetrics>},
        TContext
      > => {

      const mutationOptions = getApiBaselineMetricsCalculateCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Scope queryset to records owned by current doctor via patient.primary_doctor.

Assumes model has a FK field named `patient` pointing to an object with
`primary_doctor` attribute. Superusers are exempt.
 */
export const apiEncountersList = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<Encounter[]>(
      {url: `/api/encounters/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiEncountersListQueryKey = () => {
    return [`/api/encounters/`] as const;
    }

    
export const getApiEncountersListQueryOptions = <TData = Awaited<ReturnType<typeof apiEncountersList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiEncountersList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiEncountersListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiEncountersList>>> = ({ signal }) => apiEncountersList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiEncountersList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiEncountersListQueryResult = NonNullable<Awaited<ReturnType<typeof apiEncountersList>>>
export type ApiEncountersListQueryError = unknown


export function useApiEncountersList<TData = Awaited<ReturnType<typeof apiEncountersList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiEncountersList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiEncountersList>>,
          TError,
          Awaited<ReturnType<typeof apiEncountersList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiEncountersList<TData = Awaited<ReturnType<typeof apiEncountersList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiEncountersList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiEncountersList>>,
          TError,
          Awaited<ReturnType<typeof apiEncountersList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiEncountersList<TData = Awaited<ReturnType<typeof apiEncountersList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiEncountersList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiEncountersList<TData = Awaited<ReturnType<typeof apiEncountersList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiEncountersList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiEncountersListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Scope queryset to records owned by current doctor via patient.primary_doctor.

Assumes model has a FK field named `patient` pointing to an object with
`primary_doctor` attribute. Superusers are exempt.
 */
export const apiEncountersCreate = (
    encounter: NonReadonly<Encounter>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<Encounter>(
      {url: `/api/encounters/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: encounter, signal
    },
      options);
    }
  


export const getApiEncountersCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiEncountersCreate>>, TError,{data: NonReadonly<Encounter>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiEncountersCreate>>, TError,{data: NonReadonly<Encounter>}, TContext> => {

const mutationKey = ['apiEncountersCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiEncountersCreate>>, {data: NonReadonly<Encounter>}> = (props) => {
          const {data} = props ?? {};

          return  apiEncountersCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiEncountersCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiEncountersCreate>>>
    export type ApiEncountersCreateMutationBody = NonReadonly<Encounter>
    export type ApiEncountersCreateMutationError = unknown

    export const useApiEncountersCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiEncountersCreate>>, TError,{data: NonReadonly<Encounter>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiEncountersCreate>>,
        TError,
        {data: NonReadonly<Encounter>},
        TContext
      > => {

      const mutationOptions = getApiEncountersCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Scope queryset to records owned by current doctor via patient.primary_doctor.

Assumes model has a FK field named `patient` pointing to an object with
`primary_doctor` attribute. Superusers are exempt.
 */
export const apiEncountersRetrieve = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<Encounter>(
      {url: `/api/encounters/${id}/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiEncountersRetrieveQueryKey = (id?: number,) => {
    return [`/api/encounters/${id}/`] as const;
    }

    
export const getApiEncountersRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiEncountersRetrieve>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiEncountersRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiEncountersRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiEncountersRetrieve>>> = ({ signal }) => apiEncountersRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiEncountersRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiEncountersRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiEncountersRetrieve>>>
export type ApiEncountersRetrieveQueryError = unknown


export function useApiEncountersRetrieve<TData = Awaited<ReturnType<typeof apiEncountersRetrieve>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiEncountersRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiEncountersRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiEncountersRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiEncountersRetrieve<TData = Awaited<ReturnType<typeof apiEncountersRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiEncountersRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiEncountersRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiEncountersRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiEncountersRetrieve<TData = Awaited<ReturnType<typeof apiEncountersRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiEncountersRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiEncountersRetrieve<TData = Awaited<ReturnType<typeof apiEncountersRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiEncountersRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiEncountersRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Scope queryset to records owned by current doctor via patient.primary_doctor.

Assumes model has a FK field named `patient` pointing to an object with
`primary_doctor` attribute. Superusers are exempt.
 */
export const apiEncountersUpdate = (
    id: number,
    encounter: NonReadonly<Encounter>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<Encounter>(
      {url: `/api/encounters/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: encounter
    },
      options);
    }
  


export const getApiEncountersUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiEncountersUpdate>>, TError,{id: number;data: NonReadonly<Encounter>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiEncountersUpdate>>, TError,{id: number;data: NonReadonly<Encounter>}, TContext> => {

const mutationKey = ['apiEncountersUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiEncountersUpdate>>, {id: number;data: NonReadonly<Encounter>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiEncountersUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiEncountersUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiEncountersUpdate>>>
    export type ApiEncountersUpdateMutationBody = NonReadonly<Encounter>
    export type ApiEncountersUpdateMutationError = unknown

    export const useApiEncountersUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiEncountersUpdate>>, TError,{id: number;data: NonReadonly<Encounter>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiEncountersUpdate>>,
        TError,
        {id: number;data: NonReadonly<Encounter>},
        TContext
      > => {

      const mutationOptions = getApiEncountersUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Scope queryset to records owned by current doctor via patient.primary_doctor.

Assumes model has a FK field named `patient` pointing to an object with
`primary_doctor` attribute. Superusers are exempt.
 */
export const apiEncountersPartialUpdate = (
    id: number,
    patchedEncounter: NonReadonly<PatchedEncounter>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<Encounter>(
      {url: `/api/encounters/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedEncounter
    },
      options);
    }
  


export const getApiEncountersPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiEncountersPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedEncounter>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiEncountersPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedEncounter>}, TContext> => {

const mutationKey = ['apiEncountersPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiEncountersPartialUpdate>>, {id: number;data: NonReadonly<PatchedEncounter>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiEncountersPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiEncountersPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiEncountersPartialUpdate>>>
    export type ApiEncountersPartialUpdateMutationBody = NonReadonly<PatchedEncounter>
    export type ApiEncountersPartialUpdateMutationError = unknown

    export const useApiEncountersPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiEncountersPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedEncounter>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiEncountersPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedEncounter>},
        TContext
      > => {

      const mutationOptions = getApiEncountersPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Scope queryset to records owned by current doctor via patient.primary_doctor.

Assumes model has a FK field named `patient` pointing to an object with
`primary_doctor` attribute. Superusers are exempt.
 */
export const apiEncountersDestroy = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<null>(
      {url: `/api/encounters/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getApiEncountersDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiEncountersDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiEncountersDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['apiEncountersDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiEncountersDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  apiEncountersDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiEncountersDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof apiEncountersDestroy>>>
    
    export type ApiEncountersDestroyMutationError = unknown

    export const useApiEncountersDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiEncountersDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiEncountersDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getApiEncountersDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const apiExportPatientRetrieve = (
    id: string,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<null>(
      {url: `/api/export/patient/${id}/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiExportPatientRetrieveQueryKey = (id?: string,) => {
    return [`/api/export/patient/${id}/`] as const;
    }

    
export const getApiExportPatientRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiExportPatientRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiExportPatientRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiExportPatientRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiExportPatientRetrieve>>> = ({ signal }) => apiExportPatientRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiExportPatientRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiExportPatientRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiExportPatientRetrieve>>>
export type ApiExportPatientRetrieveQueryError = unknown


export function useApiExportPatientRetrieve<TData = Awaited<ReturnType<typeof apiExportPatientRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiExportPatientRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiExportPatientRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiExportPatientRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiExportPatientRetrieve<TData = Awaited<ReturnType<typeof apiExportPatientRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiExportPatientRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiExportPatientRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiExportPatientRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiExportPatientRetrieve<TData = Awaited<ReturnType<typeof apiExportPatientRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiExportPatientRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiExportPatientRetrieve<TData = Awaited<ReturnType<typeof apiExportPatientRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiExportPatientRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiExportPatientRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Scope queryset to records owned by current doctor via patient.primary_doctor.

Assumes model has a FK field named `patient` pointing to an object with
`primary_doctor` attribute. Superusers are exempt.
 */
export const apiLabsList = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<LabResult[]>(
      {url: `/api/labs/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiLabsListQueryKey = () => {
    return [`/api/labs/`] as const;
    }

    
export const getApiLabsListQueryOptions = <TData = Awaited<ReturnType<typeof apiLabsList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiLabsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiLabsListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiLabsList>>> = ({ signal }) => apiLabsList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiLabsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiLabsListQueryResult = NonNullable<Awaited<ReturnType<typeof apiLabsList>>>
export type ApiLabsListQueryError = unknown


export function useApiLabsList<TData = Awaited<ReturnType<typeof apiLabsList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiLabsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiLabsList>>,
          TError,
          Awaited<ReturnType<typeof apiLabsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiLabsList<TData = Awaited<ReturnType<typeof apiLabsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiLabsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiLabsList>>,
          TError,
          Awaited<ReturnType<typeof apiLabsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiLabsList<TData = Awaited<ReturnType<typeof apiLabsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiLabsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiLabsList<TData = Awaited<ReturnType<typeof apiLabsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiLabsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiLabsListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Scope queryset to records owned by current doctor via patient.primary_doctor.

Assumes model has a FK field named `patient` pointing to an object with
`primary_doctor` attribute. Superusers are exempt.
 */
export const apiLabsCreate = (
    labResult: NonReadonly<LabResult>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<LabResult>(
      {url: `/api/labs/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: labResult, signal
    },
      options);
    }
  


export const getApiLabsCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiLabsCreate>>, TError,{data: NonReadonly<LabResult>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiLabsCreate>>, TError,{data: NonReadonly<LabResult>}, TContext> => {

const mutationKey = ['apiLabsCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiLabsCreate>>, {data: NonReadonly<LabResult>}> = (props) => {
          const {data} = props ?? {};

          return  apiLabsCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiLabsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiLabsCreate>>>
    export type ApiLabsCreateMutationBody = NonReadonly<LabResult>
    export type ApiLabsCreateMutationError = unknown

    export const useApiLabsCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiLabsCreate>>, TError,{data: NonReadonly<LabResult>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiLabsCreate>>,
        TError,
        {data: NonReadonly<LabResult>},
        TContext
      > => {

      const mutationOptions = getApiLabsCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Scope queryset to records owned by current doctor via patient.primary_doctor.

Assumes model has a FK field named `patient` pointing to an object with
`primary_doctor` attribute. Superusers are exempt.
 */
export const apiLabsRetrieve = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<LabResult>(
      {url: `/api/labs/${id}/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiLabsRetrieveQueryKey = (id?: number,) => {
    return [`/api/labs/${id}/`] as const;
    }

    
export const getApiLabsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiLabsRetrieve>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiLabsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiLabsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiLabsRetrieve>>> = ({ signal }) => apiLabsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiLabsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiLabsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiLabsRetrieve>>>
export type ApiLabsRetrieveQueryError = unknown


export function useApiLabsRetrieve<TData = Awaited<ReturnType<typeof apiLabsRetrieve>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiLabsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiLabsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiLabsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiLabsRetrieve<TData = Awaited<ReturnType<typeof apiLabsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiLabsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiLabsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiLabsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiLabsRetrieve<TData = Awaited<ReturnType<typeof apiLabsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiLabsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiLabsRetrieve<TData = Awaited<ReturnType<typeof apiLabsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiLabsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiLabsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Scope queryset to records owned by current doctor via patient.primary_doctor.

Assumes model has a FK field named `patient` pointing to an object with
`primary_doctor` attribute. Superusers are exempt.
 */
export const apiLabsUpdate = (
    id: number,
    labResult: NonReadonly<LabResult>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<LabResult>(
      {url: `/api/labs/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: labResult
    },
      options);
    }
  


export const getApiLabsUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiLabsUpdate>>, TError,{id: number;data: NonReadonly<LabResult>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiLabsUpdate>>, TError,{id: number;data: NonReadonly<LabResult>}, TContext> => {

const mutationKey = ['apiLabsUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiLabsUpdate>>, {id: number;data: NonReadonly<LabResult>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiLabsUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiLabsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiLabsUpdate>>>
    export type ApiLabsUpdateMutationBody = NonReadonly<LabResult>
    export type ApiLabsUpdateMutationError = unknown

    export const useApiLabsUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiLabsUpdate>>, TError,{id: number;data: NonReadonly<LabResult>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiLabsUpdate>>,
        TError,
        {id: number;data: NonReadonly<LabResult>},
        TContext
      > => {

      const mutationOptions = getApiLabsUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Scope queryset to records owned by current doctor via patient.primary_doctor.

Assumes model has a FK field named `patient` pointing to an object with
`primary_doctor` attribute. Superusers are exempt.
 */
export const apiLabsPartialUpdate = (
    id: number,
    patchedLabResult: NonReadonly<PatchedLabResult>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<LabResult>(
      {url: `/api/labs/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedLabResult
    },
      options);
    }
  


export const getApiLabsPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiLabsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedLabResult>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiLabsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedLabResult>}, TContext> => {

const mutationKey = ['apiLabsPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiLabsPartialUpdate>>, {id: number;data: NonReadonly<PatchedLabResult>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiLabsPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiLabsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiLabsPartialUpdate>>>
    export type ApiLabsPartialUpdateMutationBody = NonReadonly<PatchedLabResult>
    export type ApiLabsPartialUpdateMutationError = unknown

    export const useApiLabsPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiLabsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedLabResult>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiLabsPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedLabResult>},
        TContext
      > => {

      const mutationOptions = getApiLabsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Scope queryset to records owned by current doctor via patient.primary_doctor.

Assumes model has a FK field named `patient` pointing to an object with
`primary_doctor` attribute. Superusers are exempt.
 */
export const apiLabsDestroy = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<null>(
      {url: `/api/labs/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getApiLabsDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiLabsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiLabsDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['apiLabsDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiLabsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  apiLabsDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiLabsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof apiLabsDestroy>>>
    
    export type ApiLabsDestroyMutationError = unknown

    export const useApiLabsDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiLabsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiLabsDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getApiLabsDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Scope queryset to records owned by current doctor via patient.primary_doctor.

Assumes model has a FK field named `patient` pointing to an object with
`primary_doctor` attribute. Superusers are exempt.
 */
export const apiMedsList = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<MedicationOrder[]>(
      {url: `/api/meds/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiMedsListQueryKey = () => {
    return [`/api/meds/`] as const;
    }

    
export const getApiMedsListQueryOptions = <TData = Awaited<ReturnType<typeof apiMedsList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMedsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiMedsListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiMedsList>>> = ({ signal }) => apiMedsList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiMedsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiMedsListQueryResult = NonNullable<Awaited<ReturnType<typeof apiMedsList>>>
export type ApiMedsListQueryError = unknown


export function useApiMedsList<TData = Awaited<ReturnType<typeof apiMedsList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMedsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiMedsList>>,
          TError,
          Awaited<ReturnType<typeof apiMedsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiMedsList<TData = Awaited<ReturnType<typeof apiMedsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMedsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiMedsList>>,
          TError,
          Awaited<ReturnType<typeof apiMedsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiMedsList<TData = Awaited<ReturnType<typeof apiMedsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMedsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiMedsList<TData = Awaited<ReturnType<typeof apiMedsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMedsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiMedsListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Scope queryset to records owned by current doctor via patient.primary_doctor.

Assumes model has a FK field named `patient` pointing to an object with
`primary_doctor` attribute. Superusers are exempt.
 */
export const apiMedsCreate = (
    medicationOrder: NonReadonly<MedicationOrder>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<MedicationOrder>(
      {url: `/api/meds/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: medicationOrder, signal
    },
      options);
    }
  


export const getApiMedsCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiMedsCreate>>, TError,{data: NonReadonly<MedicationOrder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiMedsCreate>>, TError,{data: NonReadonly<MedicationOrder>}, TContext> => {

const mutationKey = ['apiMedsCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiMedsCreate>>, {data: NonReadonly<MedicationOrder>}> = (props) => {
          const {data} = props ?? {};

          return  apiMedsCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiMedsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiMedsCreate>>>
    export type ApiMedsCreateMutationBody = NonReadonly<MedicationOrder>
    export type ApiMedsCreateMutationError = unknown

    export const useApiMedsCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiMedsCreate>>, TError,{data: NonReadonly<MedicationOrder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiMedsCreate>>,
        TError,
        {data: NonReadonly<MedicationOrder>},
        TContext
      > => {

      const mutationOptions = getApiMedsCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Scope queryset to records owned by current doctor via patient.primary_doctor.

Assumes model has a FK field named `patient` pointing to an object with
`primary_doctor` attribute. Superusers are exempt.
 */
export const apiMedsRetrieve = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<MedicationOrder>(
      {url: `/api/meds/${id}/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiMedsRetrieveQueryKey = (id?: number,) => {
    return [`/api/meds/${id}/`] as const;
    }

    
export const getApiMedsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiMedsRetrieve>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMedsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiMedsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiMedsRetrieve>>> = ({ signal }) => apiMedsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiMedsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiMedsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiMedsRetrieve>>>
export type ApiMedsRetrieveQueryError = unknown


export function useApiMedsRetrieve<TData = Awaited<ReturnType<typeof apiMedsRetrieve>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMedsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiMedsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiMedsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiMedsRetrieve<TData = Awaited<ReturnType<typeof apiMedsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMedsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiMedsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiMedsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiMedsRetrieve<TData = Awaited<ReturnType<typeof apiMedsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMedsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiMedsRetrieve<TData = Awaited<ReturnType<typeof apiMedsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMedsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiMedsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Scope queryset to records owned by current doctor via patient.primary_doctor.

Assumes model has a FK field named `patient` pointing to an object with
`primary_doctor` attribute. Superusers are exempt.
 */
export const apiMedsUpdate = (
    id: number,
    medicationOrder: NonReadonly<MedicationOrder>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<MedicationOrder>(
      {url: `/api/meds/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: medicationOrder
    },
      options);
    }
  


export const getApiMedsUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiMedsUpdate>>, TError,{id: number;data: NonReadonly<MedicationOrder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiMedsUpdate>>, TError,{id: number;data: NonReadonly<MedicationOrder>}, TContext> => {

const mutationKey = ['apiMedsUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiMedsUpdate>>, {id: number;data: NonReadonly<MedicationOrder>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiMedsUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiMedsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiMedsUpdate>>>
    export type ApiMedsUpdateMutationBody = NonReadonly<MedicationOrder>
    export type ApiMedsUpdateMutationError = unknown

    export const useApiMedsUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiMedsUpdate>>, TError,{id: number;data: NonReadonly<MedicationOrder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiMedsUpdate>>,
        TError,
        {id: number;data: NonReadonly<MedicationOrder>},
        TContext
      > => {

      const mutationOptions = getApiMedsUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Scope queryset to records owned by current doctor via patient.primary_doctor.

Assumes model has a FK field named `patient` pointing to an object with
`primary_doctor` attribute. Superusers are exempt.
 */
export const apiMedsPartialUpdate = (
    id: number,
    patchedMedicationOrder: NonReadonly<PatchedMedicationOrder>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<MedicationOrder>(
      {url: `/api/meds/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedMedicationOrder
    },
      options);
    }
  


export const getApiMedsPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiMedsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedMedicationOrder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiMedsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedMedicationOrder>}, TContext> => {

const mutationKey = ['apiMedsPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiMedsPartialUpdate>>, {id: number;data: NonReadonly<PatchedMedicationOrder>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiMedsPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiMedsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiMedsPartialUpdate>>>
    export type ApiMedsPartialUpdateMutationBody = NonReadonly<PatchedMedicationOrder>
    export type ApiMedsPartialUpdateMutationError = unknown

    export const useApiMedsPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiMedsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedMedicationOrder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiMedsPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedMedicationOrder>},
        TContext
      > => {

      const mutationOptions = getApiMedsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Scope queryset to records owned by current doctor via patient.primary_doctor.

Assumes model has a FK field named `patient` pointing to an object with
`primary_doctor` attribute. Superusers are exempt.
 */
export const apiMedsDestroy = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<null>(
      {url: `/api/meds/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getApiMedsDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiMedsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiMedsDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['apiMedsDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiMedsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  apiMedsDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiMedsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof apiMedsDestroy>>>
    
    export type ApiMedsDestroyMutationError = unknown

    export const useApiMedsDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiMedsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiMedsDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getApiMedsDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒâ€ŒÙ‡Ø§
 */
export const apiNotificationsList = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<Notification[]>(
      {url: `/api/notifications/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiNotificationsListQueryKey = () => {
    return [`/api/notifications/`] as const;
    }

    
export const getApiNotificationsListQueryOptions = <TData = Awaited<ReturnType<typeof apiNotificationsList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiNotificationsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiNotificationsListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiNotificationsList>>> = ({ signal }) => apiNotificationsList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiNotificationsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiNotificationsListQueryResult = NonNullable<Awaited<ReturnType<typeof apiNotificationsList>>>
export type ApiNotificationsListQueryError = unknown


export function useApiNotificationsList<TData = Awaited<ReturnType<typeof apiNotificationsList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiNotificationsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiNotificationsList>>,
          TError,
          Awaited<ReturnType<typeof apiNotificationsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiNotificationsList<TData = Awaited<ReturnType<typeof apiNotificationsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiNotificationsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiNotificationsList>>,
          TError,
          Awaited<ReturnType<typeof apiNotificationsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiNotificationsList<TData = Awaited<ReturnType<typeof apiNotificationsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiNotificationsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiNotificationsList<TData = Awaited<ReturnType<typeof apiNotificationsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiNotificationsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiNotificationsListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒâ€ŒÙ‡Ø§
 */
export const apiNotificationsRetrieve = (
    id: string,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<Notification>(
      {url: `/api/notifications/${id}/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiNotificationsRetrieveQueryKey = (id?: string,) => {
    return [`/api/notifications/${id}/`] as const;
    }

    
export const getApiNotificationsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiNotificationsRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiNotificationsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiNotificationsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiNotificationsRetrieve>>> = ({ signal }) => apiNotificationsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiNotificationsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiNotificationsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiNotificationsRetrieve>>>
export type ApiNotificationsRetrieveQueryError = unknown


export function useApiNotificationsRetrieve<TData = Awaited<ReturnType<typeof apiNotificationsRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiNotificationsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiNotificationsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiNotificationsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiNotificationsRetrieve<TData = Awaited<ReturnType<typeof apiNotificationsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiNotificationsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiNotificationsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiNotificationsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiNotificationsRetrieve<TData = Awaited<ReturnType<typeof apiNotificationsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiNotificationsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiNotificationsRetrieve<TData = Awaited<ReturnType<typeof apiNotificationsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiNotificationsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiNotificationsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Ø¹Ù„Ø§Ù…Øªâ€ŒÚ¯Ø°Ø§Ø±ÛŒ Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† Ø®ÙˆØ§Ù†Ø¯Ù‡ Ø´Ø¯Ù‡
 */
export const apiNotificationsMarkReadCreate = (
    id: string,
    notification: NonReadonly<Notification>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<Notification>(
      {url: `/api/notifications/${id}/mark_read/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: notification, signal
    },
      options);
    }
  


export const getApiNotificationsMarkReadCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiNotificationsMarkReadCreate>>, TError,{id: string;data: NonReadonly<Notification>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiNotificationsMarkReadCreate>>, TError,{id: string;data: NonReadonly<Notification>}, TContext> => {

const mutationKey = ['apiNotificationsMarkReadCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiNotificationsMarkReadCreate>>, {id: string;data: NonReadonly<Notification>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiNotificationsMarkReadCreate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiNotificationsMarkReadCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiNotificationsMarkReadCreate>>>
    export type ApiNotificationsMarkReadCreateMutationBody = NonReadonly<Notification>
    export type ApiNotificationsMarkReadCreateMutationError = unknown

    export const useApiNotificationsMarkReadCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiNotificationsMarkReadCreate>>, TError,{id: string;data: NonReadonly<Notification>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiNotificationsMarkReadCreate>>,
        TError,
        {id: string;data: NonReadonly<Notification>},
        TContext
      > => {

      const mutationOptions = getApiNotificationsMarkReadCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Ø¹Ù„Ø§Ù…Øªâ€ŒÚ¯Ø°Ø§Ø±ÛŒ Ù‡Ù…Ù‡ Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† Ø®ÙˆØ§Ù†Ø¯Ù‡ Ø´Ø¯Ù‡
 */
export const apiNotificationsMarkAllReadCreate = (
    notification: NonReadonly<Notification>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<Notification>(
      {url: `/api/notifications/mark_all_read/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: notification, signal
    },
      options);
    }
  


export const getApiNotificationsMarkAllReadCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiNotificationsMarkAllReadCreate>>, TError,{data: NonReadonly<Notification>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiNotificationsMarkAllReadCreate>>, TError,{data: NonReadonly<Notification>}, TContext> => {

const mutationKey = ['apiNotificationsMarkAllReadCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiNotificationsMarkAllReadCreate>>, {data: NonReadonly<Notification>}> = (props) => {
          const {data} = props ?? {};

          return  apiNotificationsMarkAllReadCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiNotificationsMarkAllReadCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiNotificationsMarkAllReadCreate>>>
    export type ApiNotificationsMarkAllReadCreateMutationBody = NonReadonly<Notification>
    export type ApiNotificationsMarkAllReadCreateMutationError = unknown

    export const useApiNotificationsMarkAllReadCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiNotificationsMarkAllReadCreate>>, TError,{data: NonReadonly<Notification>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiNotificationsMarkAllReadCreate>>,
        TError,
        {data: NonReadonly<Notification>},
        TContext
      > => {

      const mutationOptions = getApiNotificationsMarkAllReadCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ØªØ¹Ø¯Ø§Ø¯ Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒâ€ŒÙ‡Ø§ÛŒ Ø®ÙˆØ§Ù†Ø¯Ù‡ Ù†Ø´Ø¯Ù‡
 */
export const apiNotificationsUnreadCountRetrieve = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<Notification>(
      {url: `/api/notifications/unread_count/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiNotificationsUnreadCountRetrieveQueryKey = () => {
    return [`/api/notifications/unread_count/`] as const;
    }

    
export const getApiNotificationsUnreadCountRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiNotificationsUnreadCountRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiNotificationsUnreadCountRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiNotificationsUnreadCountRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiNotificationsUnreadCountRetrieve>>> = ({ signal }) => apiNotificationsUnreadCountRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiNotificationsUnreadCountRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiNotificationsUnreadCountRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiNotificationsUnreadCountRetrieve>>>
export type ApiNotificationsUnreadCountRetrieveQueryError = unknown


export function useApiNotificationsUnreadCountRetrieve<TData = Awaited<ReturnType<typeof apiNotificationsUnreadCountRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiNotificationsUnreadCountRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiNotificationsUnreadCountRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiNotificationsUnreadCountRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiNotificationsUnreadCountRetrieve<TData = Awaited<ReturnType<typeof apiNotificationsUnreadCountRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiNotificationsUnreadCountRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiNotificationsUnreadCountRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiNotificationsUnreadCountRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiNotificationsUnreadCountRetrieve<TData = Awaited<ReturnType<typeof apiNotificationsUnreadCountRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiNotificationsUnreadCountRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiNotificationsUnreadCountRetrieve<TData = Awaited<ReturnType<typeof apiNotificationsUnreadCountRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiNotificationsUnreadCountRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiNotificationsUnreadCountRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const apiPatientsList = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<Patient[]>(
      {url: `/api/patients/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiPatientsListQueryKey = () => {
    return [`/api/patients/`] as const;
    }

    
export const getApiPatientsListQueryOptions = <TData = Awaited<ReturnType<typeof apiPatientsList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatientsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiPatientsListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiPatientsList>>> = ({ signal }) => apiPatientsList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiPatientsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiPatientsListQueryResult = NonNullable<Awaited<ReturnType<typeof apiPatientsList>>>
export type ApiPatientsListQueryError = unknown


export function useApiPatientsList<TData = Awaited<ReturnType<typeof apiPatientsList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatientsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiPatientsList>>,
          TError,
          Awaited<ReturnType<typeof apiPatientsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiPatientsList<TData = Awaited<ReturnType<typeof apiPatientsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatientsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiPatientsList>>,
          TError,
          Awaited<ReturnType<typeof apiPatientsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiPatientsList<TData = Awaited<ReturnType<typeof apiPatientsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatientsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiPatientsList<TData = Awaited<ReturnType<typeof apiPatientsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatientsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiPatientsListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const apiPatientsCreate = (
    patient: NonReadonly<Patient>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<Patient>(
      {url: `/api/patients/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: patient, signal
    },
      options);
    }
  


export const getApiPatientsCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiPatientsCreate>>, TError,{data: NonReadonly<Patient>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiPatientsCreate>>, TError,{data: NonReadonly<Patient>}, TContext> => {

const mutationKey = ['apiPatientsCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiPatientsCreate>>, {data: NonReadonly<Patient>}> = (props) => {
          const {data} = props ?? {};

          return  apiPatientsCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiPatientsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiPatientsCreate>>>
    export type ApiPatientsCreateMutationBody = NonReadonly<Patient>
    export type ApiPatientsCreateMutationError = unknown

    export const useApiPatientsCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiPatientsCreate>>, TError,{data: NonReadonly<Patient>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiPatientsCreate>>,
        TError,
        {data: NonReadonly<Patient>},
        TContext
      > => {

      const mutationOptions = getApiPatientsCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const apiPatientsRetrieve = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<Patient>(
      {url: `/api/patients/${id}/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiPatientsRetrieveQueryKey = (id?: number,) => {
    return [`/api/patients/${id}/`] as const;
    }

    
export const getApiPatientsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiPatientsRetrieve>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatientsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiPatientsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiPatientsRetrieve>>> = ({ signal }) => apiPatientsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiPatientsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiPatientsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiPatientsRetrieve>>>
export type ApiPatientsRetrieveQueryError = unknown


export function useApiPatientsRetrieve<TData = Awaited<ReturnType<typeof apiPatientsRetrieve>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatientsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiPatientsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiPatientsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiPatientsRetrieve<TData = Awaited<ReturnType<typeof apiPatientsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatientsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiPatientsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiPatientsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiPatientsRetrieve<TData = Awaited<ReturnType<typeof apiPatientsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatientsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiPatientsRetrieve<TData = Awaited<ReturnType<typeof apiPatientsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatientsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiPatientsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const apiPatientsUpdate = (
    id: number,
    patient: NonReadonly<Patient>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<Patient>(
      {url: `/api/patients/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: patient
    },
      options);
    }
  


export const getApiPatientsUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiPatientsUpdate>>, TError,{id: number;data: NonReadonly<Patient>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiPatientsUpdate>>, TError,{id: number;data: NonReadonly<Patient>}, TContext> => {

const mutationKey = ['apiPatientsUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiPatientsUpdate>>, {id: number;data: NonReadonly<Patient>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiPatientsUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiPatientsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiPatientsUpdate>>>
    export type ApiPatientsUpdateMutationBody = NonReadonly<Patient>
    export type ApiPatientsUpdateMutationError = unknown

    export const useApiPatientsUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiPatientsUpdate>>, TError,{id: number;data: NonReadonly<Patient>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiPatientsUpdate>>,
        TError,
        {id: number;data: NonReadonly<Patient>},
        TContext
      > => {

      const mutationOptions = getApiPatientsUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const apiPatientsPartialUpdate = (
    id: number,
    patchedPatient: NonReadonly<PatchedPatient>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<Patient>(
      {url: `/api/patients/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedPatient
    },
      options);
    }
  


export const getApiPatientsPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiPatientsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedPatient>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiPatientsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedPatient>}, TContext> => {

const mutationKey = ['apiPatientsPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiPatientsPartialUpdate>>, {id: number;data: NonReadonly<PatchedPatient>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiPatientsPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiPatientsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiPatientsPartialUpdate>>>
    export type ApiPatientsPartialUpdateMutationBody = NonReadonly<PatchedPatient>
    export type ApiPatientsPartialUpdateMutationError = unknown

    export const useApiPatientsPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiPatientsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedPatient>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiPatientsPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedPatient>},
        TContext
      > => {

      const mutationOptions = getApiPatientsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const apiPatientsDestroy = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<null>(
      {url: `/api/patients/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getApiPatientsDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiPatientsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiPatientsDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['apiPatientsDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiPatientsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  apiPatientsDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiPatientsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof apiPatientsDestroy>>>
    
    export type ApiPatientsDestroyMutationError = unknown

    export const useApiPatientsDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiPatientsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiPatientsDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getApiPatientsDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ØªØ§ÛŒÙ…â€ŒÙ„Ø§ÛŒÙ† ØªØ¬Ù…ÛŒØ¹â€ŒØ´Ø¯Ù‡ ÛŒÚ© Ø¨ÛŒÙ…Ø§Ø± Ø±Ø§ Ø¨Ø±Ù…ÛŒâ€ŒÚ¯Ø±Ø¯Ø§Ù†Ø¯ØŒ Ø´Ø§Ù…Ù„ Ù…ÙˆØ§Ø¬Ù‡Ø§Øª Ø¨Ø§Ù„ÛŒÙ†ÛŒØŒ Ù†ØªØ§ÛŒØ¬ Ø¢Ø²Ù…Ø§ÛŒØ´ØŒ Ø¯Ø³ØªÙˆØ±Ù‡Ø§ÛŒ Ø¯Ø§Ø±ÙˆÛŒÛŒ Ùˆ Ø®Ù„Ø§ØµÙ‡â€ŒÙ‡Ø§ÛŒ ØªÙˆÙ„ÛŒØ¯Ø´Ø¯Ù‡ ØªÙˆØ³Ø· Ø²ÛŒØ±Ø³ÛŒØ³ØªÙ… Ù‡ÙˆØ´â€ŒÙ…ØµÙ†ÙˆØ¹ÛŒ.

Ø¬Ø²Ø¦ÛŒØ§Øª:
- Ø§ÛŒÙ† Ø§Ú©Ø´Ù† Ø¨Ø±Ø§ÛŒ ÛŒÚ© Ø¨ÛŒÙ…Ø§Ø± Ù…Ø´Ø®Øµ (Ø¨Ø± Ù¾Ø§ÛŒÙ‡ pk/URL) Ø§Ø¬Ø±Ø§ Ù…ÛŒâ€ŒØ´ÙˆØ¯ Ùˆ Ù…Ø¬Ù…ÙˆØ¹Ù‡â€ŒÙ‡Ø§ÛŒ Ù…Ø±ØªØ¨Ø· Ø±Ø§ Ø¬Ø¯Ø§Ú¯Ø§Ù†Ù‡ ÙˆØ§Ú©Ø´ÛŒ Ùˆ Ø³Ø±ÛŒØ§Ù„Ø§ÛŒØ² Ù…ÛŒâ€ŒÚ©Ù†Ø¯.
- Ù…Ø­Ø¯ÙˆØ¯ÛŒØªâ€ŒÙ‡Ø§:
- Ù¾Ø§Ø±Ø§Ù…ØªØ± Ú©ÙˆØ¦Ø±ÛŒ `limit` ØªØ¹ÛŒÛŒÙ†â€ŒÚ©Ù†Ù†Ø¯Ù‡ Ø­Ø¯Ø§Ú©Ø«Ø± ØªØ¹Ø¯Ø§Ø¯ Ø¢ÛŒØªÙ…â€ŒÙ‡Ø§ Ø¨Ø±Ø§ÛŒ Ù‡Ø± ÛŒÚ© Ø§Ø² Ù†ÙˆØ¹â€ŒÙ‡Ø§ÛŒ EncounterØŒ LabResult Ùˆ MedicationOrder Ø§Ø³Øª. Ù…Ù‚Ø¯Ø§Ø± Ù¾ÛŒØ´â€ŒÙØ±Ø¶ 100 Ùˆ Ø¨ÛŒØ´ÛŒÙ†Ù‡ Ù…Ø¬Ø§Ø² 500 Ø§Ø³Øª (Ø§Ú¯Ø± Ù…Ù‚Ø¯Ø§Ø± Ø¨Ø²Ø±Ú¯â€ŒØªØ± Ø§Ø±Ø³Ø§Ù„ Ø´ÙˆØ¯ Ø¨Ù‡ 500 ØªÙ‚Ù„ÛŒÙ„ Ù…ÛŒâ€ŒÛŒØ§Ø¨Ø¯).
- AISummaryÙ‡Ø§ Ù…Ø³ØªÙ‚Ù„ Ø§Ø² `limit` Ù‡Ù…ÙˆØ§Ø±Ù‡ ØªØ§ 5 Ù…ÙˆØ±Ø¯ Ø§Ø®ÛŒØ± (Ø¨Ø± Ø§Ø³Ø§Ø³ `created_at` Ù†Ø²ÙˆÙ„ÛŒ) Ù…Ø­Ø¯ÙˆØ¯ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯.
- Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²Ú¯Ø±Ø¯Ø§Ù†Ø¯Ù‡ Ø´Ø¯Ù‡:
- patient: Ø¯Ø§Ø¯Ù‡ Ø³Ø±ÛŒØ§Ù„Ø§ÛŒØ²Ø´Ø¯Ù‡Ù” Ø¨ÛŒÙ…Ø§Ø±
- encounters: Ù„ÛŒØ³Øª Ø³Ø±ÛŒØ§Ù„Ø§ÛŒØ²Ø´Ø¯Ù‡Ù” EncounterÙ‡Ø§ Ù…Ø±ØªØ¨â€ŒØ´Ø¯Ù‡ Ø¨Ø± Ø§Ø³Ø§Ø³ `occured_at` Ù†Ø²ÙˆÙ„ÛŒ (ØªØ§ `limit`)
- labs: Ù„ÛŒØ³Øª Ø³Ø±ÛŒØ§Ù„Ø§ÛŒØ²Ø´Ø¯Ù‡Ù” LabResultÙ‡Ø§ Ù…Ø±ØªØ¨â€ŒØ´Ø¯Ù‡ Ø¨Ø± Ø§Ø³Ø§Ø³ `taken_at` Ù†Ø²ÙˆÙ„ÛŒ (ØªØ§ `limit`)
- medications: Ù„ÛŒØ³Øª Ø³Ø±ÛŒØ§Ù„Ø§ÛŒØ²Ø´Ø¯Ù‡Ù” MedicationOrderÙ‡Ø§ Ù…Ø±ØªØ¨â€ŒØ´Ø¯Ù‡ Ø¨Ø± Ø§Ø³Ø§Ø³ `start_date` Ù†Ø²ÙˆÙ„ÛŒ (ØªØ§ `limit`)
- ai_summaries: Ù„ÛŒØ³Øª Ø³Ø±ÛŒØ§Ù„Ø§ÛŒØ²Ø´Ø¯Ù‡Ù” AISummaryÙ‡Ø§ (Ø­Ø¯Ø§Ú©Ø«Ø± 5 Ù…ÙˆØ±Ø¯ØŒ Ù…Ø±ØªØ¨ Ø¨Ø± Ø§Ø³Ø§Ø³ `created_at` Ù†Ø²ÙˆÙ„ÛŒ)

Ù†Ú©Ø§Øª Ù…Ø±ØªØ¨Ø· Ø¨Ø§ Ù‡ÙˆØ´â€ŒÙ…ØµÙ†ÙˆØ¹ÛŒ Ùˆ Ù¾Ø±Ø¯Ø§Ø²Ø´:
- AISummaryÙ‡Ø§ Ø®Ø±ÙˆØ¬ÛŒâ€ŒÙ‡Ø§ÛŒ ØªØ­Ù„ÛŒÙ„ÛŒ/Ø®Ù„Ø§ØµÙ‡â€ŒØ³Ø§Ø²ÛŒ Ù‡Ø³ØªÙ†Ø¯ Ú©Ù‡ Ù…Ù…Ú©Ù† Ø§Ø³Øª Ø¨Ø± Ù¾Ø§ÛŒÙ‡ Ù¾Ø±Ø¯Ø§Ø²Ø´â€ŒÙ‡Ø§ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø±ØŒ Ù…Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ø²Ø¨Ø§Ù†ÛŒ ÛŒØ§ Ø¢Ù†Ø§Ù„ÛŒØ²Ù‡Ø§ÛŒ Ø¨Ø§Ù„ÛŒÙ†ÛŒ ØªÙˆÙ„ÛŒØ¯ Ø´Ø¯Ù‡ Ø¨Ø§Ø´Ù†Ø¯Ø› Ø§ÛŒÙ† Ù…ÙˆØ§Ø±Ø¯ Ù…Ú©Ù…Ù„ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø®Ø§Ù… Ø¨Ø§Ù„ÛŒÙ†ÛŒ Ù‡Ø³ØªÙ†Ø¯ Ùˆ Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´ Ø®Ù„Ø§ØµÙ‡Ù” ÙˆØ¶Ø¹ÛŒØª ÛŒØ§ Ù†Ú©Ø§Øª Ù…Ù‡Ù… Ø¨ÛŒÙ…Ø§Ø± Ø§Ø±Ø§Ø¦Ù‡ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯.
- Ø§ÛŒÙ† Ø§Ú©Ø´Ù† ØµØ±ÙØ§Ù‹ Ø®ÙˆØ§Ù†Ø¯Ù† Ùˆ Ø³Ø±ÛŒØ§Ù„Ø§ÛŒØ² Ú©Ø±Ø¯Ù† Ø±Ú©ÙˆØ±Ø¯Ù‡Ø§ÛŒ AISummary Ø±Ø§ Ø§Ù†Ø¬Ø§Ù… Ù…ÛŒâ€ŒØ¯Ù‡Ø¯ Ùˆ Ù‡ÛŒÚ† Ù¾Ø±Ø¯Ø§Ø²Ø´ ÛŒØ§ Ø§Ø¬Ø±Ø§ÛŒ ØªØ³Ú© Ø¶Ù…Ù†ÛŒ (Ù…Ø«Ù„ ÙØ±Ø§Ø®ÙˆØ§Ù†ÛŒ Ù…Ø¯Ù„ ÛŒØ§ Ø§ÛŒØ¬Ø§Ø¯ ÙˆØ¸ÛŒÙÙ‡ Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡) Ø±Ø§ Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ù†Ù…ÛŒâ€ŒÚ©Ù†Ø¯Ø› Ø§Ú¯Ø± Ù†ÛŒØ§Ø² Ø¨Ù‡ ØªÙˆÙ„ÛŒØ¯ ÛŒØ§ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø®Ù„Ø§ØµÙ‡â€ŒÙ‡Ø§ÛŒ Ù‡ÙˆØ´â€ŒÙ…ØµÙ†ÙˆØ¹ÛŒ Ø¨Ø§Ø´Ø¯ØŒ Ø¢Ù† Ø¹Ù…Ù„ÛŒØ§Øª Ø¨Ø§ÛŒØ¯ Ø§Ø² Ù…Ø³ÛŒØ±Ù‡Ø§ÛŒ Ø¬Ø¯Ø§Ú¯Ø§Ù†Ù‡ Ù…Ø¯ÛŒØ±ÛŒØª Ø´ÙˆØ¯.

Ø¹ÙˆØ§Ø±Ø¶ Ø¬Ø§Ù†Ø¨ÛŒ Ùˆ Ø®Ø·Ø§Ù‡Ø§:
- Ø®ÙˆØ¯ ØªØ§Ø¨Ø¹ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ø±Ø§ ØªØºÛŒÛŒØ± Ù†Ù…ÛŒâ€ŒØ¯Ù‡Ø¯Ø› Ø¯Ø± ØµÙˆØ±Øª Ù†Ø¨ÙˆØ¯Ù† Ø¯Ø³ØªØ±Ø³ÛŒ ÛŒØ§ ÙˆØ¬ÙˆØ¯ Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø¢Ø¨Ø¬Ú©Øª Ø¨ÛŒÙ…Ø§Ø±ØŒ Ø®Ø·Ø§Ù‡Ø§ÛŒ Ù…Ø±Ø¨ÙˆØ· Ø¨Ù‡ permissions ÛŒØ§ 404 ØªÙˆØ³Ø· Ù…ØªØ¯Ù‡Ø§ÛŒ Ù¾Ø§ÛŒÙ‡Ù” ViewSet/DRF ØªÙˆÙ„ÛŒØ¯ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯.
 */
export const apiPatientsTimelineRetrieve = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<Patient>(
      {url: `/api/patients/${id}/timeline/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiPatientsTimelineRetrieveQueryKey = (id?: number,) => {
    return [`/api/patients/${id}/timeline/`] as const;
    }

    
export const getApiPatientsTimelineRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiPatientsTimelineRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>> = ({ signal }) => apiPatientsTimelineRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiPatientsTimelineRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>>
export type ApiPatientsTimelineRetrieveQueryError = unknown


export function useApiPatientsTimelineRetrieve<TData = Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiPatientsTimelineRetrieve<TData = Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiPatientsTimelineRetrieve<TData = Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiPatientsTimelineRetrieve<TData = Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiPatientsTimelineRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * List all pattern-based alerts with filtering options
 * @summary List pattern alerts
 */
export const apiPatternAlertsList = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<PatternAlert[]>(
      {url: `/api/pattern-alerts/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiPatternAlertsListQueryKey = () => {
    return [`/api/pattern-alerts/`] as const;
    }

    
export const getApiPatternAlertsListQueryOptions = <TData = Awaited<ReturnType<typeof apiPatternAlertsList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatternAlertsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiPatternAlertsListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiPatternAlertsList>>> = ({ signal }) => apiPatternAlertsList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiPatternAlertsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiPatternAlertsListQueryResult = NonNullable<Awaited<ReturnType<typeof apiPatternAlertsList>>>
export type ApiPatternAlertsListQueryError = unknown


export function useApiPatternAlertsList<TData = Awaited<ReturnType<typeof apiPatternAlertsList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatternAlertsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiPatternAlertsList>>,
          TError,
          Awaited<ReturnType<typeof apiPatternAlertsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiPatternAlertsList<TData = Awaited<ReturnType<typeof apiPatternAlertsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatternAlertsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiPatternAlertsList>>,
          TError,
          Awaited<ReturnType<typeof apiPatternAlertsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiPatternAlertsList<TData = Awaited<ReturnType<typeof apiPatternAlertsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatternAlertsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List pattern alerts
 */

export function useApiPatternAlertsList<TData = Awaited<ReturnType<typeof apiPatternAlertsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatternAlertsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiPatternAlertsListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve a specific pattern alert by ID
 * @summary Get pattern alert
 */
export const apiPatternAlertsRetrieve = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<PatternAlert>(
      {url: `/api/pattern-alerts/${id}/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiPatternAlertsRetrieveQueryKey = (id?: number,) => {
    return [`/api/pattern-alerts/${id}/`] as const;
    }

    
export const getApiPatternAlertsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiPatternAlertsRetrieve>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatternAlertsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiPatternAlertsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiPatternAlertsRetrieve>>> = ({ signal }) => apiPatternAlertsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiPatternAlertsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiPatternAlertsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiPatternAlertsRetrieve>>>
export type ApiPatternAlertsRetrieveQueryError = unknown


export function useApiPatternAlertsRetrieve<TData = Awaited<ReturnType<typeof apiPatternAlertsRetrieve>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatternAlertsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiPatternAlertsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiPatternAlertsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiPatternAlertsRetrieve<TData = Awaited<ReturnType<typeof apiPatternAlertsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatternAlertsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiPatternAlertsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiPatternAlertsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiPatternAlertsRetrieve<TData = Awaited<ReturnType<typeof apiPatternAlertsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatternAlertsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get pattern alert
 */

export function useApiPatternAlertsRetrieve<TData = Awaited<ReturnType<typeof apiPatternAlertsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatternAlertsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiPatternAlertsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Mark a pattern alert as resolved
 * @summary Resolve pattern alert
 */
export const apiPatternAlertsResolveCreate = (
    id: number,
    patternAlert: NonReadonly<PatternAlert>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<PatternAlert>(
      {url: `/api/pattern-alerts/${id}/resolve/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: patternAlert, signal
    },
      options);
    }
  


export const getApiPatternAlertsResolveCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiPatternAlertsResolveCreate>>, TError,{id: number;data: NonReadonly<PatternAlert>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiPatternAlertsResolveCreate>>, TError,{id: number;data: NonReadonly<PatternAlert>}, TContext> => {

const mutationKey = ['apiPatternAlertsResolveCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiPatternAlertsResolveCreate>>, {id: number;data: NonReadonly<PatternAlert>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiPatternAlertsResolveCreate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiPatternAlertsResolveCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiPatternAlertsResolveCreate>>>
    export type ApiPatternAlertsResolveCreateMutationBody = NonReadonly<PatternAlert>
    export type ApiPatternAlertsResolveCreateMutationError = unknown

    /**
 * @summary Resolve pattern alert
 */
export const useApiPatternAlertsResolveCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiPatternAlertsResolveCreate>>, TError,{id: number;data: NonReadonly<PatternAlert>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiPatternAlertsResolveCreate>>,
        TError,
        {id: number;data: NonReadonly<PatternAlert>},
        TContext
      > => {

      const mutationOptions = getApiPatternAlertsResolveCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * List all pattern analyses with optional filtering by patient and pattern type
 * @summary List pattern analyses
 */
export const apiPatternAnalysesList = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<PatternAnalysis[]>(
      {url: `/api/pattern-analyses/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiPatternAnalysesListQueryKey = () => {
    return [`/api/pattern-analyses/`] as const;
    }

    
export const getApiPatternAnalysesListQueryOptions = <TData = Awaited<ReturnType<typeof apiPatternAnalysesList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatternAnalysesList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiPatternAnalysesListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiPatternAnalysesList>>> = ({ signal }) => apiPatternAnalysesList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiPatternAnalysesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiPatternAnalysesListQueryResult = NonNullable<Awaited<ReturnType<typeof apiPatternAnalysesList>>>
export type ApiPatternAnalysesListQueryError = unknown


export function useApiPatternAnalysesList<TData = Awaited<ReturnType<typeof apiPatternAnalysesList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatternAnalysesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiPatternAnalysesList>>,
          TError,
          Awaited<ReturnType<typeof apiPatternAnalysesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiPatternAnalysesList<TData = Awaited<ReturnType<typeof apiPatternAnalysesList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatternAnalysesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiPatternAnalysesList>>,
          TError,
          Awaited<ReturnType<typeof apiPatternAnalysesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiPatternAnalysesList<TData = Awaited<ReturnType<typeof apiPatternAnalysesList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatternAnalysesList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List pattern analyses
 */

export function useApiPatternAnalysesList<TData = Awaited<ReturnType<typeof apiPatternAnalysesList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatternAnalysesList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiPatternAnalysesListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve a specific pattern analysis by ID
 * @summary Get pattern analysis
 */
export const apiPatternAnalysesRetrieve = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<PatternAnalysis>(
      {url: `/api/pattern-analyses/${id}/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiPatternAnalysesRetrieveQueryKey = (id?: number,) => {
    return [`/api/pattern-analyses/${id}/`] as const;
    }

    
export const getApiPatternAnalysesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiPatternAnalysesRetrieve>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatternAnalysesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiPatternAnalysesRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiPatternAnalysesRetrieve>>> = ({ signal }) => apiPatternAnalysesRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiPatternAnalysesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiPatternAnalysesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiPatternAnalysesRetrieve>>>
export type ApiPatternAnalysesRetrieveQueryError = unknown


export function useApiPatternAnalysesRetrieve<TData = Awaited<ReturnType<typeof apiPatternAnalysesRetrieve>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatternAnalysesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiPatternAnalysesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiPatternAnalysesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiPatternAnalysesRetrieve<TData = Awaited<ReturnType<typeof apiPatternAnalysesRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatternAnalysesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiPatternAnalysesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiPatternAnalysesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiPatternAnalysesRetrieve<TData = Awaited<ReturnType<typeof apiPatternAnalysesRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatternAnalysesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get pattern analysis
 */

export function useApiPatternAnalysesRetrieve<TData = Awaited<ReturnType<typeof apiPatternAnalysesRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiPatternAnalysesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiPatternAnalysesRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Trigger new pattern analysis for specified patient and pattern types
 * @summary Request new pattern analysis
 */
export const apiPatternAnalysesAnalyzeCreate = (
    patternAnalysis: NonReadonly<PatternAnalysis>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<PatternAnalysis>(
      {url: `/api/pattern-analyses/analyze/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: patternAnalysis, signal
    },
      options);
    }
  


export const getApiPatternAnalysesAnalyzeCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiPatternAnalysesAnalyzeCreate>>, TError,{data: NonReadonly<PatternAnalysis>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiPatternAnalysesAnalyzeCreate>>, TError,{data: NonReadonly<PatternAnalysis>}, TContext> => {

const mutationKey = ['apiPatternAnalysesAnalyzeCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiPatternAnalysesAnalyzeCreate>>, {data: NonReadonly<PatternAnalysis>}> = (props) => {
          const {data} = props ?? {};

          return  apiPatternAnalysesAnalyzeCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiPatternAnalysesAnalyzeCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiPatternAnalysesAnalyzeCreate>>>
    export type ApiPatternAnalysesAnalyzeCreateMutationBody = NonReadonly<PatternAnalysis>
    export type ApiPatternAnalysesAnalyzeCreateMutationError = unknown

    /**
 * @summary Request new pattern analysis
 */
export const useApiPatternAnalysesAnalyzeCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiPatternAnalysesAnalyzeCreate>>, TError,{data: NonReadonly<PatternAnalysis>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiPatternAnalysesAnalyzeCreate>>,
        TError,
        {data: NonReadonly<PatternAnalysis>},
        TContext
      > => {

      const mutationOptions = getApiPatternAnalysesAnalyzeCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const apiRefsList = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<ClinicalReference[]>(
      {url: `/api/refs/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiRefsListQueryKey = () => {
    return [`/api/refs/`] as const;
    }

    
export const getApiRefsListQueryOptions = <TData = Awaited<ReturnType<typeof apiRefsList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRefsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiRefsListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiRefsList>>> = ({ signal }) => apiRefsList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiRefsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiRefsListQueryResult = NonNullable<Awaited<ReturnType<typeof apiRefsList>>>
export type ApiRefsListQueryError = unknown


export function useApiRefsList<TData = Awaited<ReturnType<typeof apiRefsList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRefsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiRefsList>>,
          TError,
          Awaited<ReturnType<typeof apiRefsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiRefsList<TData = Awaited<ReturnType<typeof apiRefsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRefsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiRefsList>>,
          TError,
          Awaited<ReturnType<typeof apiRefsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiRefsList<TData = Awaited<ReturnType<typeof apiRefsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRefsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiRefsList<TData = Awaited<ReturnType<typeof apiRefsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRefsList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiRefsListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const apiRefsCreate = (
    clinicalReference: NonReadonly<ClinicalReference>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<ClinicalReference>(
      {url: `/api/refs/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: clinicalReference, signal
    },
      options);
    }
  


export const getApiRefsCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiRefsCreate>>, TError,{data: NonReadonly<ClinicalReference>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiRefsCreate>>, TError,{data: NonReadonly<ClinicalReference>}, TContext> => {

const mutationKey = ['apiRefsCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiRefsCreate>>, {data: NonReadonly<ClinicalReference>}> = (props) => {
          const {data} = props ?? {};

          return  apiRefsCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiRefsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiRefsCreate>>>
    export type ApiRefsCreateMutationBody = NonReadonly<ClinicalReference>
    export type ApiRefsCreateMutationError = unknown

    export const useApiRefsCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiRefsCreate>>, TError,{data: NonReadonly<ClinicalReference>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiRefsCreate>>,
        TError,
        {data: NonReadonly<ClinicalReference>},
        TContext
      > => {

      const mutationOptions = getApiRefsCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const apiRefsRetrieve = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<ClinicalReference>(
      {url: `/api/refs/${id}/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiRefsRetrieveQueryKey = (id?: number,) => {
    return [`/api/refs/${id}/`] as const;
    }

    
export const getApiRefsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiRefsRetrieve>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRefsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiRefsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiRefsRetrieve>>> = ({ signal }) => apiRefsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiRefsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiRefsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiRefsRetrieve>>>
export type ApiRefsRetrieveQueryError = unknown


export function useApiRefsRetrieve<TData = Awaited<ReturnType<typeof apiRefsRetrieve>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRefsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiRefsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiRefsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiRefsRetrieve<TData = Awaited<ReturnType<typeof apiRefsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRefsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiRefsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiRefsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiRefsRetrieve<TData = Awaited<ReturnType<typeof apiRefsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRefsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiRefsRetrieve<TData = Awaited<ReturnType<typeof apiRefsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRefsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiRefsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const apiRefsUpdate = (
    id: number,
    clinicalReference: NonReadonly<ClinicalReference>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<ClinicalReference>(
      {url: `/api/refs/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: clinicalReference
    },
      options);
    }
  


export const getApiRefsUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiRefsUpdate>>, TError,{id: number;data: NonReadonly<ClinicalReference>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiRefsUpdate>>, TError,{id: number;data: NonReadonly<ClinicalReference>}, TContext> => {

const mutationKey = ['apiRefsUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiRefsUpdate>>, {id: number;data: NonReadonly<ClinicalReference>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiRefsUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiRefsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiRefsUpdate>>>
    export type ApiRefsUpdateMutationBody = NonReadonly<ClinicalReference>
    export type ApiRefsUpdateMutationError = unknown

    export const useApiRefsUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiRefsUpdate>>, TError,{id: number;data: NonReadonly<ClinicalReference>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiRefsUpdate>>,
        TError,
        {id: number;data: NonReadonly<ClinicalReference>},
        TContext
      > => {

      const mutationOptions = getApiRefsUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const apiRefsPartialUpdate = (
    id: number,
    patchedClinicalReference: NonReadonly<PatchedClinicalReference>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<ClinicalReference>(
      {url: `/api/refs/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedClinicalReference
    },
      options);
    }
  


export const getApiRefsPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiRefsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedClinicalReference>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiRefsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedClinicalReference>}, TContext> => {

const mutationKey = ['apiRefsPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiRefsPartialUpdate>>, {id: number;data: NonReadonly<PatchedClinicalReference>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiRefsPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiRefsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiRefsPartialUpdate>>>
    export type ApiRefsPartialUpdateMutationBody = NonReadonly<PatchedClinicalReference>
    export type ApiRefsPartialUpdateMutationError = unknown

    export const useApiRefsPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiRefsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedClinicalReference>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiRefsPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedClinicalReference>},
        TContext
      > => {

      const mutationOptions = getApiRefsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const apiRefsDestroy = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<null>(
      {url: `/api/refs/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getApiRefsDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiRefsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiRefsDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['apiRefsDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiRefsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  apiRefsDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiRefsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof apiRefsDestroy>>>
    
    export type ApiRefsDestroyMutationError = unknown

    export const useApiRefsDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiRefsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiRefsDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getApiRefsDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const apiRemindersList = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<Reminder[]>(
      {url: `/api/reminders/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiRemindersListQueryKey = () => {
    return [`/api/reminders/`] as const;
    }

    
export const getApiRemindersListQueryOptions = <TData = Awaited<ReturnType<typeof apiRemindersList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRemindersList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiRemindersListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiRemindersList>>> = ({ signal }) => apiRemindersList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiRemindersList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiRemindersListQueryResult = NonNullable<Awaited<ReturnType<typeof apiRemindersList>>>
export type ApiRemindersListQueryError = unknown


export function useApiRemindersList<TData = Awaited<ReturnType<typeof apiRemindersList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRemindersList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiRemindersList>>,
          TError,
          Awaited<ReturnType<typeof apiRemindersList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiRemindersList<TData = Awaited<ReturnType<typeof apiRemindersList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRemindersList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiRemindersList>>,
          TError,
          Awaited<ReturnType<typeof apiRemindersList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiRemindersList<TData = Awaited<ReturnType<typeof apiRemindersList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRemindersList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiRemindersList<TData = Awaited<ReturnType<typeof apiRemindersList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRemindersList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiRemindersListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const apiRemindersCreate = (
    reminder: NonReadonly<Reminder>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<Reminder>(
      {url: `/api/reminders/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: reminder, signal
    },
      options);
    }
  


export const getApiRemindersCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiRemindersCreate>>, TError,{data: NonReadonly<Reminder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiRemindersCreate>>, TError,{data: NonReadonly<Reminder>}, TContext> => {

const mutationKey = ['apiRemindersCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiRemindersCreate>>, {data: NonReadonly<Reminder>}> = (props) => {
          const {data} = props ?? {};

          return  apiRemindersCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiRemindersCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiRemindersCreate>>>
    export type ApiRemindersCreateMutationBody = NonReadonly<Reminder>
    export type ApiRemindersCreateMutationError = unknown

    export const useApiRemindersCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiRemindersCreate>>, TError,{data: NonReadonly<Reminder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiRemindersCreate>>,
        TError,
        {data: NonReadonly<Reminder>},
        TContext
      > => {

      const mutationOptions = getApiRemindersCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const apiRemindersRetrieve = (
    id: string,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<Reminder>(
      {url: `/api/reminders/${id}/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiRemindersRetrieveQueryKey = (id?: string,) => {
    return [`/api/reminders/${id}/`] as const;
    }

    
export const getApiRemindersRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiRemindersRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRemindersRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiRemindersRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiRemindersRetrieve>>> = ({ signal }) => apiRemindersRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiRemindersRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiRemindersRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiRemindersRetrieve>>>
export type ApiRemindersRetrieveQueryError = unknown


export function useApiRemindersRetrieve<TData = Awaited<ReturnType<typeof apiRemindersRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRemindersRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiRemindersRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiRemindersRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiRemindersRetrieve<TData = Awaited<ReturnType<typeof apiRemindersRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRemindersRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiRemindersRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiRemindersRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiRemindersRetrieve<TData = Awaited<ReturnType<typeof apiRemindersRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRemindersRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiRemindersRetrieve<TData = Awaited<ReturnType<typeof apiRemindersRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRemindersRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiRemindersRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const apiRemindersUpdate = (
    id: string,
    reminder: NonReadonly<Reminder>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<Reminder>(
      {url: `/api/reminders/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: reminder
    },
      options);
    }
  


export const getApiRemindersUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiRemindersUpdate>>, TError,{id: string;data: NonReadonly<Reminder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiRemindersUpdate>>, TError,{id: string;data: NonReadonly<Reminder>}, TContext> => {

const mutationKey = ['apiRemindersUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiRemindersUpdate>>, {id: string;data: NonReadonly<Reminder>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiRemindersUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiRemindersUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiRemindersUpdate>>>
    export type ApiRemindersUpdateMutationBody = NonReadonly<Reminder>
    export type ApiRemindersUpdateMutationError = unknown

    export const useApiRemindersUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiRemindersUpdate>>, TError,{id: string;data: NonReadonly<Reminder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiRemindersUpdate>>,
        TError,
        {id: string;data: NonReadonly<Reminder>},
        TContext
      > => {

      const mutationOptions = getApiRemindersUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const apiRemindersPartialUpdate = (
    id: string,
    patchedReminder: NonReadonly<PatchedReminder>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<Reminder>(
      {url: `/api/reminders/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedReminder
    },
      options);
    }
  


export const getApiRemindersPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiRemindersPartialUpdate>>, TError,{id: string;data: NonReadonly<PatchedReminder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiRemindersPartialUpdate>>, TError,{id: string;data: NonReadonly<PatchedReminder>}, TContext> => {

const mutationKey = ['apiRemindersPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiRemindersPartialUpdate>>, {id: string;data: NonReadonly<PatchedReminder>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiRemindersPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiRemindersPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiRemindersPartialUpdate>>>
    export type ApiRemindersPartialUpdateMutationBody = NonReadonly<PatchedReminder>
    export type ApiRemindersPartialUpdateMutationError = unknown

    export const useApiRemindersPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiRemindersPartialUpdate>>, TError,{id: string;data: NonReadonly<PatchedReminder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiRemindersPartialUpdate>>,
        TError,
        {id: string;data: NonReadonly<PatchedReminder>},
        TContext
      > => {

      const mutationOptions = getApiRemindersPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const apiRemindersDestroy = (
    id: string,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<null>(
      {url: `/api/reminders/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getApiRemindersDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiRemindersDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiRemindersDestroy>>, TError,{id: string}, TContext> => {

const mutationKey = ['apiRemindersDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiRemindersDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  apiRemindersDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiRemindersDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof apiRemindersDestroy>>>
    
    export type ApiRemindersDestroyMutationError = unknown

    export const useApiRemindersDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiRemindersDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiRemindersDestroy>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getApiRemindersDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const apiRemindersCompleteCreate = (
    id: string,
    reminder: NonReadonly<Reminder>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<Reminder>(
      {url: `/api/reminders/${id}/complete/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: reminder, signal
    },
      options);
    }
  


export const getApiRemindersCompleteCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiRemindersCompleteCreate>>, TError,{id: string;data: NonReadonly<Reminder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiRemindersCompleteCreate>>, TError,{id: string;data: NonReadonly<Reminder>}, TContext> => {

const mutationKey = ['apiRemindersCompleteCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiRemindersCompleteCreate>>, {id: string;data: NonReadonly<Reminder>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiRemindersCompleteCreate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiRemindersCompleteCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiRemindersCompleteCreate>>>
    export type ApiRemindersCompleteCreateMutationBody = NonReadonly<Reminder>
    export type ApiRemindersCompleteCreateMutationError = unknown

    export const useApiRemindersCompleteCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiRemindersCompleteCreate>>, TError,{id: string;data: NonReadonly<Reminder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiRemindersCompleteCreate>>,
        TError,
        {id: string;data: NonReadonly<Reminder>},
        TContext
      > => {

      const mutationOptions = getApiRemindersCompleteCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const apiRemindersSnoozeCreate = (
    id: string,
    reminder: NonReadonly<Reminder>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<Reminder>(
      {url: `/api/reminders/${id}/snooze/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: reminder, signal
    },
      options);
    }
  


export const getApiRemindersSnoozeCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiRemindersSnoozeCreate>>, TError,{id: string;data: NonReadonly<Reminder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiRemindersSnoozeCreate>>, TError,{id: string;data: NonReadonly<Reminder>}, TContext> => {

const mutationKey = ['apiRemindersSnoozeCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiRemindersSnoozeCreate>>, {id: string;data: NonReadonly<Reminder>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiRemindersSnoozeCreate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiRemindersSnoozeCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiRemindersSnoozeCreate>>>
    export type ApiRemindersSnoozeCreateMutationBody = NonReadonly<Reminder>
    export type ApiRemindersSnoozeCreateMutationError = unknown

    export const useApiRemindersSnoozeCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiRemindersSnoozeCreate>>, TError,{id: string;data: NonReadonly<Reminder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiRemindersSnoozeCreate>>,
        TError,
        {id: string;data: NonReadonly<Reminder>},
        TContext
      > => {

      const mutationOptions = getApiRemindersSnoozeCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * List due reminders for current doctor patients.
Optional query: ?patient_id=<uuid>
 */
export const apiRemindersDueRetrieve = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<Reminder>(
      {url: `/api/reminders/due/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiRemindersDueRetrieveQueryKey = () => {
    return [`/api/reminders/due/`] as const;
    }

    
export const getApiRemindersDueRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiRemindersDueRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRemindersDueRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiRemindersDueRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiRemindersDueRetrieve>>> = ({ signal }) => apiRemindersDueRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiRemindersDueRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiRemindersDueRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiRemindersDueRetrieve>>>
export type ApiRemindersDueRetrieveQueryError = unknown


export function useApiRemindersDueRetrieve<TData = Awaited<ReturnType<typeof apiRemindersDueRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRemindersDueRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiRemindersDueRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiRemindersDueRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiRemindersDueRetrieve<TData = Awaited<ReturnType<typeof apiRemindersDueRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRemindersDueRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiRemindersDueRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiRemindersDueRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiRemindersDueRetrieve<TData = Awaited<ReturnType<typeof apiRemindersDueRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRemindersDueRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiRemindersDueRetrieve<TData = Awaited<ReturnType<typeof apiRemindersDueRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRemindersDueRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiRemindersDueRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Generate upcoming reminders for a given patient_id.
Body: {"patient_id": "<uuid>"}
 */
export const apiRemindersGenerateCreate = (
    reminder: NonReadonly<Reminder>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<Reminder>(
      {url: `/api/reminders/generate/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: reminder, signal
    },
      options);
    }
  


export const getApiRemindersGenerateCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiRemindersGenerateCreate>>, TError,{data: NonReadonly<Reminder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiRemindersGenerateCreate>>, TError,{data: NonReadonly<Reminder>}, TContext> => {

const mutationKey = ['apiRemindersGenerateCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiRemindersGenerateCreate>>, {data: NonReadonly<Reminder>}> = (props) => {
          const {data} = props ?? {};

          return  apiRemindersGenerateCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiRemindersGenerateCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiRemindersGenerateCreate>>>
    export type ApiRemindersGenerateCreateMutationBody = NonReadonly<Reminder>
    export type ApiRemindersGenerateCreateMutationError = unknown

    export const useApiRemindersGenerateCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiRemindersGenerateCreate>>, TError,{data: NonReadonly<Reminder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiRemindersGenerateCreate>>,
        TError,
        {data: NonReadonly<Reminder>},
        TContext
      > => {

      const mutationOptions = getApiRemindersGenerateCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Send Notification entries for all due reminders for a given patient.
Body: {"patient_id": "<uuid>"}
 */
export const apiRemindersNotifyDueCreate = (
    reminder: NonReadonly<Reminder>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<Reminder>(
      {url: `/api/reminders/notify-due/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: reminder, signal
    },
      options);
    }
  


export const getApiRemindersNotifyDueCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiRemindersNotifyDueCreate>>, TError,{data: NonReadonly<Reminder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiRemindersNotifyDueCreate>>, TError,{data: NonReadonly<Reminder>}, TContext> => {

const mutationKey = ['apiRemindersNotifyDueCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiRemindersNotifyDueCreate>>, {data: NonReadonly<Reminder>}> = (props) => {
          const {data} = props ?? {};

          return  apiRemindersNotifyDueCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiRemindersNotifyDueCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiRemindersNotifyDueCreate>>>
    export type ApiRemindersNotifyDueCreateMutationBody = NonReadonly<Reminder>
    export type ApiRemindersNotifyDueCreateMutationError = unknown

    export const useApiRemindersNotifyDueCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiRemindersNotifyDueCreate>>, TError,{data: NonReadonly<Reminder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiRemindersNotifyDueCreate>>,
        TError,
        {data: NonReadonly<Reminder>},
        TContext
      > => {

      const mutationOptions = getApiRemindersNotifyDueCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Takes a set of user credentials and returns an access and refresh JSON web
token pair to prove the authentication of those credentials.
 */
export const apiTokenCreate = (
    tokenObtainPair: NonReadonly<TokenObtainPair>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<TokenObtainPair>(
      {url: `/api/token/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: tokenObtainPair, signal
    },
      options);
    }
  


export const getApiTokenCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiTokenCreate>>, TError,{data: NonReadonly<TokenObtainPair>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiTokenCreate>>, TError,{data: NonReadonly<TokenObtainPair>}, TContext> => {

const mutationKey = ['apiTokenCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiTokenCreate>>, {data: NonReadonly<TokenObtainPair>}> = (props) => {
          const {data} = props ?? {};

          return  apiTokenCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiTokenCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiTokenCreate>>>
    export type ApiTokenCreateMutationBody = NonReadonly<TokenObtainPair>
    export type ApiTokenCreateMutationError = unknown

    export const useApiTokenCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiTokenCreate>>, TError,{data: NonReadonly<TokenObtainPair>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiTokenCreate>>,
        TError,
        {data: NonReadonly<TokenObtainPair>},
        TContext
      > => {

      const mutationOptions = getApiTokenCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Takes a refresh type JSON web token and returns an access type JSON web
token if the refresh token is valid.
 */
export const apiTokenRefreshCreate = (
    tokenRefresh: NonReadonly<TokenRefresh>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<TokenRefresh>(
      {url: `/api/token/refresh/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: tokenRefresh, signal
    },
      options);
    }
  


export const getApiTokenRefreshCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiTokenRefreshCreate>>, TError,{data: NonReadonly<TokenRefresh>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiTokenRefreshCreate>>, TError,{data: NonReadonly<TokenRefresh>}, TContext> => {

const mutationKey = ['apiTokenRefreshCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiTokenRefreshCreate>>, {data: NonReadonly<TokenRefresh>}> = (props) => {
          const {data} = props ?? {};

          return  apiTokenRefreshCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiTokenRefreshCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiTokenRefreshCreate>>>
    export type ApiTokenRefreshCreateMutationBody = NonReadonly<TokenRefresh>
    export type ApiTokenRefreshCreateMutationError = unknown

    export const useApiTokenRefreshCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiTokenRefreshCreate>>, TError,{data: NonReadonly<TokenRefresh>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiTokenRefreshCreate>>,
        TError,
        {data: NonReadonly<TokenRefresh>},
        TContext
      > => {

      const mutationOptions = getApiTokenRefreshCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const apiVersionsRetrieve = (
    resourceType: string,
    resourceId: string,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<null>(
      {url: `/api/versions/${resourceType}/${resourceId}/`, method: 'GET', signal
    },
      options);
    }
  

export const getApiVersionsRetrieveQueryKey = (resourceType?: string,
    resourceId?: string,) => {
    return [`/api/versions/${resourceType}/${resourceId}/`] as const;
    }

    
export const getApiVersionsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiVersionsRetrieve>>, TError = unknown>(resourceType: string,
    resourceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiVersionsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiVersionsRetrieveQueryKey(resourceType,resourceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiVersionsRetrieve>>> = ({ signal }) => apiVersionsRetrieve(resourceType,resourceId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(resourceType && resourceId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiVersionsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiVersionsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiVersionsRetrieve>>>
export type ApiVersionsRetrieveQueryError = unknown


export function useApiVersionsRetrieve<TData = Awaited<ReturnType<typeof apiVersionsRetrieve>>, TError = unknown>(
 resourceType: string,
    resourceId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiVersionsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiVersionsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiVersionsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiVersionsRetrieve<TData = Awaited<ReturnType<typeof apiVersionsRetrieve>>, TError = unknown>(
 resourceType: string,
    resourceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiVersionsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiVersionsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiVersionsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiVersionsRetrieve<TData = Awaited<ReturnType<typeof apiVersionsRetrieve>>, TError = unknown>(
 resourceType: string,
    resourceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiVersionsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useApiVersionsRetrieve<TData = Awaited<ReturnType<typeof apiVersionsRetrieve>>, TError = unknown>(
 resourceType: string,
    resourceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiVersionsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiVersionsRetrieveQueryOptions(resourceType,resourceId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const apiVersionsRevertCreate = (
    resourceType: string,
    resourceId: string,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<null>(
      {url: `/api/versions/${resourceType}/${resourceId}/revert/`, method: 'POST', signal
    },
      options);
    }
  


export const getApiVersionsRevertCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiVersionsRevertCreate>>, TError,{resourceType: string;resourceId: string}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiVersionsRevertCreate>>, TError,{resourceType: string;resourceId: string}, TContext> => {

const mutationKey = ['apiVersionsRevertCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiVersionsRevertCreate>>, {resourceType: string;resourceId: string}> = (props) => {
          const {resourceType,resourceId} = props ?? {};

          return  apiVersionsRevertCreate(resourceType,resourceId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiVersionsRevertCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiVersionsRevertCreate>>>
    
    export type ApiVersionsRevertCreateMutationError = unknown

    export const useApiVersionsRevertCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiVersionsRevertCreate>>, TError,{resourceType: string;resourceId: string}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiVersionsRevertCreate>>,
        TError,
        {resourceType: string;resourceId: string},
        TContext
      > => {

      const mutationOptions = getApiVersionsRevertCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§ÛŒ ØªØ§ÛŒÙ…â€ŒÙ„Ø§ÛŒÙ†
 */
export const timelineApiCategoriesList = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<TimelineEventCategory[]>(
      {url: `/timeline/api/categories/`, method: 'GET', signal
    },
      options);
    }
  

export const getTimelineApiCategoriesListQueryKey = () => {
    return [`/timeline/api/categories/`] as const;
    }

    
export const getTimelineApiCategoriesListQueryOptions = <TData = Awaited<ReturnType<typeof timelineApiCategoriesList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiCategoriesList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTimelineApiCategoriesListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof timelineApiCategoriesList>>> = ({ signal }) => timelineApiCategoriesList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof timelineApiCategoriesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type TimelineApiCategoriesListQueryResult = NonNullable<Awaited<ReturnType<typeof timelineApiCategoriesList>>>
export type TimelineApiCategoriesListQueryError = unknown


export function useTimelineApiCategoriesList<TData = Awaited<ReturnType<typeof timelineApiCategoriesList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiCategoriesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineApiCategoriesList>>,
          TError,
          Awaited<ReturnType<typeof timelineApiCategoriesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineApiCategoriesList<TData = Awaited<ReturnType<typeof timelineApiCategoriesList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiCategoriesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineApiCategoriesList>>,
          TError,
          Awaited<ReturnType<typeof timelineApiCategoriesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineApiCategoriesList<TData = Awaited<ReturnType<typeof timelineApiCategoriesList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiCategoriesList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useTimelineApiCategoriesList<TData = Awaited<ReturnType<typeof timelineApiCategoriesList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiCategoriesList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getTimelineApiCategoriesListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§ÛŒ ØªØ§ÛŒÙ…â€ŒÙ„Ø§ÛŒÙ†
 */
export const timelineApiCategoriesRetrieve = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<TimelineEventCategory>(
      {url: `/timeline/api/categories/${id}/`, method: 'GET', signal
    },
      options);
    }
  

export const getTimelineApiCategoriesRetrieveQueryKey = (id?: number,) => {
    return [`/timeline/api/categories/${id}/`] as const;
    }

    
export const getTimelineApiCategoriesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof timelineApiCategoriesRetrieve>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiCategoriesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTimelineApiCategoriesRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof timelineApiCategoriesRetrieve>>> = ({ signal }) => timelineApiCategoriesRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof timelineApiCategoriesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type TimelineApiCategoriesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof timelineApiCategoriesRetrieve>>>
export type TimelineApiCategoriesRetrieveQueryError = unknown


export function useTimelineApiCategoriesRetrieve<TData = Awaited<ReturnType<typeof timelineApiCategoriesRetrieve>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiCategoriesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineApiCategoriesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof timelineApiCategoriesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineApiCategoriesRetrieve<TData = Awaited<ReturnType<typeof timelineApiCategoriesRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiCategoriesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineApiCategoriesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof timelineApiCategoriesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineApiCategoriesRetrieve<TData = Awaited<ReturnType<typeof timelineApiCategoriesRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiCategoriesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useTimelineApiCategoriesRetrieve<TData = Awaited<ReturnType<typeof timelineApiCategoriesRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiCategoriesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getTimelineApiCategoriesRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª ØªØ§ÛŒÙ…â€ŒÙ„Ø§ÛŒÙ† Ø¨ÛŒÙ…Ø§Ø±
 */
export const timelineApiPreferencesList = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<PatientTimelinePreference[]>(
      {url: `/timeline/api/preferences/`, method: 'GET', signal
    },
      options);
    }
  

export const getTimelineApiPreferencesListQueryKey = () => {
    return [`/timeline/api/preferences/`] as const;
    }

    
export const getTimelineApiPreferencesListQueryOptions = <TData = Awaited<ReturnType<typeof timelineApiPreferencesList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiPreferencesList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTimelineApiPreferencesListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof timelineApiPreferencesList>>> = ({ signal }) => timelineApiPreferencesList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof timelineApiPreferencesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type TimelineApiPreferencesListQueryResult = NonNullable<Awaited<ReturnType<typeof timelineApiPreferencesList>>>
export type TimelineApiPreferencesListQueryError = unknown


export function useTimelineApiPreferencesList<TData = Awaited<ReturnType<typeof timelineApiPreferencesList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiPreferencesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineApiPreferencesList>>,
          TError,
          Awaited<ReturnType<typeof timelineApiPreferencesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineApiPreferencesList<TData = Awaited<ReturnType<typeof timelineApiPreferencesList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiPreferencesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineApiPreferencesList>>,
          TError,
          Awaited<ReturnType<typeof timelineApiPreferencesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineApiPreferencesList<TData = Awaited<ReturnType<typeof timelineApiPreferencesList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiPreferencesList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useTimelineApiPreferencesList<TData = Awaited<ReturnType<typeof timelineApiPreferencesList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiPreferencesList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getTimelineApiPreferencesListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª ØªØ§ÛŒÙ…â€ŒÙ„Ø§ÛŒÙ† Ø¨ÛŒÙ…Ø§Ø±
 */
export const timelineApiPreferencesCreate = (
    patientTimelinePreference: NonReadonly<PatientTimelinePreference>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<PatientTimelinePreference>(
      {url: `/timeline/api/preferences/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: patientTimelinePreference, signal
    },
      options);
    }
  


export const getTimelineApiPreferencesCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineApiPreferencesCreate>>, TError,{data: NonReadonly<PatientTimelinePreference>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof timelineApiPreferencesCreate>>, TError,{data: NonReadonly<PatientTimelinePreference>}, TContext> => {

const mutationKey = ['timelineApiPreferencesCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof timelineApiPreferencesCreate>>, {data: NonReadonly<PatientTimelinePreference>}> = (props) => {
          const {data} = props ?? {};

          return  timelineApiPreferencesCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TimelineApiPreferencesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof timelineApiPreferencesCreate>>>
    export type TimelineApiPreferencesCreateMutationBody = NonReadonly<PatientTimelinePreference>
    export type TimelineApiPreferencesCreateMutationError = unknown

    export const useTimelineApiPreferencesCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineApiPreferencesCreate>>, TError,{data: NonReadonly<PatientTimelinePreference>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof timelineApiPreferencesCreate>>,
        TError,
        {data: NonReadonly<PatientTimelinePreference>},
        TContext
      > => {

      const mutationOptions = getTimelineApiPreferencesCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª ØªØ§ÛŒÙ…â€ŒÙ„Ø§ÛŒÙ† Ø¨ÛŒÙ…Ø§Ø±
 */
export const timelineApiPreferencesRetrieve = (
    id: string,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<PatientTimelinePreference>(
      {url: `/timeline/api/preferences/${id}/`, method: 'GET', signal
    },
      options);
    }
  

export const getTimelineApiPreferencesRetrieveQueryKey = (id?: string,) => {
    return [`/timeline/api/preferences/${id}/`] as const;
    }

    
export const getTimelineApiPreferencesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof timelineApiPreferencesRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiPreferencesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTimelineApiPreferencesRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof timelineApiPreferencesRetrieve>>> = ({ signal }) => timelineApiPreferencesRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof timelineApiPreferencesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type TimelineApiPreferencesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof timelineApiPreferencesRetrieve>>>
export type TimelineApiPreferencesRetrieveQueryError = unknown


export function useTimelineApiPreferencesRetrieve<TData = Awaited<ReturnType<typeof timelineApiPreferencesRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiPreferencesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineApiPreferencesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof timelineApiPreferencesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineApiPreferencesRetrieve<TData = Awaited<ReturnType<typeof timelineApiPreferencesRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiPreferencesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineApiPreferencesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof timelineApiPreferencesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineApiPreferencesRetrieve<TData = Awaited<ReturnType<typeof timelineApiPreferencesRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiPreferencesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useTimelineApiPreferencesRetrieve<TData = Awaited<ReturnType<typeof timelineApiPreferencesRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiPreferencesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getTimelineApiPreferencesRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª ØªØ§ÛŒÙ…â€ŒÙ„Ø§ÛŒÙ† Ø¨ÛŒÙ…Ø§Ø±
 */
export const timelineApiPreferencesUpdate = (
    id: string,
    patientTimelinePreference: NonReadonly<PatientTimelinePreference>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<PatientTimelinePreference>(
      {url: `/timeline/api/preferences/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: patientTimelinePreference
    },
      options);
    }
  


export const getTimelineApiPreferencesUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineApiPreferencesUpdate>>, TError,{id: string;data: NonReadonly<PatientTimelinePreference>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof timelineApiPreferencesUpdate>>, TError,{id: string;data: NonReadonly<PatientTimelinePreference>}, TContext> => {

const mutationKey = ['timelineApiPreferencesUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof timelineApiPreferencesUpdate>>, {id: string;data: NonReadonly<PatientTimelinePreference>}> = (props) => {
          const {id,data} = props ?? {};

          return  timelineApiPreferencesUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TimelineApiPreferencesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof timelineApiPreferencesUpdate>>>
    export type TimelineApiPreferencesUpdateMutationBody = NonReadonly<PatientTimelinePreference>
    export type TimelineApiPreferencesUpdateMutationError = unknown

    export const useTimelineApiPreferencesUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineApiPreferencesUpdate>>, TError,{id: string;data: NonReadonly<PatientTimelinePreference>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof timelineApiPreferencesUpdate>>,
        TError,
        {id: string;data: NonReadonly<PatientTimelinePreference>},
        TContext
      > => {

      const mutationOptions = getTimelineApiPreferencesUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª ØªØ§ÛŒÙ…â€ŒÙ„Ø§ÛŒÙ† Ø¨ÛŒÙ…Ø§Ø±
 */
export const timelineApiPreferencesPartialUpdate = (
    id: string,
    patchedPatientTimelinePreference: NonReadonly<PatchedPatientTimelinePreference>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<PatientTimelinePreference>(
      {url: `/timeline/api/preferences/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedPatientTimelinePreference
    },
      options);
    }
  


export const getTimelineApiPreferencesPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineApiPreferencesPartialUpdate>>, TError,{id: string;data: NonReadonly<PatchedPatientTimelinePreference>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof timelineApiPreferencesPartialUpdate>>, TError,{id: string;data: NonReadonly<PatchedPatientTimelinePreference>}, TContext> => {

const mutationKey = ['timelineApiPreferencesPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof timelineApiPreferencesPartialUpdate>>, {id: string;data: NonReadonly<PatchedPatientTimelinePreference>}> = (props) => {
          const {id,data} = props ?? {};

          return  timelineApiPreferencesPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TimelineApiPreferencesPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof timelineApiPreferencesPartialUpdate>>>
    export type TimelineApiPreferencesPartialUpdateMutationBody = NonReadonly<PatchedPatientTimelinePreference>
    export type TimelineApiPreferencesPartialUpdateMutationError = unknown

    export const useTimelineApiPreferencesPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineApiPreferencesPartialUpdate>>, TError,{id: string;data: NonReadonly<PatchedPatientTimelinePreference>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof timelineApiPreferencesPartialUpdate>>,
        TError,
        {id: string;data: NonReadonly<PatchedPatientTimelinePreference>},
        TContext
      > => {

      const mutationOptions = getTimelineApiPreferencesPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª ØªØ§ÛŒÙ…â€ŒÙ„Ø§ÛŒÙ† Ø¨ÛŒÙ…Ø§Ø±
 */
export const timelineApiPreferencesDestroy = (
    id: string,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<null>(
      {url: `/timeline/api/preferences/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getTimelineApiPreferencesDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineApiPreferencesDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof timelineApiPreferencesDestroy>>, TError,{id: string}, TContext> => {

const mutationKey = ['timelineApiPreferencesDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof timelineApiPreferencesDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  timelineApiPreferencesDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TimelineApiPreferencesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof timelineApiPreferencesDestroy>>>
    
    export type TimelineApiPreferencesDestroyMutationError = unknown

    export const useTimelineApiPreferencesDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineApiPreferencesDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof timelineApiPreferencesDestroy>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getTimelineApiPreferencesDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ØªÙ†Ø¸ÛŒÙ…Ø§Øª ØªØ§ÛŒÙ…â€ŒÙ„Ø§ÛŒÙ† Ú©Ø§Ø±Ø¨Ø± Ø¬Ø§Ø±ÛŒ (Ø§Ú¯Ø± Ø¨ÛŒÙ…Ø§Ø± Ø§Ø³Øª)
 */
export const timelineApiPreferencesMyPreferencesRetrieve = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<PatientTimelinePreference>(
      {url: `/timeline/api/preferences/my_preferences/`, method: 'GET', signal
    },
      options);
    }
  

export const getTimelineApiPreferencesMyPreferencesRetrieveQueryKey = () => {
    return [`/timeline/api/preferences/my_preferences/`] as const;
    }

    
export const getTimelineApiPreferencesMyPreferencesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof timelineApiPreferencesMyPreferencesRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiPreferencesMyPreferencesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTimelineApiPreferencesMyPreferencesRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof timelineApiPreferencesMyPreferencesRetrieve>>> = ({ signal }) => timelineApiPreferencesMyPreferencesRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof timelineApiPreferencesMyPreferencesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type TimelineApiPreferencesMyPreferencesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof timelineApiPreferencesMyPreferencesRetrieve>>>
export type TimelineApiPreferencesMyPreferencesRetrieveQueryError = unknown


export function useTimelineApiPreferencesMyPreferencesRetrieve<TData = Awaited<ReturnType<typeof timelineApiPreferencesMyPreferencesRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiPreferencesMyPreferencesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineApiPreferencesMyPreferencesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof timelineApiPreferencesMyPreferencesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineApiPreferencesMyPreferencesRetrieve<TData = Awaited<ReturnType<typeof timelineApiPreferencesMyPreferencesRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiPreferencesMyPreferencesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineApiPreferencesMyPreferencesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof timelineApiPreferencesMyPreferencesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineApiPreferencesMyPreferencesRetrieve<TData = Awaited<ReturnType<typeof timelineApiPreferencesMyPreferencesRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiPreferencesMyPreferencesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useTimelineApiPreferencesMyPreferencesRetrieve<TData = Awaited<ReturnType<typeof timelineApiPreferencesMyPreferencesRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiPreferencesMyPreferencesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getTimelineApiPreferencesMyPreferencesRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ØªÙ†Ø¸ÛŒÙ…Ø§Øª ØªØ§ÛŒÙ…â€ŒÙ„Ø§ÛŒÙ† Ú©Ø§Ø±Ø¨Ø± Ø¬Ø§Ø±ÛŒ (Ø§Ú¯Ø± Ø¨ÛŒÙ…Ø§Ø± Ø§Ø³Øª)
 */
export const timelineApiPreferencesMyPreferencesCreate = (
    patientTimelinePreference: NonReadonly<PatientTimelinePreference>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<PatientTimelinePreference>(
      {url: `/timeline/api/preferences/my_preferences/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: patientTimelinePreference, signal
    },
      options);
    }
  


export const getTimelineApiPreferencesMyPreferencesCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineApiPreferencesMyPreferencesCreate>>, TError,{data: NonReadonly<PatientTimelinePreference>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof timelineApiPreferencesMyPreferencesCreate>>, TError,{data: NonReadonly<PatientTimelinePreference>}, TContext> => {

const mutationKey = ['timelineApiPreferencesMyPreferencesCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof timelineApiPreferencesMyPreferencesCreate>>, {data: NonReadonly<PatientTimelinePreference>}> = (props) => {
          const {data} = props ?? {};

          return  timelineApiPreferencesMyPreferencesCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TimelineApiPreferencesMyPreferencesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof timelineApiPreferencesMyPreferencesCreate>>>
    export type TimelineApiPreferencesMyPreferencesCreateMutationBody = NonReadonly<PatientTimelinePreference>
    export type TimelineApiPreferencesMyPreferencesCreateMutationError = unknown

    export const useTimelineApiPreferencesMyPreferencesCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineApiPreferencesMyPreferencesCreate>>, TError,{data: NonReadonly<PatientTimelinePreference>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof timelineApiPreferencesMyPreferencesCreate>>,
        TError,
        {data: NonReadonly<PatientTimelinePreference>},
        TContext
      > => {

      const mutationOptions = getTimelineApiPreferencesMyPreferencesCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ØªÙ†Ø¸ÛŒÙ…Ø§Øª ØªØ§ÛŒÙ…â€ŒÙ„Ø§ÛŒÙ† Ú©Ø§Ø±Ø¨Ø± Ø¬Ø§Ø±ÛŒ (Ø§Ú¯Ø± Ø¨ÛŒÙ…Ø§Ø± Ø§Ø³Øª)
 */
export const timelineApiPreferencesMyPreferencesUpdate = (
    patientTimelinePreference: NonReadonly<PatientTimelinePreference>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<PatientTimelinePreference>(
      {url: `/timeline/api/preferences/my_preferences/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: patientTimelinePreference
    },
      options);
    }
  


export const getTimelineApiPreferencesMyPreferencesUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineApiPreferencesMyPreferencesUpdate>>, TError,{data: NonReadonly<PatientTimelinePreference>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof timelineApiPreferencesMyPreferencesUpdate>>, TError,{data: NonReadonly<PatientTimelinePreference>}, TContext> => {

const mutationKey = ['timelineApiPreferencesMyPreferencesUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof timelineApiPreferencesMyPreferencesUpdate>>, {data: NonReadonly<PatientTimelinePreference>}> = (props) => {
          const {data} = props ?? {};

          return  timelineApiPreferencesMyPreferencesUpdate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TimelineApiPreferencesMyPreferencesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof timelineApiPreferencesMyPreferencesUpdate>>>
    export type TimelineApiPreferencesMyPreferencesUpdateMutationBody = NonReadonly<PatientTimelinePreference>
    export type TimelineApiPreferencesMyPreferencesUpdateMutationError = unknown

    export const useTimelineApiPreferencesMyPreferencesUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineApiPreferencesMyPreferencesUpdate>>, TError,{data: NonReadonly<PatientTimelinePreference>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof timelineApiPreferencesMyPreferencesUpdate>>,
        TError,
        {data: NonReadonly<PatientTimelinePreference>},
        TContext
      > => {

      const mutationOptions = getTimelineApiPreferencesMyPreferencesUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ù‚Ø§Ù„Ø¨â€ŒÙ‡Ø§ÛŒ ÛŒØ§Ø¯Ø¢ÙˆØ±ÛŒ
 */
export const timelineApiReminderTemplatesList = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<ReminderTemplate[]>(
      {url: `/timeline/api/reminder-templates/`, method: 'GET', signal
    },
      options);
    }
  

export const getTimelineApiReminderTemplatesListQueryKey = () => {
    return [`/timeline/api/reminder-templates/`] as const;
    }

    
export const getTimelineApiReminderTemplatesListQueryOptions = <TData = Awaited<ReturnType<typeof timelineApiReminderTemplatesList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiReminderTemplatesList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTimelineApiReminderTemplatesListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof timelineApiReminderTemplatesList>>> = ({ signal }) => timelineApiReminderTemplatesList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof timelineApiReminderTemplatesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type TimelineApiReminderTemplatesListQueryResult = NonNullable<Awaited<ReturnType<typeof timelineApiReminderTemplatesList>>>
export type TimelineApiReminderTemplatesListQueryError = unknown


export function useTimelineApiReminderTemplatesList<TData = Awaited<ReturnType<typeof timelineApiReminderTemplatesList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiReminderTemplatesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineApiReminderTemplatesList>>,
          TError,
          Awaited<ReturnType<typeof timelineApiReminderTemplatesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineApiReminderTemplatesList<TData = Awaited<ReturnType<typeof timelineApiReminderTemplatesList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiReminderTemplatesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineApiReminderTemplatesList>>,
          TError,
          Awaited<ReturnType<typeof timelineApiReminderTemplatesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineApiReminderTemplatesList<TData = Awaited<ReturnType<typeof timelineApiReminderTemplatesList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiReminderTemplatesList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useTimelineApiReminderTemplatesList<TData = Awaited<ReturnType<typeof timelineApiReminderTemplatesList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiReminderTemplatesList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getTimelineApiReminderTemplatesListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ù‚Ø§Ù„Ø¨â€ŒÙ‡Ø§ÛŒ ÛŒØ§Ø¯Ø¢ÙˆØ±ÛŒ
 */
export const timelineApiReminderTemplatesRetrieve = (
    id: number,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<ReminderTemplate>(
      {url: `/timeline/api/reminder-templates/${id}/`, method: 'GET', signal
    },
      options);
    }
  

export const getTimelineApiReminderTemplatesRetrieveQueryKey = (id?: number,) => {
    return [`/timeline/api/reminder-templates/${id}/`] as const;
    }

    
export const getTimelineApiReminderTemplatesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof timelineApiReminderTemplatesRetrieve>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiReminderTemplatesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTimelineApiReminderTemplatesRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof timelineApiReminderTemplatesRetrieve>>> = ({ signal }) => timelineApiReminderTemplatesRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof timelineApiReminderTemplatesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type TimelineApiReminderTemplatesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof timelineApiReminderTemplatesRetrieve>>>
export type TimelineApiReminderTemplatesRetrieveQueryError = unknown


export function useTimelineApiReminderTemplatesRetrieve<TData = Awaited<ReturnType<typeof timelineApiReminderTemplatesRetrieve>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiReminderTemplatesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineApiReminderTemplatesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof timelineApiReminderTemplatesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineApiReminderTemplatesRetrieve<TData = Awaited<ReturnType<typeof timelineApiReminderTemplatesRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiReminderTemplatesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineApiReminderTemplatesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof timelineApiReminderTemplatesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineApiReminderTemplatesRetrieve<TData = Awaited<ReturnType<typeof timelineApiReminderTemplatesRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiReminderTemplatesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useTimelineApiReminderTemplatesRetrieve<TData = Awaited<ReturnType<typeof timelineApiReminderTemplatesRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiReminderTemplatesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getTimelineApiReminderTemplatesRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Ø¯Ø±ÛŒØ§ÙØª Ù‚Ø§Ù„Ø¨ Ø¨Ø± Ø§Ø³Ø§Ø³ Ù†ÙˆØ¹ Ø¢Ø²Ù…Ø§ÛŒØ´
 */
export const timelineApiReminderTemplatesByTestTypeRetrieve = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<ReminderTemplate>(
      {url: `/timeline/api/reminder-templates/by_test_type/`, method: 'GET', signal
    },
      options);
    }
  

export const getTimelineApiReminderTemplatesByTestTypeRetrieveQueryKey = () => {
    return [`/timeline/api/reminder-templates/by_test_type/`] as const;
    }

    
export const getTimelineApiReminderTemplatesByTestTypeRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof timelineApiReminderTemplatesByTestTypeRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiReminderTemplatesByTestTypeRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTimelineApiReminderTemplatesByTestTypeRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof timelineApiReminderTemplatesByTestTypeRetrieve>>> = ({ signal }) => timelineApiReminderTemplatesByTestTypeRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof timelineApiReminderTemplatesByTestTypeRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type TimelineApiReminderTemplatesByTestTypeRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof timelineApiReminderTemplatesByTestTypeRetrieve>>>
export type TimelineApiReminderTemplatesByTestTypeRetrieveQueryError = unknown


export function useTimelineApiReminderTemplatesByTestTypeRetrieve<TData = Awaited<ReturnType<typeof timelineApiReminderTemplatesByTestTypeRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiReminderTemplatesByTestTypeRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineApiReminderTemplatesByTestTypeRetrieve>>,
          TError,
          Awaited<ReturnType<typeof timelineApiReminderTemplatesByTestTypeRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineApiReminderTemplatesByTestTypeRetrieve<TData = Awaited<ReturnType<typeof timelineApiReminderTemplatesByTestTypeRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiReminderTemplatesByTestTypeRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineApiReminderTemplatesByTestTypeRetrieve>>,
          TError,
          Awaited<ReturnType<typeof timelineApiReminderTemplatesByTestTypeRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineApiReminderTemplatesByTestTypeRetrieve<TData = Awaited<ReturnType<typeof timelineApiReminderTemplatesByTestTypeRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiReminderTemplatesByTestTypeRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useTimelineApiReminderTemplatesByTestTypeRetrieve<TData = Awaited<ReturnType<typeof timelineApiReminderTemplatesByTestTypeRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiReminderTemplatesByTestTypeRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getTimelineApiReminderTemplatesByTestTypeRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª ÛŒØ§Ø¯Ø¢ÙˆØ±Ù‡Ø§ÛŒ Ø¢Ø²Ù…Ø§ÛŒØ´Ø§Øª
 */
export const timelineApiRemindersList = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<TestReminder[]>(
      {url: `/timeline/api/reminders/`, method: 'GET', signal
    },
      options);
    }
  

export const getTimelineApiRemindersListQueryKey = () => {
    return [`/timeline/api/reminders/`] as const;
    }

    
export const getTimelineApiRemindersListQueryOptions = <TData = Awaited<ReturnType<typeof timelineApiRemindersList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiRemindersList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTimelineApiRemindersListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof timelineApiRemindersList>>> = ({ signal }) => timelineApiRemindersList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof timelineApiRemindersList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type TimelineApiRemindersListQueryResult = NonNullable<Awaited<ReturnType<typeof timelineApiRemindersList>>>
export type TimelineApiRemindersListQueryError = unknown


export function useTimelineApiRemindersList<TData = Awaited<ReturnType<typeof timelineApiRemindersList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiRemindersList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineApiRemindersList>>,
          TError,
          Awaited<ReturnType<typeof timelineApiRemindersList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineApiRemindersList<TData = Awaited<ReturnType<typeof timelineApiRemindersList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiRemindersList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineApiRemindersList>>,
          TError,
          Awaited<ReturnType<typeof timelineApiRemindersList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineApiRemindersList<TData = Awaited<ReturnType<typeof timelineApiRemindersList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiRemindersList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useTimelineApiRemindersList<TData = Awaited<ReturnType<typeof timelineApiRemindersList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiRemindersList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getTimelineApiRemindersListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª ÛŒØ§Ø¯Ø¢ÙˆØ±Ù‡Ø§ÛŒ Ø¢Ø²Ù…Ø§ÛŒØ´Ø§Øª
 */
export const timelineApiRemindersCreate = (
    testReminder: NonReadonly<TestReminder>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<TestReminder>(
      {url: `/timeline/api/reminders/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: testReminder, signal
    },
      options);
    }
  


export const getTimelineApiRemindersCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineApiRemindersCreate>>, TError,{data: NonReadonly<TestReminder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof timelineApiRemindersCreate>>, TError,{data: NonReadonly<TestReminder>}, TContext> => {

const mutationKey = ['timelineApiRemindersCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof timelineApiRemindersCreate>>, {data: NonReadonly<TestReminder>}> = (props) => {
          const {data} = props ?? {};

          return  timelineApiRemindersCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TimelineApiRemindersCreateMutationResult = NonNullable<Awaited<ReturnType<typeof timelineApiRemindersCreate>>>
    export type TimelineApiRemindersCreateMutationBody = NonReadonly<TestReminder>
    export type TimelineApiRemindersCreateMutationError = unknown

    export const useTimelineApiRemindersCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineApiRemindersCreate>>, TError,{data: NonReadonly<TestReminder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof timelineApiRemindersCreate>>,
        TError,
        {data: NonReadonly<TestReminder>},
        TContext
      > => {

      const mutationOptions = getTimelineApiRemindersCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª ÛŒØ§Ø¯Ø¢ÙˆØ±Ù‡Ø§ÛŒ Ø¢Ø²Ù…Ø§ÛŒØ´Ø§Øª
 */
export const timelineApiRemindersRetrieve = (
    id: string,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<TestReminder>(
      {url: `/timeline/api/reminders/${id}/`, method: 'GET', signal
    },
      options);
    }
  

export const getTimelineApiRemindersRetrieveQueryKey = (id?: string,) => {
    return [`/timeline/api/reminders/${id}/`] as const;
    }

    
export const getTimelineApiRemindersRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof timelineApiRemindersRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiRemindersRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTimelineApiRemindersRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof timelineApiRemindersRetrieve>>> = ({ signal }) => timelineApiRemindersRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof timelineApiRemindersRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type TimelineApiRemindersRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof timelineApiRemindersRetrieve>>>
export type TimelineApiRemindersRetrieveQueryError = unknown


export function useTimelineApiRemindersRetrieve<TData = Awaited<ReturnType<typeof timelineApiRemindersRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiRemindersRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineApiRemindersRetrieve>>,
          TError,
          Awaited<ReturnType<typeof timelineApiRemindersRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineApiRemindersRetrieve<TData = Awaited<ReturnType<typeof timelineApiRemindersRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiRemindersRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineApiRemindersRetrieve>>,
          TError,
          Awaited<ReturnType<typeof timelineApiRemindersRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineApiRemindersRetrieve<TData = Awaited<ReturnType<typeof timelineApiRemindersRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiRemindersRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useTimelineApiRemindersRetrieve<TData = Awaited<ReturnType<typeof timelineApiRemindersRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiRemindersRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getTimelineApiRemindersRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª ÛŒØ§Ø¯Ø¢ÙˆØ±Ù‡Ø§ÛŒ Ø¢Ø²Ù…Ø§ÛŒØ´Ø§Øª
 */
export const timelineApiRemindersUpdate = (
    id: string,
    testReminder: NonReadonly<TestReminder>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<TestReminder>(
      {url: `/timeline/api/reminders/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: testReminder
    },
      options);
    }
  


export const getTimelineApiRemindersUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineApiRemindersUpdate>>, TError,{id: string;data: NonReadonly<TestReminder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof timelineApiRemindersUpdate>>, TError,{id: string;data: NonReadonly<TestReminder>}, TContext> => {

const mutationKey = ['timelineApiRemindersUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof timelineApiRemindersUpdate>>, {id: string;data: NonReadonly<TestReminder>}> = (props) => {
          const {id,data} = props ?? {};

          return  timelineApiRemindersUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TimelineApiRemindersUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof timelineApiRemindersUpdate>>>
    export type TimelineApiRemindersUpdateMutationBody = NonReadonly<TestReminder>
    export type TimelineApiRemindersUpdateMutationError = unknown

    export const useTimelineApiRemindersUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineApiRemindersUpdate>>, TError,{id: string;data: NonReadonly<TestReminder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof timelineApiRemindersUpdate>>,
        TError,
        {id: string;data: NonReadonly<TestReminder>},
        TContext
      > => {

      const mutationOptions = getTimelineApiRemindersUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª ÛŒØ§Ø¯Ø¢ÙˆØ±Ù‡Ø§ÛŒ Ø¢Ø²Ù…Ø§ÛŒØ´Ø§Øª
 */
export const timelineApiRemindersPartialUpdate = (
    id: string,
    patchedTestReminder: NonReadonly<PatchedTestReminder>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<TestReminder>(
      {url: `/timeline/api/reminders/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedTestReminder
    },
      options);
    }
  


export const getTimelineApiRemindersPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineApiRemindersPartialUpdate>>, TError,{id: string;data: NonReadonly<PatchedTestReminder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof timelineApiRemindersPartialUpdate>>, TError,{id: string;data: NonReadonly<PatchedTestReminder>}, TContext> => {

const mutationKey = ['timelineApiRemindersPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof timelineApiRemindersPartialUpdate>>, {id: string;data: NonReadonly<PatchedTestReminder>}> = (props) => {
          const {id,data} = props ?? {};

          return  timelineApiRemindersPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TimelineApiRemindersPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof timelineApiRemindersPartialUpdate>>>
    export type TimelineApiRemindersPartialUpdateMutationBody = NonReadonly<PatchedTestReminder>
    export type TimelineApiRemindersPartialUpdateMutationError = unknown

    export const useTimelineApiRemindersPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineApiRemindersPartialUpdate>>, TError,{id: string;data: NonReadonly<PatchedTestReminder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof timelineApiRemindersPartialUpdate>>,
        TError,
        {id: string;data: NonReadonly<PatchedTestReminder>},
        TContext
      > => {

      const mutationOptions = getTimelineApiRemindersPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª ÛŒØ§Ø¯Ø¢ÙˆØ±Ù‡Ø§ÛŒ Ø¢Ø²Ù…Ø§ÛŒØ´Ø§Øª
 */
export const timelineApiRemindersDestroy = (
    id: string,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<null>(
      {url: `/timeline/api/reminders/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getTimelineApiRemindersDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineApiRemindersDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof timelineApiRemindersDestroy>>, TError,{id: string}, TContext> => {

const mutationKey = ['timelineApiRemindersDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof timelineApiRemindersDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  timelineApiRemindersDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TimelineApiRemindersDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof timelineApiRemindersDestroy>>>
    
    export type TimelineApiRemindersDestroyMutationError = unknown

    export const useTimelineApiRemindersDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineApiRemindersDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof timelineApiRemindersDestroy>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getTimelineApiRemindersDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Ø¹Ù„Ø§Ù…Øªâ€ŒÚ¯Ø°Ø§Ø±ÛŒ ÛŒØ§Ø¯Ø¢ÙˆØ±ÛŒ Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯Ù‡
 */
export const timelineApiRemindersMarkCompletedCreate = (
    id: string,
    testReminder: NonReadonly<TestReminder>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<TestReminder>(
      {url: `/timeline/api/reminders/${id}/mark_completed/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: testReminder, signal
    },
      options);
    }
  


export const getTimelineApiRemindersMarkCompletedCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineApiRemindersMarkCompletedCreate>>, TError,{id: string;data: NonReadonly<TestReminder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof timelineApiRemindersMarkCompletedCreate>>, TError,{id: string;data: NonReadonly<TestReminder>}, TContext> => {

const mutationKey = ['timelineApiRemindersMarkCompletedCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof timelineApiRemindersMarkCompletedCreate>>, {id: string;data: NonReadonly<TestReminder>}> = (props) => {
          const {id,data} = props ?? {};

          return  timelineApiRemindersMarkCompletedCreate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TimelineApiRemindersMarkCompletedCreateMutationResult = NonNullable<Awaited<ReturnType<typeof timelineApiRemindersMarkCompletedCreate>>>
    export type TimelineApiRemindersMarkCompletedCreateMutationBody = NonReadonly<TestReminder>
    export type TimelineApiRemindersMarkCompletedCreateMutationError = unknown

    export const useTimelineApiRemindersMarkCompletedCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineApiRemindersMarkCompletedCreate>>, TError,{id: string;data: NonReadonly<TestReminder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof timelineApiRemindersMarkCompletedCreate>>,
        TError,
        {id: string;data: NonReadonly<TestReminder>},
        TContext
      > => {

      const mutationOptions = getTimelineApiRemindersMarkCompletedCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Ø§ÛŒØ¬Ø§Ø¯ ÛŒØ§Ø¯Ø¢ÙˆØ±ÛŒ Ø§Ø² Ù‚Ø§Ù„Ø¨
 */
export const timelineApiRemindersCreateFromTemplateCreate = (
    testReminder: NonReadonly<TestReminder>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<TestReminder>(
      {url: `/timeline/api/reminders/create_from_template/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: testReminder, signal
    },
      options);
    }
  


export const getTimelineApiRemindersCreateFromTemplateCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineApiRemindersCreateFromTemplateCreate>>, TError,{data: NonReadonly<TestReminder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof timelineApiRemindersCreateFromTemplateCreate>>, TError,{data: NonReadonly<TestReminder>}, TContext> => {

const mutationKey = ['timelineApiRemindersCreateFromTemplateCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof timelineApiRemindersCreateFromTemplateCreate>>, {data: NonReadonly<TestReminder>}> = (props) => {
          const {data} = props ?? {};

          return  timelineApiRemindersCreateFromTemplateCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TimelineApiRemindersCreateFromTemplateCreateMutationResult = NonNullable<Awaited<ReturnType<typeof timelineApiRemindersCreateFromTemplateCreate>>>
    export type TimelineApiRemindersCreateFromTemplateCreateMutationBody = NonReadonly<TestReminder>
    export type TimelineApiRemindersCreateFromTemplateCreateMutationError = unknown

    export const useTimelineApiRemindersCreateFromTemplateCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineApiRemindersCreateFromTemplateCreate>>, TError,{data: NonReadonly<TestReminder>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof timelineApiRemindersCreateFromTemplateCreate>>,
        TError,
        {data: NonReadonly<TestReminder>},
        TContext
      > => {

      const mutationOptions = getTimelineApiRemindersCreateFromTemplateCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ÛŒØ§Ø¯Ø¢ÙˆØ±Ù‡Ø§ÛŒ Ø¹Ù‚Ø¨â€ŒØ§ÙØªØ§Ø¯Ù‡
 */
export const timelineApiRemindersOverdueRemindersRetrieve = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<TestReminder>(
      {url: `/timeline/api/reminders/overdue_reminders/`, method: 'GET', signal
    },
      options);
    }
  

export const getTimelineApiRemindersOverdueRemindersRetrieveQueryKey = () => {
    return [`/timeline/api/reminders/overdue_reminders/`] as const;
    }

    
export const getTimelineApiRemindersOverdueRemindersRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof timelineApiRemindersOverdueRemindersRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiRemindersOverdueRemindersRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTimelineApiRemindersOverdueRemindersRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof timelineApiRemindersOverdueRemindersRetrieve>>> = ({ signal }) => timelineApiRemindersOverdueRemindersRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof timelineApiRemindersOverdueRemindersRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type TimelineApiRemindersOverdueRemindersRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof timelineApiRemindersOverdueRemindersRetrieve>>>
export type TimelineApiRemindersOverdueRemindersRetrieveQueryError = unknown


export function useTimelineApiRemindersOverdueRemindersRetrieve<TData = Awaited<ReturnType<typeof timelineApiRemindersOverdueRemindersRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiRemindersOverdueRemindersRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineApiRemindersOverdueRemindersRetrieve>>,
          TError,
          Awaited<ReturnType<typeof timelineApiRemindersOverdueRemindersRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineApiRemindersOverdueRemindersRetrieve<TData = Awaited<ReturnType<typeof timelineApiRemindersOverdueRemindersRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiRemindersOverdueRemindersRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineApiRemindersOverdueRemindersRetrieve>>,
          TError,
          Awaited<ReturnType<typeof timelineApiRemindersOverdueRemindersRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineApiRemindersOverdueRemindersRetrieve<TData = Awaited<ReturnType<typeof timelineApiRemindersOverdueRemindersRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiRemindersOverdueRemindersRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useTimelineApiRemindersOverdueRemindersRetrieve<TData = Awaited<ReturnType<typeof timelineApiRemindersOverdueRemindersRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiRemindersOverdueRemindersRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getTimelineApiRemindersOverdueRemindersRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Ø¯Ø±ÛŒØ§ÙØª ÛŒØ§Ø¯Ø¢ÙˆØ±Ù‡Ø§ÛŒ ÛŒÚ© Ø¨ÛŒÙ…Ø§Ø± Ø®Ø§Øµ
 */
export const timelineApiRemindersPatientRemindersRetrieve = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<TestReminder>(
      {url: `/timeline/api/reminders/patient_reminders/`, method: 'GET', signal
    },
      options);
    }
  

export const getTimelineApiRemindersPatientRemindersRetrieveQueryKey = () => {
    return [`/timeline/api/reminders/patient_reminders/`] as const;
    }

    
export const getTimelineApiRemindersPatientRemindersRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof timelineApiRemindersPatientRemindersRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiRemindersPatientRemindersRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTimelineApiRemindersPatientRemindersRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof timelineApiRemindersPatientRemindersRetrieve>>> = ({ signal }) => timelineApiRemindersPatientRemindersRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof timelineApiRemindersPatientRemindersRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type TimelineApiRemindersPatientRemindersRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof timelineApiRemindersPatientRemindersRetrieve>>>
export type TimelineApiRemindersPatientRemindersRetrieveQueryError = unknown


export function useTimelineApiRemindersPatientRemindersRetrieve<TData = Awaited<ReturnType<typeof timelineApiRemindersPatientRemindersRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiRemindersPatientRemindersRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineApiRemindersPatientRemindersRetrieve>>,
          TError,
          Awaited<ReturnType<typeof timelineApiRemindersPatientRemindersRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineApiRemindersPatientRemindersRetrieve<TData = Awaited<ReturnType<typeof timelineApiRemindersPatientRemindersRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiRemindersPatientRemindersRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineApiRemindersPatientRemindersRetrieve>>,
          TError,
          Awaited<ReturnType<typeof timelineApiRemindersPatientRemindersRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineApiRemindersPatientRemindersRetrieve<TData = Awaited<ReturnType<typeof timelineApiRemindersPatientRemindersRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiRemindersPatientRemindersRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useTimelineApiRemindersPatientRemindersRetrieve<TData = Awaited<ReturnType<typeof timelineApiRemindersPatientRemindersRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiRemindersPatientRemindersRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getTimelineApiRemindersPatientRemindersRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ÛŒØ§Ø¯Ø¢ÙˆØ±Ù‡Ø§ÛŒ Ø¢ØªÛŒ (Ø¯Ø± Û· Ø±ÙˆØ² Ø¢ÛŒÙ†Ø¯Ù‡)
 */
export const timelineApiRemindersUpcomingRemindersRetrieve = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<TestReminder>(
      {url: `/timeline/api/reminders/upcoming_reminders/`, method: 'GET', signal
    },
      options);
    }
  

export const getTimelineApiRemindersUpcomingRemindersRetrieveQueryKey = () => {
    return [`/timeline/api/reminders/upcoming_reminders/`] as const;
    }

    
export const getTimelineApiRemindersUpcomingRemindersRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof timelineApiRemindersUpcomingRemindersRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiRemindersUpcomingRemindersRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTimelineApiRemindersUpcomingRemindersRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof timelineApiRemindersUpcomingRemindersRetrieve>>> = ({ signal }) => timelineApiRemindersUpcomingRemindersRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof timelineApiRemindersUpcomingRemindersRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type TimelineApiRemindersUpcomingRemindersRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof timelineApiRemindersUpcomingRemindersRetrieve>>>
export type TimelineApiRemindersUpcomingRemindersRetrieveQueryError = unknown


export function useTimelineApiRemindersUpcomingRemindersRetrieve<TData = Awaited<ReturnType<typeof timelineApiRemindersUpcomingRemindersRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiRemindersUpcomingRemindersRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineApiRemindersUpcomingRemindersRetrieve>>,
          TError,
          Awaited<ReturnType<typeof timelineApiRemindersUpcomingRemindersRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineApiRemindersUpcomingRemindersRetrieve<TData = Awaited<ReturnType<typeof timelineApiRemindersUpcomingRemindersRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiRemindersUpcomingRemindersRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineApiRemindersUpcomingRemindersRetrieve>>,
          TError,
          Awaited<ReturnType<typeof timelineApiRemindersUpcomingRemindersRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineApiRemindersUpcomingRemindersRetrieve<TData = Awaited<ReturnType<typeof timelineApiRemindersUpcomingRemindersRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiRemindersUpcomingRemindersRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useTimelineApiRemindersUpcomingRemindersRetrieve<TData = Awaited<ReturnType<typeof timelineApiRemindersUpcomingRemindersRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiRemindersUpcomingRemindersRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getTimelineApiRemindersUpcomingRemindersRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª ØªØ§ÛŒÙ…â€ŒÙ„Ø§ÛŒÙ† Ù¾Ø²Ø´Ú©ÛŒ
 */
export const timelineApiTimelineList = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<MedicalTimeline[]>(
      {url: `/timeline/api/timeline/`, method: 'GET', signal
    },
      options);
    }
  

export const getTimelineApiTimelineListQueryKey = () => {
    return [`/timeline/api/timeline/`] as const;
    }

    
export const getTimelineApiTimelineListQueryOptions = <TData = Awaited<ReturnType<typeof timelineApiTimelineList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiTimelineList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTimelineApiTimelineListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof timelineApiTimelineList>>> = ({ signal }) => timelineApiTimelineList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof timelineApiTimelineList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type TimelineApiTimelineListQueryResult = NonNullable<Awaited<ReturnType<typeof timelineApiTimelineList>>>
export type TimelineApiTimelineListQueryError = unknown


export function useTimelineApiTimelineList<TData = Awaited<ReturnType<typeof timelineApiTimelineList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiTimelineList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineApiTimelineList>>,
          TError,
          Awaited<ReturnType<typeof timelineApiTimelineList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineApiTimelineList<TData = Awaited<ReturnType<typeof timelineApiTimelineList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiTimelineList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineApiTimelineList>>,
          TError,
          Awaited<ReturnType<typeof timelineApiTimelineList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineApiTimelineList<TData = Awaited<ReturnType<typeof timelineApiTimelineList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiTimelineList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useTimelineApiTimelineList<TData = Awaited<ReturnType<typeof timelineApiTimelineList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiTimelineList>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getTimelineApiTimelineListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª ØªØ§ÛŒÙ…â€ŒÙ„Ø§ÛŒÙ† Ù¾Ø²Ø´Ú©ÛŒ
 */
export const timelineApiTimelineCreate = (
    medicalTimeline: NonReadonly<MedicalTimeline>,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<MedicalTimeline>(
      {url: `/timeline/api/timeline/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: medicalTimeline, signal
    },
      options);
    }
  


export const getTimelineApiTimelineCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineApiTimelineCreate>>, TError,{data: NonReadonly<MedicalTimeline>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof timelineApiTimelineCreate>>, TError,{data: NonReadonly<MedicalTimeline>}, TContext> => {

const mutationKey = ['timelineApiTimelineCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof timelineApiTimelineCreate>>, {data: NonReadonly<MedicalTimeline>}> = (props) => {
          const {data} = props ?? {};

          return  timelineApiTimelineCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TimelineApiTimelineCreateMutationResult = NonNullable<Awaited<ReturnType<typeof timelineApiTimelineCreate>>>
    export type TimelineApiTimelineCreateMutationBody = NonReadonly<MedicalTimeline>
    export type TimelineApiTimelineCreateMutationError = unknown

    export const useTimelineApiTimelineCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineApiTimelineCreate>>, TError,{data: NonReadonly<MedicalTimeline>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof timelineApiTimelineCreate>>,
        TError,
        {data: NonReadonly<MedicalTimeline>},
        TContext
      > => {

      const mutationOptions = getTimelineApiTimelineCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª ØªØ§ÛŒÙ…â€ŒÙ„Ø§ÛŒÙ† Ù¾Ø²Ø´Ú©ÛŒ
 */
export const timelineApiTimelineRetrieve = (
    id: string,
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<MedicalTimeline>(
      {url: `/timeline/api/timeline/${id}/`, method: 'GET', signal
    },
      options);
    }
  

export const getTimelineApiTimelineRetrieveQueryKey = (id?: string,) => {
    return [`/timeline/api/timeline/${id}/`] as const;
    }

    
export const getTimelineApiTimelineRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof timelineApiTimelineRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiTimelineRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTimelineApiTimelineRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof timelineApiTimelineRetrieve>>> = ({ signal }) => timelineApiTimelineRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof timelineApiTimelineRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type TimelineApiTimelineRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof timelineApiTimelineRetrieve>>>
export type TimelineApiTimelineRetrieveQueryError = unknown


export function useTimelineApiTimelineRetrieve<TData = Awaited<ReturnType<typeof timelineApiTimelineRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiTimelineRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineApiTimelineRetrieve>>,
          TError,
          Awaited<ReturnType<typeof timelineApiTimelineRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineApiTimelineRetrieve<TData = Awaited<ReturnType<typeof timelineApiTimelineRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiTimelineRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineApiTimelineRetrieve>>,
          TError,
          Awaited<ReturnType<typeof timelineApiTimelineRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineApiTimelineRetrieve<TData = Awaited<ReturnType<typeof timelineApiTimelineRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiTimelineRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useTimelineApiTimelineRetrieve<TData = Awaited<ReturnType<typeof timelineApiTimelineRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiTimelineRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getTimelineApiTimelineRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª ØªØ§ÛŒÙ…â€ŒÙ„Ø§ÛŒÙ† Ù¾Ø²Ø´Ú©ÛŒ
 */
export const timelineApiTimelineUpdate = (
    id: string,
    medicalTimeline: NonReadonly<MedicalTimeline>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<MedicalTimeline>(
      {url: `/timeline/api/timeline/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: medicalTimeline
    },
      options);
    }
  


export const getTimelineApiTimelineUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineApiTimelineUpdate>>, TError,{id: string;data: NonReadonly<MedicalTimeline>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof timelineApiTimelineUpdate>>, TError,{id: string;data: NonReadonly<MedicalTimeline>}, TContext> => {

const mutationKey = ['timelineApiTimelineUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof timelineApiTimelineUpdate>>, {id: string;data: NonReadonly<MedicalTimeline>}> = (props) => {
          const {id,data} = props ?? {};

          return  timelineApiTimelineUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TimelineApiTimelineUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof timelineApiTimelineUpdate>>>
    export type TimelineApiTimelineUpdateMutationBody = NonReadonly<MedicalTimeline>
    export type TimelineApiTimelineUpdateMutationError = unknown

    export const useTimelineApiTimelineUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineApiTimelineUpdate>>, TError,{id: string;data: NonReadonly<MedicalTimeline>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof timelineApiTimelineUpdate>>,
        TError,
        {id: string;data: NonReadonly<MedicalTimeline>},
        TContext
      > => {

      const mutationOptions = getTimelineApiTimelineUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª ØªØ§ÛŒÙ…â€ŒÙ„Ø§ÛŒÙ† Ù¾Ø²Ø´Ú©ÛŒ
 */
export const timelineApiTimelinePartialUpdate = (
    id: string,
    patchedMedicalTimeline: NonReadonly<PatchedMedicalTimeline>,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<MedicalTimeline>(
      {url: `/timeline/api/timeline/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedMedicalTimeline
    },
      options);
    }
  


export const getTimelineApiTimelinePartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineApiTimelinePartialUpdate>>, TError,{id: string;data: NonReadonly<PatchedMedicalTimeline>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof timelineApiTimelinePartialUpdate>>, TError,{id: string;data: NonReadonly<PatchedMedicalTimeline>}, TContext> => {

const mutationKey = ['timelineApiTimelinePartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof timelineApiTimelinePartialUpdate>>, {id: string;data: NonReadonly<PatchedMedicalTimeline>}> = (props) => {
          const {id,data} = props ?? {};

          return  timelineApiTimelinePartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TimelineApiTimelinePartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof timelineApiTimelinePartialUpdate>>>
    export type TimelineApiTimelinePartialUpdateMutationBody = NonReadonly<PatchedMedicalTimeline>
    export type TimelineApiTimelinePartialUpdateMutationError = unknown

    export const useTimelineApiTimelinePartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineApiTimelinePartialUpdate>>, TError,{id: string;data: NonReadonly<PatchedMedicalTimeline>}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof timelineApiTimelinePartialUpdate>>,
        TError,
        {id: string;data: NonReadonly<PatchedMedicalTimeline>},
        TContext
      > => {

      const mutationOptions = getTimelineApiTimelinePartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ViewSet Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª ØªØ§ÛŒÙ…â€ŒÙ„Ø§ÛŒÙ† Ù¾Ø²Ø´Ú©ÛŒ
 */
export const timelineApiTimelineDestroy = (
    id: string,
 options?: SecondParameter<typeof createAxiosInstance>,) => {
      
      
      return createAxiosInstance<null>(
      {url: `/timeline/api/timeline/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getTimelineApiTimelineDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineApiTimelineDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof timelineApiTimelineDestroy>>, TError,{id: string}, TContext> => {

const mutationKey = ['timelineApiTimelineDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof timelineApiTimelineDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  timelineApiTimelineDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TimelineApiTimelineDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof timelineApiTimelineDestroy>>>
    
    export type TimelineApiTimelineDestroyMutationError = unknown

    export const useTimelineApiTimelineDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineApiTimelineDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof timelineApiTimelineDestroy>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getTimelineApiTimelineDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Ø¯Ø±ÛŒØ§ÙØª ØªØ§ÛŒÙ…â€ŒÙ„Ø§ÛŒÙ† ÛŒÚ© Ø¨ÛŒÙ…Ø§Ø± Ø®Ø§Øµ
 */
export const timelineApiTimelinePatientTimelineRetrieve = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<MedicalTimeline>(
      {url: `/timeline/api/timeline/patient_timeline/`, method: 'GET', signal
    },
      options);
    }
  

export const getTimelineApiTimelinePatientTimelineRetrieveQueryKey = () => {
    return [`/timeline/api/timeline/patient_timeline/`] as const;
    }

    
export const getTimelineApiTimelinePatientTimelineRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof timelineApiTimelinePatientTimelineRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiTimelinePatientTimelineRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTimelineApiTimelinePatientTimelineRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof timelineApiTimelinePatientTimelineRetrieve>>> = ({ signal }) => timelineApiTimelinePatientTimelineRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof timelineApiTimelinePatientTimelineRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type TimelineApiTimelinePatientTimelineRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof timelineApiTimelinePatientTimelineRetrieve>>>
export type TimelineApiTimelinePatientTimelineRetrieveQueryError = unknown


export function useTimelineApiTimelinePatientTimelineRetrieve<TData = Awaited<ReturnType<typeof timelineApiTimelinePatientTimelineRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiTimelinePatientTimelineRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineApiTimelinePatientTimelineRetrieve>>,
          TError,
          Awaited<ReturnType<typeof timelineApiTimelinePatientTimelineRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineApiTimelinePatientTimelineRetrieve<TData = Awaited<ReturnType<typeof timelineApiTimelinePatientTimelineRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiTimelinePatientTimelineRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineApiTimelinePatientTimelineRetrieve>>,
          TError,
          Awaited<ReturnType<typeof timelineApiTimelinePatientTimelineRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineApiTimelinePatientTimelineRetrieve<TData = Awaited<ReturnType<typeof timelineApiTimelinePatientTimelineRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiTimelinePatientTimelineRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useTimelineApiTimelinePatientTimelineRetrieve<TData = Awaited<ReturnType<typeof timelineApiTimelinePatientTimelineRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiTimelinePatientTimelineRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getTimelineApiTimelinePatientTimelineRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Ø®Ù„Ø§ØµÙ‡â€ŒØ§ÛŒ Ø§Ø² ØªØ§ÛŒÙ…â€ŒÙ„Ø§ÛŒÙ† Ø¨ÛŒÙ…Ø§Ø±
 */
export const timelineApiTimelineTimelineSummaryRetrieve = (
    
 options?: SecondParameter<typeof createAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return createAxiosInstance<MedicalTimeline>(
      {url: `/timeline/api/timeline/timeline_summary/`, method: 'GET', signal
    },
      options);
    }
  

export const getTimelineApiTimelineTimelineSummaryRetrieveQueryKey = () => {
    return [`/timeline/api/timeline/timeline_summary/`] as const;
    }

    
export const getTimelineApiTimelineTimelineSummaryRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof timelineApiTimelineTimelineSummaryRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiTimelineTimelineSummaryRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTimelineApiTimelineTimelineSummaryRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof timelineApiTimelineTimelineSummaryRetrieve>>> = ({ signal }) => timelineApiTimelineTimelineSummaryRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof timelineApiTimelineTimelineSummaryRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type TimelineApiTimelineTimelineSummaryRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof timelineApiTimelineTimelineSummaryRetrieve>>>
export type TimelineApiTimelineTimelineSummaryRetrieveQueryError = unknown


export function useTimelineApiTimelineTimelineSummaryRetrieve<TData = Awaited<ReturnType<typeof timelineApiTimelineTimelineSummaryRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiTimelineTimelineSummaryRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineApiTimelineTimelineSummaryRetrieve>>,
          TError,
          Awaited<ReturnType<typeof timelineApiTimelineTimelineSummaryRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineApiTimelineTimelineSummaryRetrieve<TData = Awaited<ReturnType<typeof timelineApiTimelineTimelineSummaryRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiTimelineTimelineSummaryRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineApiTimelineTimelineSummaryRetrieve>>,
          TError,
          Awaited<ReturnType<typeof timelineApiTimelineTimelineSummaryRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineApiTimelineTimelineSummaryRetrieve<TData = Awaited<ReturnType<typeof timelineApiTimelineTimelineSummaryRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiTimelineTimelineSummaryRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useTimelineApiTimelineTimelineSummaryRetrieve<TData = Awaited<ReturnType<typeof timelineApiTimelineTimelineSummaryRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineApiTimelineTimelineSummaryRetrieve>>, TError, TData>>, request?: SecondParameter<typeof createAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getTimelineApiTimelineTimelineSummaryRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
